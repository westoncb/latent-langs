CONCEPT GeometricInteractionNets {
  PARAMETERS {
    d : Nat -- Ambient dimension
  }

  CONTEXT {
    TYPES {
      Symbol := String
      Port := (Symbol, Nat)
      Cell := (Symbol, List(Port))
      Net := (Set(Cell), Set(Port), Set((Port, Port)))

      Shape := CS(â„^d)
      Direction := {v âˆˆ ğ•Š^(d-1)} 
      EmbeddedNet := (Net, Map(Cell, Shape))
    }

    DEFINITIONS {
      Arity(s : Symbol) -> Nat
      Interaction(a b : Symbol) -> EmbeddedNet?
      Reduced(e : EmbeddedNet) -> Bool

      Sublevel(e : EmbeddedNet, v : Direction, t : â„) -> Bool := 
        âˆ€ (c, s) âˆˆ e.2 . âŸ¨Centroid(s), vâŸ© â‰¤ t

      Reduces(e e' : EmbeddedNet, S : InteractionSystem) -> Bool
      ReducesInMany(e e' : EmbeddedNet, S : InteractionSystem) -> Bool
    }
    
    NOTATION {
      INFIX "â†’â‚›" := Reduces
      INFIX "â†’*â‚›" := ReducesInMany
      DgmPHT^i_e(v) := PersistenceDiagram(Sublevel(e, v, ?), i)
      dI(e, e') := inf {Îµ | âˆƒ (Ï• Ïˆ : Sublevel(e, ?, ?) -> Sublevel(e', ?, ?)) . 
                              IsInterleaving(Ï•, Ïˆ, Îµ)}
    }

    STRUCTURES {
      STRUCTURE InteractionSystem {
        FIELD alphabet : Set(Symbol)
        FIELD rules : Map((Symbol, Symbol), EmbeddedNet)

        AXIOM WellFormedRules(a b : Symbol)(Î± : EmbeddedNet) :
          rules(a, b) = Î± IMPLIES (a âˆˆ alphabet âˆ§ b âˆˆ alphabet âˆ§ Reduced(Î±))

        AXIOM Symmetry(a b : Symbol) :
          Interaction(a, b) = Flip(Interaction(b, a))
          WHERE Flip((net, embed)) := (net, c â†¦ Reflect(embed(c)))
      }

      STRUCTURE EmbeddingPerturbation {
        FIELD Family : Map(Cell, FUNC(Shape) -> Shape)
        AXIOM Uniformity(Îµ : â„>0)(c : Cell) : 
          âˆ€ s . dH(Family(c)(s), s) â‰¤ Îµ
        AXIOM Homeomorphism(c : Cell) :  
          âˆ€ s . Family(c)|_s : s -> Family(c)(s) is homeomorphism
      }
    }
  }

  TRANSFORMERS {
    REWRITE EmbeddingShift(Îµ) : EmbeddedNet -> EmbeddedNet {
      MATCH (net, embed) 
      REWRITE (net, c â†¦ Translate(embed(c), Îµ))
    }

    REWRITE PullbackInteraction(S : InteractionSystem) : EmbeddedNet -> EmbeddedNet {
      MATCH (net, embed) 
      WHERE (a, b) â†¦ ((Ï‰_i), ps, ws) âˆˆ S.rules, (a, pa) âˆˆ net.1, (b, pb) âˆˆ net.1
      REWRITE (
        net âˆª {(Ï‰_i, pw)},
        embed âˆª {(Ï‰_i, pw) â†¦ ConvexHull{p | (p, _) âˆˆ ps âˆ§ p âˆˆ embed(a, pa) âˆª embed(b, pb)}}  
      )
    }
  }

  PROOFS {
    THEOREM InteractionStability {
      âˆ€ (S : InteractionSystem) (e e' Ãª : EmbeddedNet)(Îµ : â„â‰¥0) .
        e â†’â‚› e' âˆ§ dI(e, Ãª) â‰¤ Îµ â‡’ âˆƒ (Ãª' C : â„â‰¥0) . Ãª â†’â‚› Ãª' âˆ§ dI(e', Ãª') â‰¤ CÎµ 
    }
    PROOF {
      ASSUME S : InteractionSystem, 
             e e' Ãª : EmbeddedNet, Îµ : â„â‰¥0,
             e â†’â‚› e', dI(e, Ãª) â‰¤ Îµ
      
      LET (a, b) â†¦ ((Ï‰_i), ps, ws) âˆˆ S.rules 
        SUCH_THAT (e.1 âˆª {(a, _), (b, _)}, _) â†’â‚› e'

      dI(e, Ãª) â‰¤ Îµ
      â‡’ âˆƒ (Ï• Ïˆ : Sublevel(e, ?, ?) -> Sublevel(Ãª, ?, ?)) . 
          IsInterleaving(Ï•, Ïˆ, Îµ)
      â‡’ âˆƒ (Ï•' Ïˆ' : Sublevel(EmbeddingShift(Îµ)(Ï‰_i â†¦ ?), ?, ?) -> Sublevel(Ãª, ?, ?)) .
          IsInterleaving(Ï•', Ïˆ', CÎµ)
        BY ConvexityOfSublevels, StabilityOfEmbeddings
      â‡’ dI(EmbeddingShift(Îµ)(Ï‰_i â†¦ ?), PullbackInteraction(S)(Ãª)) â‰¤ CÎµ  
      â‡’ âˆƒ Ãª' . Ãª â†’â‚› Ãª' âˆ§ dI(e', Ãª') â‰¤ CÎµ

      TAKE Ãª' = PullbackInteraction(S)(Ãª), C = <CONSTANT>
    }

    THEOREM PersistentCombinators {
      âˆ€ (a b : Symbol)(â„“ : Nat)(Îµ : â„>0) .
        a âˆˆ Combinators âˆ§ b âˆˆ Combinators â‡’
        âˆƒ (Râ„“_Îµ : â„>0) . âˆ€ (e : EmbeddedNet) .
          Sublevel(e, Centroid(e.2(a))-Centroid(e.2(b)), ?) has [Îµ]-persistent â„“-dim feature â‡’
          âˆ€ (v : Direction) . DgmPHT^â„“_e(v) has [Râ„“_Îµ]-persistent feature
    }
    PROOF {
      SUFFICES_TO_SHOW âˆƒ (R0_Îµ : â„>0) . <STATEMENT> 
        BY Hurewicz âˆ§ DimensionalityReduction
      
      ASSUME a b : Symbol, Îµ : â„>0,
             e : EmbeddedNet,
             Sublevel(e, Centroid(e.2(a))-Centroid(e.2(b)), ?) has [Îµ]-persistent 0-dim feature

      Sublevel(e, Centroid(e.2(a))-Centroid(e.2(b)), ?) has [Îµ]-persistent 0-dim feature    
      â‡’ âˆƒ (t : â„) . Sublevel(e, Centroid(e.2(a))-Centroid(e.2(b)), t) =/= âˆ… âˆ§
                    Sublevel(e, Centroid(e.2(a))-Centroid(e.2(b)), t+Îµ) =/= âˆ…
        BY PersistenceImpliesNonEmptyIntervals
      â‡’ Sublevel(e', Centroid(e'.2(a))-Centroid(e'.2(b)), ?) =/= âˆ…  
        WHERE e â†’â‚› e'
        BY PullbackInteraction
      â‡’ âˆ€ (v : Direction) . DgmPHT^0_e'(v) has [R0_Îµ]-persistent feature
        WHERE R0_Îµ := <CONSTANT> 
        BY StabilityOfEmbeddings, Hausdorff-Gromov, ConvexityOfSublevels

      TAKE R0_Îµ := <CONSTANT>  
    }
      
    THEOREM EmbeddedNetApproximation {
      âˆ€ (e : EmbeddedNet | âˆ€ c . e.2(c) is n-manifold) 
        (Ï„ : â„>0, Îµ Î´ : â„>0 | Îµ < Ï„/2 âˆ§ Î´ < 1) .
      Prob[ âˆƒ (K : EmbeddedNet | K.1 = e.1 âˆ§ âˆ€ c . K.2(c) = AlphaComplex({x_i} âˆ© e.2(c))) .
              dI(e, K) â‰¤ CÎµ ] â‰¥ 1 - Î´
      WHERE {x_i} âŠ‚ â‹ƒ e.2 is (Îµ/2)-dense, C = <CONSTANT>      
    }
    PROOF {
      ASSUME e : EmbeddedNet, Ï„ Îµ : â„>0, Îµ < Ï„/2, Î´ : â„>0, Î´ < 1
      
      LET {x_i}_i âŠ‚ â‹ƒ e.2 with {x_i} is (Îµ/2)-dense, |{x_i}| = O((1/Îµ)^d)
      LET U := â‹ƒ_i B(x_i, Îµ)
      DEFINE K : EmbeddedNet {
        K.1 := e.1
        âˆ€ c . K.2(c) := AlphaComplex({x_i} âˆ© e.2(c))
      }
      
      âˆ€ c . e.2(c) â‰ƒ U âˆ© e.2(c) with probability â‰¥ 1 - Î´  
        BY NiyogiSmaleWeinberger, Assumption[Îµ < Ï„/2]
      âˆ€ c . U âˆ© e.2(c) â‰ƒ K.2(c)   
        BY NerveTheorem

      â‡’ âˆ€ c . âˆƒ (Ï•_c : e.2(c) -> K.2(c))(H_c : I Ã— e.2(c) -> e.2(c)) . 
          Ï•_c is Îµ-homotopy equivalence âˆ§
          H_c : id_c âˆ¼ Ï•_c with Im(H_c) âŠ‚ NÎµ(e.2(c))
        BY Assumption[Î´ < 1], NiyogiSmaleWeinberger, AlphaApproximation

      â‡’ dI(e, K) â‰¤ CÎµ with probability â‰¥ 1 - Î´
        WHERE C = <CONSTANT>
        BY {Ï•_c}_c is (CÎµ)-interleaving, 
           H_c moves points by â‰¤ 2Îµ, 
           StabilityOfEmbeddings  
    }

    THEOREM InteractionSensitivity {
      âˆ€ (S : InteractionSystem)(e e' : EmbeddedNet)(F : EmbeddingPerturbation) .
        e â†’â‚› e' â‡’ 
        âˆƒ (Ãª Ãª' C : â„â‰¥0) .
          Ãª.1 = e.1 âˆ§ Ãª'.1 = e'.1 âˆ§ 
          Ãª.2 = F.Family âˆ˜ e.2 âˆ§
          Ãª â†’â‚› Ãª' âˆ§ dI(e', Ãª') â‰¤ C(Îµ + dI(e.2(Ï‰), Ãª.2(Ï‰)))
        WHERE Îµ := sup{dH(s, F.Family(c)(s)) | c âˆˆ e.1, s âŠ† e.2(c)}
    }
    PROOF {  
      ASSUME S : InteractionSystem, e e' : EmbeddedNet,
             F : EmbeddingPerturbation,
             e â†’â‚› e' with (a, b) â†¦ ((Ï‰_i), ps, ws)
      
      DEFINE Ãª : EmbeddedNet {
        Ãª.1 := e.1
        Ãª.2 := F.Family âˆ˜ e.2
      }

      DEFINE ps' := [(F.Family(a)(p), q) | (p, q) âˆˆ ps âˆ© e.2(a)] ++
                    [(F.Family(b)(p), q) | (p, q) âˆˆ ps âˆ© e.2(b)]
      DEFINE Ãª' := PullbackInteraction(S)((Ãª.1, {(Ï‰_i, pw)} âˆª Ãª.2))
        WHERE ((Ï‰_i), pw, ?) := S.rules(a, b)
      
      HAVE Ãª â†’â‚› Ãª' 
        BY PullbackInteraction with (a, b) â†¦ ((Ï‰_i), ps', ws)
      
      HAVE dI(e'.2(Ï‰), Ãª'.2(Ï‰))
             â‰¤ dI(e'.2(Ï‰), ConvexHull(e.2(Ï‰))) +
               dI(ConvexHull(e.2(Ï‰)), ConvexHull(Ãª.2(Ï‰))) + 
               dI(ConvexHull(Ãª.2(Ï‰)), Ãª'.2(Ï‰))
             â‰¤ C(Îµ + dI(e.2(Ï‰), Ãª.2(Ï‰))) 
        WHERE C := <CONSTANT>
        BY ConvexityOfSublevels, StabilityOfEmbeddings, Hausdorff-Gromov
        
      TAKE C := <CONSTANT>
    }
  }

  EXAMPLES {
    EXAMPLE BraidInteractions : EmbeddedNet {
      LET X1 : Cell := ("X", [(0, 1)])
      LET X2 : Cell := ("X", [(1, 2)])  
      LET Y : Cell := ("Y", [(0, 1), (1, 2)])
      LET net : Net := ({X1, X2, Y}, 
                         {(0, 1), (0, 2), (1, 3), (1, 4)},
                         {((0, 1), (1, 3)), ((0, 2), (1, 4))})
      LET embed : Map(Cell, Shape) := {
        X1 â†¦ Rectangle(0, 0, 2, 1),  
        X2 â†¦ Rectangle(1, 1, 3, 2),
        Y â†¦ Polygon((1, 0), (2, 1), (1, 2), (0, 1))  
      }

      (net, embed)
    }

    EXAMPLE SystemForBraids : InteractionSystem {
      LET alphabet : Set(Symbol) := {"X", "Y"}
      LET rules : Map((Symbol, Symbol), EmbeddedNet) := {
        ("X", "Y") â†¦ BraidInteraction("X", "Y"),
        ("Y", "X") â†¦ BraidInteraction("Y", "X")
      }
      { alphabet, rules }
    }
  }
}  





CONCEPT GeometricSymbolicDuality {
  REQUIRES {
    GeometricInteractionNets: CONCEPT
    SymbolicInteractionNets: CONCEPT = InteractionCombinators
  }

  CONTEXT {
    STRUCTURES {
      STRUCTURE GeometricSymbolicCorrespondence {
        FIELD Geometric: GeometricInteractionNets.InteractionSystem
        FIELD Symbolic: SymbolicInteractionNets.InteractionSystem

        AXIOM ShapeTypeCorrespondence(a: Geometric.Alphabet, A: Symbolic.Alphabet) {
          âˆƒ(f: Geometric.Shape -> Symbolic.Agent) . 
            Geometric.Interaction(a, b) = (net, embed) IFF
            Symbolic.Interaction(f(a), f(b)) = (net, f âˆ˜ embed)
        }
        
        AXIOM ReductionCorrespondence(e_G: Geometric.EmbeddedNet, e_S: Symbolic.Net) {
          Geometric.Reduces(e_G, Geometric, e_G') IFF 
          Symbolic.Reduces(e_S, Symbolic, e_S') AND
          e_S' = (e_G'.Net, f âˆ˜ e_G'.Embedding)
        }
      }
    }
  }

  TRANSFORMERS {
    DERIVE DiscreteApproximation(e: Geometric.EmbeddedNet, Î´: Real) -> Symbolic.Net {
      DEFINE f = LAMBDA (s: Geometric.Shape) . MIN {A: Symbolic.Agent | d(A, s) <= Î´}
      RETURN (e.Net, f âˆ˜ e.Embedding) 
    }
    
    DERIVE ContinuousExtension(e: Symbolic.Net, Î´: Real) -> Geometric.EmbeddedNet {
      DEFINE f_inv = LAMBDA (A: Symbolic.Agent) . Union {s: Geometric.Shape | f(s) = A}
      RETURN (e.Net, f_inv âˆ˜ e.Agents)
    }
  }

  PROOFS {
    THEOREM Approximation {
      FORALL (e_G: Geometric.EmbeddedNet, e_S: Symbolic.Net, Î´: Real) {
        LET e_SÎ´ = DiscreteApproximation(e_G, Î´)
        LET e_GÎ´ = ContinuousExtension(e_S, Î´)
        
        d(e_G, e_GÎ´) <= 2Î´ AND d(e_S, e_SÎ´) <= 2Î´  
      }
      PROOF {
        d(e_G, e_GÎ´) 
          = d(e_G, ContinuousExtension(DiscreteApproximation(e_G, Î´), Î´))
          <= d(e_G, ContinuousExtension(e_G, Î´)) + d(ContinuousExtension(e_G, Î´), e_GÎ´)
          <= Î´ + Î´ = 2Î´
          BY Triangle inequality, Definitions of Approximation and Extension
        
        d(e_S, e_SÎ´)
          = d(e_S, DiscreteApproximation(ContinuousExtension(e_S, Î´), Î´))  
          <= d(e_S, DiscreteApproximation(e_S, Î´)) + d(DiscreteApproximation(e_S, Î´), e_SÎ´)
          <= Î´ + Î´ = 2Î´
          BY Triangle inequality, Definitions of Approximation and Extension
        QED  
      }
    }
    
    THEOREM DualityInvariance {
      FORALL (C: GeometricSymbolicCorrespondence, e_G: Geometric.EmbeddedNet, e_S: Symbolic.Net) {
        Geometric.ReducesInMany(e_G, C.Geometric, e_G') IFF
        Symbolic.ReducesInMany(e_S, C.Symbolic, e_S')
      }
      PROOF {
        ASSUME Geometric.ReducesInMany(e_G, C.Geometric, e_G') 
        
        e_G â†’* e_G' in C.Geometric
          IFF âˆ€i. e_G_i â†’ e_G_{i+1} in C.Geometric
          IFF âˆ€i. e_S_i â†’ e_S_{i+1} in C.Symbolic 
            WHERE e_S_i = (e_G_i.Net, f âˆ˜ e_G_i.Embedding)
          IFF e_S â†’* e_S' in C.Symbolic
            WHERE e_S' = (e_G'.Net, f âˆ˜ e_G'.Embedding)
          BY ReductionCorrespondence
        QED
      }
    }
  }

  EXAMPLES {
    EXAMPLE BooleanCircuits {
      LET G: GeometricInteractionNets.InteractionSystem {
        Alphabet = {Wire, And, Or, Not}
        Shapes = {Line, AndGate, OrGate, NotGate}
        
        Interaction(Wire, And) = (net_AND, embed_AND)
        Interaction(Wire, Or) = (net_OR, embed_OR)  
        Interaction(Wire, Not) = (net_NOT, embed_NOT)
      } 
      
      LET S: SymbolicInteractionNets.InteractionSystem {
        Alphabet = {W, A, O, N}
        
        Interaction(W, A) = (net_AND, Agent_AND)
        Interaction(W, O) = (net_OR, Agent_OR)
        Interaction(W, N) = (net_NOT, Agent_NOT)
      }

      DEFINE C: GeometricSymbolicCorrespondence {
        Geometric = G
        Symbolic = S
        
        f(Wire) = W
        f(And) = A  
        f(Or) = O
        f(Not) = N
      }

      THEN {
        FORALL (e_G: G.EmbeddedNet, e_S: S.Net) {
          G.ReducesInMany(e_G, G, e_G') IFF 
          S.ReducesInMany(e_S, S, e_S')
        }
      }
    }    
  }
}