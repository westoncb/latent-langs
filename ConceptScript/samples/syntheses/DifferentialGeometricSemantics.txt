CONCEPT DifferentialGeometricSemantics {
  PARAMETERS {
    n : Nat
    k : Nat
    Î£ : Vocabulary  
  }
  
  CONTEXT {
    TYPES {
      Vocabulary = SET(Symbol)
      Symbol = String
      
      SmoothManifold = {
        Dimension : Nat
        Atlas : SET(Chart)
        Tangent : FUNC(THIS, TangentBundle)
        Cotangent : FUNC(THIS, CotangentBundle)
      }
      
      Chart(M : SmoothManifold) = {
        Domain : OpenSet(M)
        Map : FUNC(Domain, EuclideanSpace(M.Dimension))
      }
      
      EuclideanSpace(n : Nat) = R^n
      
      VectorBundle(M : SmoothManifold, V : VectorSpace) = {
        TotalSpace : SmoothManifold
        BaseSpace : M
        Fiber : V
        Projection : FUNC(TotalSpace, BaseSpace)  
      }

      TangentBundle(M : SmoothManifold) = VectorBundle(M, R^(M.Dimension))
      CotangentBundle(M : SmoothManifold) = VectorBundle(M, DualSpace(R^(M.Dimension)))
      
      Transformation(V : VectorSpace, W : VectorSpace) = FUNC(V, W)
      Isomorphism(V : VectorSpace, W : VectorSpace) = Transformation(V, W)
        WHERE âˆƒ g : Transformation(W, V) . f âˆ˜ g = Identity(W) âˆ§ g âˆ˜ f = Identity(V)
        
      INDUCTIVE SyntacticType(n : Nat) {  
        CASE Atomic  
        CASE Product(SyntacticType(n), ..., SyntacticType(n))
        CASE Function(SyntacticType(n), SyntacticType(n))
        CASE Quotient(SyntacticType(n), Relation)
      }

      Model(T : SyntacticType(n))
        CASE T IS Atomic -> EuclideanSpace(n)
        CASE T IS Product(T1, ..., Tm) -> DirectProduct(Model(T1), ..., Model(Tm))
        CASE T IS Function(T1, T2) -> FUNC(Model(T1), Model(T2)) 
        CASE T IS Quotient(T', ~) -> Quotient(Model(T'), InterpretRelation(~))
      
      Denotation(e : Expression(Î£), T : SyntacticType(n)) = 
        IF "e : T" THEN Model(T) ELSE Void
      
      INDUCTIVE Expression(V : Vocabulary) {
        CASE Variable(Symbol)
        CASE Operation(Symbol, List(Expression(V)))  
      }
      
      DifferentialOperator(M : SmoothManifold, V : VectorBundle(M)) = 
        FUNC(Î“(M, V), Î“(M, V âŠ— Cotangent(M)))
        
      Connection(V : VectorBundle) = {
        CovariantDerivative : DifferentialOperator(V.BaseSpace, V)
      }
      
      Structure(n : Nat, k : Nat) = {
        Base : SmoothManifold
        VectorBundles : List(k)(VectorBundle(Base)) 
        Connections : List(k)(Connection(VectorBundles[i]))
      }
    }
    
    STRUCTURES {
      STRUCTURE TypingJudgment(V : Vocabulary, n : Nat, k : Nat) {
        FIELD Term : Expression(V)
        FIELD Type : SyntacticType(n)
        FIELD Structure : Structure(n, k)
        
        AXIOM TypeInference "e : T" WHERE "âŠ¢ e : T"
        AXIOM ModelConstruction "DâŸ¦eâŸ§ : Model(T)" WHERE "e : T"
        AXIOM Compositionality "DâŸ¦Operation(f, args)âŸ§ = FâŸ¦fâŸ§(DâŸ¦args[1]âŸ§, ..., DâŸ¦args[m]âŸ§)"
          WHERE "âŠ¢ f : T1 â†’ ... â†’ Tm â†’ T" AND "âŠ¢ args[i] : Ti"
        AXIOM Substitution "DâŸ¦e[x := e']âŸ§ = DâŸ¦eâŸ§(DâŸ¦e'âŸ§/x)" 
          WHERE "âŠ¢ e : T" AND "âŠ¢ e' : U" AND "x : U âˆˆ e" 
      }
      
      STRUCTURE InterpretedSymbol(f : Symbol) {
        FIELD Domain : List(SyntacticType(n))
        FIELD Codomain : SyntacticType(n)
        FIELD Implementation : FUNC(Model(Domain[1]), ..., Model(Domain[m])) -> Model(Codomain)
        
        AXIOM Typing "âŠ¢ f : Domain[1] â†’ ... â†’ Domain[m] â†’ Codomain"
        NOTATION "FâŸ¦fâŸ§" = Implementation(f)
      }
    }
    
    ASSERTIONS {
      ASSUME "Vocabulary Î£" HAS_SYMBOLS {
        "Vec" : "n â†’ Type"
          WITH "Model(Vec(k)) = EuclideanSpace(k)"  
        "âˆ‡" : "âˆ€ (n : Nat) (A : Type) . Vec(n) âŠ— A â†’ Vec(n) âŠ— A" 
          WITH "Model(âˆ‡) = CovariantDerivative"
        "+" : "âˆ€ (n : Nat) . Vec(n) âŠ— Vec(n) â†’ Vec(n)" 
          WITH "Model(+)(v, w) = v + w"
        "Â·" : "âˆ€ (n m : Nat) . Vec(n) âŠ— Vec(m) â†’ R"
          WITH "Model(Â·)(v, w) = v â‹… w"
      }
    }
  }

  PROOFS {
    THEOREM ExpressionNormalization(e : Expression(Î£))
      WHERE "âˆ€ e . âˆƒ! e' . e ~>* e' âˆ§ e' IS_NORMAL_FORM"
      
    PROOF {
      LET "e" : Expression(Î£)
      
      SHOW "âˆƒ! e' . e ~>* e' âˆ§ e' IS_NORMAL_FORM"
        BY INDUCTION ON "e":
        
        CASE Variable(x) ->  
          TAKE "e' = Variable(x)"
          TRIVIAL
          
        CASE Operation(f, args) ->
          ASSUME "âˆ€ i . args[i] ~>* vi" AND "vi IS_NORMAL_FORM"
            BY InductionHypothesis
          
          IF "f IS_REDUCIBLE"
            THEN "Operation(f, args) ~> Operation(f', args)" 
              WHERE "f ~> f'" BY ReductionRule
            THEN "Operation(f', args) ~>* e'" 
              BY ApplyInductionHypothesis
            
          ELSE "f IS_NORMAL_FORM"
            IF "âˆƒ i . args[i] IS_REDUCIBLE"
              THEN "Operation(f, args) ~> Operation(f, args[1], ..., args'[i], ..., args[m])"
                WHERE "args[i] ~> args'[i]" BY ReductionRule
              THEN "Operation(f, args[1], ..., args'[i], ..., args[m]) ~>* e'"
                BY ApplyInductionHypothesis  
              
            ELSE "âˆ€ i . args[i] IS_NORMAL_FORM"
              TAKE "e' = Operation(f, v1, ..., vm)" WHERE "args[i] ~>* vi"
              THEN "e ~>* e'" BY Reflexivity, Transitivity of "~>*" 
              SHOW "e' IS_NORMAL_FORM" BY NormalFormOfConstructors
        
      CONCLUDE "âˆƒ! e' . e ~>* e' âˆ§ e' IS_NORMAL_FORM" 
      QED  
    }

    THEOREM ModelInvariance(e e' : Expression(Î£), T : SyntacticType(n), ğ’® : Structure(n, k))
      WHERE "e : T" AND "e ~> e'" IMPLIES "DâŸ¦eâŸ§ = DâŸ¦e'âŸ§ âˆˆ Model(T, ğ’®)" 
    
    PROOF {
      LET "e e'" : Expression(Î£)  
      LET "T" : SyntacticType(n)
      LET "ğ’®" : Structure(n, k)
      
      ASSUME "e : T" AND "e ~> e'"
      SHOW "DâŸ¦eâŸ§ = DâŸ¦e'âŸ§ âˆˆ Model(T, ğ’®)"
        BY INDUCTION ON "e ~> e'":
        
        CASE "e = Operation(f, args)" AND "e' = Operation(f', args)"
          WHERE "f ~> f'" AND "âŠ¢ f : T1 â†’ ... â†’ Tm â†’ T" AND "âŠ¢ f' : T1 â†’ ... â†’ Tm â†’ T":
          
          HAVE "args[i] : Ti" AND "DâŸ¦args[i]âŸ§ âˆˆ Model(Ti, ğ’®)" BY Assumption
          THEN "DâŸ¦eâŸ§ = FâŸ¦fâŸ§(DâŸ¦args[1]âŸ§, ..., DâŸ¦args[m]âŸ§)" BY Compositionality
          AND "DâŸ¦e'âŸ§ = FâŸ¦f'âŸ§(DâŸ¦args[1]âŸ§, ..., DâŸ¦args[m]âŸ§)" BY Compositionality
          AND "FâŸ¦fâŸ§ = FâŸ¦f'âŸ§" BY SemanticInterpretationOfReduction
          
          HENCE "DâŸ¦eâŸ§ = DâŸ¦e'âŸ§" AND "DâŸ¦eâŸ§ âˆˆ Model(T, ğ’®)" BY ModelConstruction
        
        CASE "e = Operation(f, args)" AND "e' = Operation(f, args[1], ..., args'[i], ..., args[m])"  
          WHERE "args[i] ~> args'[i]":
          
          HAVE "DâŸ¦args[i]âŸ§ = DâŸ¦args'[i]âŸ§ âˆˆ Model(Ti, ğ’®)" BY InductionHypothesis
          THEN "DâŸ¦eâŸ§ = FâŸ¦fâŸ§(DâŸ¦args[1]âŸ§, ..., DâŸ¦args[i]âŸ§, ..., DâŸ¦args[m]âŸ§)" BY Compositionality  
          AND "DâŸ¦e'âŸ§ = FâŸ¦fâŸ§(DâŸ¦args[1]âŸ§, ..., DâŸ¦args'[i]âŸ§, ..., DâŸ¦args[m]âŸ§)" BY Compositionality
          
          HENCE "DâŸ¦eâŸ§ = DâŸ¦e'âŸ§" AND "DâŸ¦eâŸ§ âˆˆ Model(T, ğ’®)" BY ModelConstruction
          
      CONCLUDE "DâŸ¦eâŸ§ = DâŸ¦e'âŸ§ âˆˆ Model(T, ğ’®)"  
      QED
    }
  }
  
  EXAMPLES {
    EXAMPLE VectorCalculus {
      LET "T1" = "Vec(n)"
      LET "T2" = "Vec(n)"
      LET "T" = "R"
      
      LET "ğ’®" = "Structure(n, 2)" WITH {
        Base = EuclideanSpace(n)
        VectorBundles[1] = TangentBundle(Base)
        VectorBundles[2] = CotangentBundle(Base)
        Connections[1] = Levi-CivitaConnection(Base)
        Connections[2] = DualConnection(Connections[1])
      }
      
      FUNC Gradient(Ï† : Expression(Î£)) -> Expression(Î£) {
        RETURN "âˆ‡(Ï†)"
      }
      
      FUNC Divergence(X : Expression(Î£)) -> Expression(Î£) {  
        RETURN "âˆ‡ Â· X"
      }
      
      FUNC Laplacian(Ï† : Expression(Î£)) -> Expression(Î£) {
        RETURN "âˆ‡ Â· âˆ‡(Ï†)"  
      }
      
      LET "Ï† : T1"
      LET "X Y : T2"
      
      THEN "âŠ¢ Ï† : T1" AND "âŠ¢ X : T2" AND "âŠ¢ Y : T2" BY TypingAssumptions
      
      AND "âŠ¢ âˆ‡(Ï†) : T2" BY FunctionTyping, Typing("Vec"), Typing("âˆ‡"), TypingJudgment 
      AND "DâŸ¦âˆ‡(Ï†)âŸ§ = grad(DâŸ¦Ï†âŸ§) âˆˆ Model(T2, ğ’®)" BY ModelRealization
      
      AND "âŠ¢ âˆ‡ Â· X : T1" BY FunctionTyping, Typing("Â·"), Typing("âˆ‡"), TypingJudgment
      AND "DâŸ¦âˆ‡ Â· XâŸ§ = div(DâŸ¦XâŸ§) âˆˆ Model(T1, ğ’®)" BY ModelRealization  
      
      AND "âŠ¢ âˆ‡ Â· âˆ‡(Ï†) : T1" BY FunctionTyping, Typing("Â·"), Typing("âˆ‡"), TypingJudgment
      AND "DâŸ¦âˆ‡ Â· âˆ‡(Ï†)âŸ§ = âˆ†(DâŸ¦Ï†âŸ§) âˆˆ Model(T1, ğ’®)" BY ModelRealization
      
      FUNC DotProduct(X Y : Expression(Î£)) -> Expression(Î£) {
        RETURN "X Â· Y"  
      }
      
      THEN "âŠ¢ X Â· Y : T" BY FunctionTyping, Typing("Â·"), TypingJudgment
      AND "DâŸ¦X Â· YâŸ§ = DâŸ¦XâŸ§ â‹… DâŸ¦YâŸ§ âˆˆ Model(T, ğ’®)" BY ModelRealization
      
      FUNC Identities(Ï† : Expression(Î£), X Y : Expression(Î£)) {
        ASSERT "âˆ‡(Ï†X Â· Y) ~>* (âˆ‡(Ï†)X + Ï†âˆ‡(X)) Â· Y + Ï†(X Â· âˆ‡(Y))" BY {
          LET "LHS" = "âˆ‡(Ï†X Â· Y)"
          LET "RHS" = "(âˆ‡(Ï†)X + Ï†âˆ‡(X)) Â· Y + Ï†(X Â· âˆ‡(Y))" 
          SHOW "LHS ~>* RHS" USING ProductRule, DistributivityAxiom, AssociativityAxiom
          THEN "DâŸ¦LHSâŸ§ = DâŸ¦RHSâŸ§ âˆˆ Model(T, ğ’®)" BY ModelInvariance
        }

        ASSERT "âˆ‡ Ã— (Ï†X) ~>* âˆ‡(Ï†) Ã— X + Ï†(âˆ‡ Ã— X)" BY {  
          LET "LHS" = "âˆ‡ Ã— (Ï†X)"
          LET "RHS" = "âˆ‡(Ï†) Ã— X + Ï†(âˆ‡ Ã— X)"
          SHOW "LHS ~>* RHS" USING ProductRule, DistributivityAxiom 
          THEN "DâŸ¦LHSâŸ§ = DâŸ¦RHSâŸ§ âˆˆ Model(T2, ğ’®)" BY ModelInvariance
        }
        
        ASSERT "âˆ‡ Ã— (X Ã— Y) ~>* (âˆ‡ Â· Y)X - (âˆ‡ Â· X)Y + (Y Â· âˆ‡)X - (X Â· âˆ‡)Y" BY {
          LET "LHS" = "âˆ‡ Ã— (X Ã— Y)"  
          LET "RHS" = "(âˆ‡ Â· Y)X - (âˆ‡ Â· X)Y + (Y Â· âˆ‡)X - (X Â· âˆ‡)Y"
          SHOW "LHS ~>* RHS" USING LagrangeIdentity, DistributivityAxiom
          THEN "DâŸ¦LHSâŸ§ = DâŸ¦RHSâŸ§ âˆˆ Model(T2, ğ’®)" BY ModelInvariance  
        }
        
        ASSERT "âˆ‡ Â· (X Ã— Y) ~>* Y Â· (âˆ‡ Ã— X) - X Â· (âˆ‡ Ã— Y)" BY {
          LET "LHS" = "âˆ‡ Â· (X Ã— Y)"
          LET "RHS" = "Y Â· (âˆ‡ Ã— X) - X Â· (âˆ‡ Ã— Y)"  
          SHOW "LHS ~>* RHS" USING DotCrossProduct, DistributivityAxiom
          THEN "DâŸ¦LHSâŸ§ = DâŸ¦RHSâŸ§ âˆˆ Model(T1, ğ’®)" BY ModelInvariance
        }
      }

      COUNTEREXAMPLE NonFlatConnection {
        LET "ğ’®'" = "Structure(n, 1)" WITH {
          Base = Sphere(n)
          VectorBundles[1] = TangentBundle(Base)
          Connections[1] = Levi-CivitaConnection(Base)
        }
        
        TAKE "X Y : Expression(Î£)" WHERE "X : Vec(n)" AND "Y : Vec(n)"
        
        THEN "âŠ¢ âˆ‡ Ã— (âˆ‡ Ã— X) : Vec(n)" 
        BUT "DâŸ¦âˆ‡ Ã— (âˆ‡ Ã— X)âŸ§ â‰  0 âˆˆ Model(Vec(n), ğ’®')" WHEN "n = 3" 
          BECAUSE "Curvature(Connection[1]) â‰  0" AND "âˆ‡ Ã— (âˆ‡ Ã— X) = (âˆ‡âˆ‡ - âˆ†)X"
      }
    }
  }
}