CONCEPT MolecularAssembler {
  PARAMETERS {
    kB : ‚Ñù  -- Boltzmann constant
    h : ‚Ñù   -- Planck constant
    NA : ‚Ñù  -- Avogadro's number
    T : ‚Ñù   -- Temperature
    Œ∑ : ‚Ñù   -- Viscosity of medium
  }

  CONTEXT {
    TYPES {
      Pos := ‚Ñù¬≥
      Force := ‚Ñù¬≥
      Atom := STRUCT { Z : ‚Ñï, pos : Pos, velocity : Pos }
      Molecule := LIST(Atom)
      Bond := STRUCT { a1 : Atom, a2 : Atom, type : ENUM { Single, Double, Triple } }
      
      PotentialFunc := FUNC(Pos, Pos) -> ‚Ñù
      ReactionFunc := FUNC(Molecule, Molecule) -> (‚Ñù, ‚Ñù)  -- (ŒîG, Ea)
    }

    STRUCTURES {
      STRUCTURE AssemblerTip {
        FIELD pos : Pos
        FIELD atom : Atom
        
        FUNC Force(target : Pos) : Force := 
          -k * (pos - target) - Œ≥ * velocity
          WHERE k := SpringConstant, Œ≥ := DampingCoefficient
        
        FUNC Move(F : Force, dt : ‚Ñù) {
          velocity += F * dt / m
          pos += velocity * dt
          WHERE m := AtomicMass(atom.Z)
        }
      }
      
      STRUCTURE Workspace {
        FIELD molecules : LIST(Molecule)
        FIELD bonds : LIST(Bond)
        
        FUNC PotentialEnergy() : ‚Ñù :=
          ‚àë·µ¢‚±º V_LJ(‚Äñatoms[i].pos - atoms[j].pos‚Äñ) + 
          ‚àë·µ¶ V_bond(‚ÄñŒ≤.a1.pos - Œ≤.a2.pos‚Äñ, Œ≤.type)
          WHERE atoms := FLATTEN(molecules)
        
        FUNC Force(a : Atom) : Force :=
          -‚àá‚Çê PotentialEnergy()
        
        FUNC AddAtom(a : Atom) {
          molecules += [a]
        }
        
        FUNC RemoveAtom(a : Atom) {
          molecules = [m - {a} FOR m IN molecules]
          bonds = [b FOR b IN bonds WHERE b.a1 ‚â† a AND b.a2 ‚â† a]
        }
        
        FUNC FormBond(a1 : Atom, a2 : Atom, type : Bond.type) {
          bonds += Bond(a1, a2, type)
        }
        
        FUNC BreakBond(b : Bond) {
          bonds -= {b}
        }
      }
      
      STRUCTURE Assembler {
        FIELD tip : AssemblerTip
        FIELD workspace : Workspace
        FIELD reactions : LIST(ReactionFunc)
        
        FUNC PerformOperation(op : AssemblerOperation) {
          CASE AddAtom(a) => workspace.AddAtom(a)
          CASE RemoveAtom(a) => workspace.RemoveAtom(a)
          CASE FormBond(a1, a2, type) => workspace.FormBond(a1, a2, type)
          CASE BreakBond(b) => workspace.BreakBond(b)
          CASE MoveTip(target) => 
            WHILE ‚Äñtip.pos - target‚Äñ > Œµ DO
              LET F = tip.Force(target)
              tip.Move(F, dt)
        }
        
        FUNC AttemptReaction(r : ReactionFunc, reactants : LIST(Molecule)) : ùîπ {
          LET (ŒîG, Ea) = r(reactants)
          LET k_f = (kB * T / h) * exp(-Ea / (kB * T))
          LET K_eq = exp(-ŒîG / (kB * T))
          
          IF RandUniform() < k_f * dt THEN
            IF ŒîG < 0 OR RandUniform() < K_eq THEN
              ApplyReaction(r, reactants)
              RETURN True
          
          RETURN False
        }
        
        FUNC Simulate(steps : ‚Ñï) {
          FOR _ IN 1..steps DO
            FOR a IN FLATTEN(workspace.molecules) DO
              LET F = workspace.Force(a)
              a.velocity += F * dt / AtomicMass(a.Z)
              a.pos += a.velocity * dt
            
            FOR r IN reactions DO
              LET reactants = FindReactants(r, workspace.molecules)
              IF reactants ‚â† ‚àÖ THEN
                AttemptReaction(r, reactants)
        }
      }
    }

    NOTATION {
      ‚Äñx‚Äñ := EuclideanNorm(x)
      x ¬∑ y := DotProduct(x, y)
      ‚àá‚Çê := GradientWrtAtom(a)
      ‚àë·µ¢‚±º := Sum(i < j)
      ‚àë·µ¶ := Sum(Œ≤ IN bonds)
    }
    
    ASSERTIONS {
      AXIOM ConservationOfEnergy {
        |Assembler.PotentialEnergy() + KineticEnergy(FLATTEN(workspace.molecules)) - E_initial| < Œµ
      }
      
      AXIOM DetailedBalance {
        ‚àÄ r : ReactionFunc, reactants : LIST(Molecule) .
          P(r, reactants ‚Üí products) / P(r‚Åª¬π, products ‚Üí reactants) = exp(-ŒîG / (kB * T))
      }
    }
  }

  TRANSFORMERS {
    SIMPLIFY LennardJonesPotential(r) {
      V_LJ(r) := 4Œµ((œÉ/r)¬π¬≤ - (œÉ/r)‚Å∂)
        WHERE Œµ := WellDepth, œÉ := EquilibriumDistance
    }
    
    REWRITE BondPotential(r, type) {
      V_bond(r, type) := 0.5 * k_type * (r - r_eq_type)¬≤
        WHERE k_type, r_eq_type := BondParameters(type)
    }
    
    SIMPLIFY LowTemperatureApprox(T ‚Üí 0) {
      AttemptReaction(r, reactants) ‚âà (ŒîG < 0)
    }
  }

  PROOFS {
    THEOREM Ergodicity {
      ‚àÄ c1 c2 : Configuration . ‚àÉ n : ‚Ñï .
        P(config(t+n*dt) = c2 | config(t) = c1) > 0
    }
    PROOF {
      -- Show that any configuration can be reached through a series of
      -- elementary operations and reactions with non-zero probability
      ...
    }

    THEOREM ReactionRateLimits {
      lim(T‚Üí‚àû) k_f = kB * T / h
      lim(T‚Üí0) k_f = 0
    }
    PROOF {
      k_f = (kB * T / h) * exp(-Ea / (kB * T))
      lim(T‚Üí‚àû) k_f = lim(T‚Üí‚àû) (kB * T / h) * 1 = ‚àû
      lim(T‚Üí0) k_f = lim(T‚Üí0) (kB * T / h) * 0 = 0
      QED
    }
  }

  EXAMPLES {
    EXAMPLE SimpleHydrogenMolecule {
      DEFINE assembler = Assembler(
        tip: AssemblerTip(pos: (0,0,0), atom: Atom(Z: 1, pos: (0,0,0), velocity: (0,0,0))),
        workspace: Workspace(molecules: [], bonds: []),
        reactions: [
          (reactants) => 
            IF |reactants| = 2 AND ALL(a.Z = 1 FOR a IN FLATTEN(reactants)) THEN
              RETURN (-436 kJ/mol, 51 kJ/mol)  -- ŒîG and Ea for H-H bond formation
            ELSE
              RETURN (0, ‚àû)
        ]
      )
      
      assembler.PerformOperation(AddAtom(Atom(Z: 1, pos: (0,0,0), velocity: (0,0,0))))
      assembler.PerformOperation(AddAtom(Atom(Z: 1, pos: (0,0,1), velocity: (0,0,0))))
      assembler.Simulate(1000000)
      
      THEN
        |assembler.workspace.bonds| = 1 AND
        ALL(m.Z = 1 FOR m IN FLATTEN(assembler.workspace.molecules)) AND
        ‚Äñassembler.workspace.molecules[0][0].pos - assembler.workspace.molecules[0][1].pos‚Äñ ‚âà 74 pm
    }
  }
}