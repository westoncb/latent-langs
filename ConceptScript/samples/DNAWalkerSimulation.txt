CONCEPT DNAWalkerSimulation {
  PARAMETERS {
    kB : â„  -- Boltzmann constant
    NA : â„  -- Avogadro's number
    T : â„  -- Temperature
    Î· : â„  -- Viscosity
    lp : â„  -- Persistence length
    a : â„  -- Base pair length
    C_salt : â„  -- Salt concentration
  }

  CONTEXT {
    TYPES {
      Nuc := ENUM { A, T, C, G }
      Pos := â„Â³
      Seq := LIST(Nuc)
      â„• := NaturalNumbers
      ð”¹ := Booleans
      
      NNParams := MAP((Nuc, Nuc), (â„, â„))  -- (Î”H, Î”S) for each pair
    }

    STRUCTURES {
      STRUCTURE Domain {
        FIELD seq : Seq
        FIELD type : ENUM { Toehold, Branch, Spacer }
        
        FUNC Î”G(T : â„, nn : NNParams) : â„ :=
          âˆ‘áµ¢â¿â»Â¹ nn(seq[i], seq[i+1]).1 - T * (âˆ‘áµ¢â¿â»Â¹ nn(seq[i], seq[i+1]).2 + 
          0.368n ln(C_salt/1000)) + InitÎ”G(seq[0], seq[-1], T)
        
        FUNC k_on(C : â„) : â„ := IF type = Toehold THEN 3.5e5 * C^0.9 ELSE 0
        
        FUNC k_off(T : â„, nn : NNParams) : â„ := k_on(1) * exp(Î”G(T, nn) / (kB * T))
        
        FUNC BranchRate() : â„ := IF type = Branch THEN 1200 * exp(-1.5|seq|) ELSE 0
        
        FUNC Flex() : â„ := IF type = Spacer THEN 0.6lp ELSE lp
      }
      
      STRUCTURE WalkerLeg {
        FIELD domains : LIST(Domain)
        FIELD pos : Pos
        FIELD s : â„
        
        FUNC L() : â„ := âˆ‘â‚– |dâ‚–.seq| * a * (1 + 0.6Î´(dâ‚–.type, Spacer))
        
        FUNC F(track : Track) : Pos := 
          WLC(â€–pos - track(s)â€– / L(), HMean([d.Flex() FOR d IN domains])) * 
          (pos - track(s)) / â€–pos - track(s)â€–
        
        FUNC Î”G(s' : â„, track : Track, nn : NNParams) : â„ := 
          âˆ‘â‚– dâ‚–.Î”G(T, nn) + 0.5Îº(L()â»Â¹ + Lp_eff()â»Â¹)(â€–pos - track(s)â€–Â² - â€–pos - track(s')â€–Â²)
        
        FUNC P(s' : â„, track : Track, nn : NNParams) : â„ := 
          exp(-Î”G(s', track, nn) / (kB * T))
        
        FUNC D() : â„ := kB * T / (6Ï€Î·âˆš(L() * HMean([d.Flex() FOR d IN domains])))
        
        FUNC k(s' : â„, track : Track, nn : NNParams) : â„ := 
          ToeholdDomain(domains).k_on(1) * 
          exp(-BranchDomain(domains).BranchRate() * |BranchDomain(domains).seq|) *
          P(s', track, nn)
      }
      
      STRUCTURE Track {
        FIELD f : FUNC(â„, Pos)
        FIELD bindingSites : LIST(â„)
        
        FUNC NearestSite(s : â„) : â„ := argmináµ¢ |s - bindingSites[i]|
      }
      
      STRUCTURE Simulator {
        FIELD dt : â„
        FIELD leg : WalkerLeg
        FIELD track : Track
        FIELD nn : NNParams
        
        FUNC Step() : (Pos, â„, ð”¹) {
          LET force = leg.F(track)
          LET drift = force * dt / (6Ï€Î· * leg.L())
          LET diff = âˆš(2 * leg.D() * dt) * RandNormalÂ³()
          
          leg.pos += drift + diff
          
          IF â€–leg.pos - track(leg.s)â€– > THRESHOLD THEN
            LET p_unbind = leg.domains[0].k_off(T, nn) * dt
            IF RandUniform() < p_unbind THEN
              RETURN (leg.pos, leg.s, False)
          ELSE
            LET s_near = track.NearestSite(leg.s)
            LET p_bind = leg.k(s_near, track, nn) * dt
            IF RandUniform() < p_bind THEN
              leg.s = s_near
              RETURN (leg.pos, leg.s, True)
          
          RETURN (leg.pos, leg.s, leg.s â‰  -1)
        }
        
        FUNC Simulate(steps : â„•) : LIST((Pos, â„, ð”¹)) {
          RETURN [Step() FOR _ IN 1..steps]
        }
      }
    }

    NOTATION {
      |x| := Length(x)
      â€–xâ€– := EuclideanNorm(x)
      x Â· y := DotProduct(x, y)
      âˆ‘áµ¢â¿ := Sum(i=1 TO n)
      âˆáµ¢â¿ := Product(i=1 TO n)
      Î´(x, y) := KroneckerDelta(x, y)
      HMean := HarmonicMean
    }
    
    ASSERTIONS {
      AXIOM DetailedBalance { 
        âˆ€ sâ‚ sâ‚‚ . leg.k(sâ‚, track, nn) * leg.P(sâ‚, track, nn) = 
                  leg.k(sâ‚‚, track, nn) * leg.P(sâ‚‚, track, nn) 
      }
      AXIOM WLCLimit { lim(xâ†’1) WLC(x, lp) = âˆž }
    }
  }

  TRANSFORMERS {
    SIMPLIFY WLCApprox(x) {
      WLC(x, lp) â‰ˆ 3kBT/(2lp) * (x + x/(1-x)Â²)  FOR 0 < x < 0.9
    }
    
    REWRITE SaltEffect(C_salt) {
      Domain.Î”G(T, nn) â†’ Domain.Î”G(T, nn) - 0.114 * |seq| * ln(C_salt)  FOR C_salt > 0.05
    }
  }

  PROOFS {
    THEOREM Ergodicity {
      âˆ€ sâ‚ sâ‚‚ âˆˆ track.bindingSites . âˆƒ n âˆˆ â„• . 
        â„™(leg.s(t+n*dt) = sâ‚‚ | leg.s(t) = sâ‚) > 0
    }
    PROOF {
      LET p_min = min(leg.k(s, track, nn) * dt FOR s IN track.bindingSites)
      HAVE p_min > 0 BY Domain.k_on > 0, exp(-x) > 0
      HENCE âˆ€ sâ‚ sâ‚‚ . â„™(leg.s(t+dt) = sâ‚‚ | leg.s(t) = sâ‚) â‰¥ p_min > 0
      THUS â„™(leg.s(t+n*dt) = sâ‚‚ | leg.s(t) = sâ‚) â‰¥ p_min^n > 0 âˆ€ n
      QED
    }

    THEOREM MeanFirstPassageTime(sâ‚, sâ‚‚) {
      ð”¼[Ï„(sâ‚ â†’ sâ‚‚)] = âˆ«â‚›â‚Ë¢Â² dx / (D * P(x))
        WHERE Ï„(sâ‚ â†’ sâ‚‚) := inf{t > 0 : s(t) = sâ‚‚ | s(0) = sâ‚}
              P(x) := exp(-U(x) / (kB * T))
              U(x) := leg.Î”G(x, track, nn)
    }
    PROOF {
      -- Derive from Fokker-Planck equation for 1D diffusion in potential U(x)
      ...
    }
  }

  EXAMPLES {
    EXAMPLE BasicSimulation {
      DEFINE nn = LoadNearestNeighborParams()  -- Load from empirical data
      
      DEFINE leg = WalkerLeg(
        domains: [
          Domain(seq: [A,T,C,G,A,T], type: Toehold),
          Domain(seq: [G,C,A,T,G,C,A,T,G,C], type: Branch),
          Domain(seq: [T,T,T,T], type: Spacer)
        ],
        pos: (0, 0, 5),
        s: 0
      )
      
      DEFINE track = Track(
        f: (s) => (10s, 0, 0),
        bindingSites: [0, 1, 2, 3, 4]
      )
      
      DEFINE sim = Simulator(dt: 1e-9, leg: leg, track: track, nn: nn)
      
      LET trajectory = sim.Simulate(1000000)
      
      THEN 
        MEAN([p.2 FOR p IN trajectory]) > 0 AND  -- Net forward movement
        COUNT([p FOR p IN trajectory WHERE p.3]) / |trajectory| > 0.9  -- High processivity
    }
  }
}