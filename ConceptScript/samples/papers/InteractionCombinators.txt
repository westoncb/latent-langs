CONCEPT InteractionCombinators {
  CONTEXT {
    TYPES {
      Symbol := String
      Cell := (Symbol, List(Port))
      Port := (Cell, Nat)
      Net := (Set(Cell), Set(Port), Set((Port, Port)))
    }

    NOTATION {
      INFIX "â†’[_]" := Reduces
      INFIX "â†’*[_]" := ReducesInMany
      INFIX "â†’á´µá¶œ" := Reduces(?, InteractionCombinatorsSystem, ?)
      INFIX "â†’*á´µá¶œ" := ReducesInMany(?, InteractionCombinatorsSystem, ?)
      ğ’¯(_, _) := TranslationMap
      MIXFIX "âŸ¨_ â†¦ _âŸ©_" := Substitution
    }
    
    STRUCTURES {
      STRUCTURE InteractionSystem {
        FIELD alphabet : Set(Symbol)
        FIELD rules : MAP((Symbol, Symbol), Net)
        
        AXIOM WellFormedRules(a b : Symbol)(Î± : Net) : 
          rules(a, b) = Î± IMPLIES (a âˆˆ alphabet âˆ§ b âˆˆ alphabet âˆ§ Reduced(Î±))
  
        AXIOM Totality(a b : Symbol) :
          a âˆˆ alphabet âˆ§ b âˆˆ alphabet IMPLIES ((a, b) âˆˆ rules.Keys âˆ¨ (b, a) âˆˆ rules.Keys)
      }
    }
  
    DEFINITIONS {
      Arity(s : Symbol) -> Nat
      Interaction(a b : Symbol) -> Net?
      Reduced(net : Net) -> Bool
  
      Reduces(net net' : Net, S : InteractionSystem) -> Bool
      ReducesInMany(net net' : Net, S : InteractionSystem) -> Bool
  
      TranslationMap(S T : InteractionSystem) -> Set(FUNC(Net) -> Net) = 
        {t : Net -> Net | Equivariant(t, S, T) âˆ§ âˆ€ net . Reduced(t(net), T) âŸº Reduced(net, S)}

      Symmetry := âˆ€ (a b : Symbol) (Î± Î² : Net) .
        Interaction(a, b) = Î± âˆ§ Interaction(b, a) = Î² IMPLIES Î± = Flip(Î²)
  
      Determinism := âˆ€ (a b : Symbol)(Î± Î² : Net) .
        Interaction(a, b) = Î± âˆ§ Interaction(a, b) = Î² IMPLIES Î± = Î²
    }

    AXIOMS {
      PortCount(s : Symbol)(c : Cell)(ps : List(Port)) : 
        c.1 = s âˆ§ c.2 = ps IMPLIES Length(ps) = Arity(s) + 1
  
      PortDistinct(c : Cell)(ps : List(Port))(i j : Nat) :
        c âˆˆ net.1 âˆ§ (c, i) âˆˆ ps âˆ§ (c, j) âˆˆ ps âˆ§ i â‰  j IMPLIES (c, i) â‰  (c, j)
    }
  }

  TRANSFORMERS {
    REWRITE Substitution(net : Net, c : Cell, sub : Net) : Net
      LET (cs, ps, ws) = net
      IN (cs âˆª sub.1, âŸ¨c â†¦ sub.2âŸ©ps, âŸ¨c â†¦ sub.3âŸ©ws)
  }

  PROOFS {    
    THEOREM ChurchRosser(S : InteractionSystem) {
      âˆ€ net netâ‚ netâ‚‚ . (net â†’*[S] netâ‚ âˆ§ net â†’*[S] netâ‚‚) â‡’ 
        (âˆƒ result . netâ‚ â†’*[S] result âˆ§ netâ‚‚ â†’*[S] result)
    }
    PROOF {
      ASSUME net : Net, netâ‚ netâ‚‚ : Net, 
             net â†’*[S] netâ‚, net â†’*[S] netâ‚‚
      
      DEFINE LocalConfluence := âˆ€ net' netâ‚' netâ‚‚' .
        (net' â†’[S] netâ‚' âˆ§ net' â†’[S] netâ‚‚') â‡’ 
          (âˆƒ result . netâ‚' â†’[S] result âˆ§ netâ‚‚' â†’[S] result)
      
      SHOW âˆƒ result . netâ‚ â†’*[S] result âˆ§ netâ‚‚ â†’*[S] result
      PROOF {
        netâ‚ â†’*[S] resultâ‚ BY Assumption
        netâ‚‚ = net â†’[S] ... â†’[S] net_k â†’[S] ... â†’[S] resultâ‚‚
        
        resultâ‚ = resultâ‚‚ 
          BY Induction, LocalConfluence
        
        TAKE result = resultâ‚
      }
      
      SHOW âˆ€ resultâ‚ resultâ‚‚ . 
        (netâ‚ â†’*[S] resultâ‚ âˆ§ netâ‚‚ â†’*[S] resultâ‚‚) â‡’ resultâ‚ = resultâ‚‚  
      PROOF {
        ASSUME netâ‚ â†’*[S] resultâ‚, netâ‚‚ â†’*[S] resultâ‚‚
        
        netâ‚ â†’*[S] resultâ‚ = net â†’[S] ... â†’[S] resultâ‚  
        netâ‚‚ â†’*[S] resultâ‚‚ = net â†’[S] ... â†’[S] net_k â†’[S] ... â†’[S] resultâ‚‚
        
        resultâ‚ â†’[S] ... â†’[S] râ‚  
        resultâ‚‚ â†’[S] ... â†’[S] râ‚‚
        
        râ‚ = râ‚‚ BY Induction, Determinism
        
        HENCE resultâ‚ = resultâ‚‚
      }
    }
    
    THEOREM TranslationTheorem(S : InteractionSystem) {
      âˆƒ (T : ğ’¯(S, InteractionCombinatorsSystem)) . FaithfullyRepresents(T)  
    }
    PROOF {
      LET C D E #p #q $p $q = InteractionCombinatorsSystem.alphabet
      
      DEFINE ğ’¯ : ğ’¯(S, InteractionCombinatorsSystem) {
        âˆ€ a : S.alphabet . ğ’¯(a) = TreeOf(CodesOf({Î± | (a, b) â†¦ Î± âˆˆ S.rules}))
        âˆ€ net : Net . ğ’¯(net) = âŸ¨a â†¦ ğ’¯(a)âŸ©net
      }
      
      SHOW Equivariant(ğ’¯)  
      PROOF {
        ASSUME net result : Net, net â†’[S] result
        SHOW ğ’¯(net) â†’*á´µá¶œ ğ’¯(result)
          BY DecodingSimulation
      }
      
      SHOW âˆ€ net . Reduced(ğ’¯(net), InteractionCombinatorsSystem) âŸº Reduced(net, S)
        BY DecodingSimulation, Definitions
      
      HENCE FaithfullyRepresents(ğ’¯)
    }
  }
}