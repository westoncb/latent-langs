CONCEPT QuantumComputing {
  LANGUAGE {
    TYPE Ket = Vector[Complex]
    TYPE Bra = DualVector[Complex]
    TYPE Operator = Matrix[Complex]
    
    NOTATION "|" "âŸ©" = Ket
    NOTATION "âŸ¨" "|" = Bra
    NOTATION "âŸ¨" x "|" y "âŸ©" = InnerProduct(Bra(x), Ket(y))
    NOTATION "|" x "âŸ©âŸ¨" y "|" = OuterProduct(Ket(x), Bra(y))
    
    NOTATION "ğŸ™" = IdentityOperator
    NOTATION "H" = HadamardOperator
    NOTATION "X" = PauliXOperator
    NOTATION "Y" = PauliYOperator
    NOTATION "Z" = PauliZOperator
    NOTATION "CNOT" = ControlledNotOperator
    
    NOTATION x "âŠ—" y = TensorProduct(x, y)
    
    FUNC TensorProduct(x : Ket, y : Ket) -> Ket
    FUNC TensorProduct(x : Operator, y : Operator) -> Operator
    
    PRED Entangled(Ïˆ : Ket) = 
      Â¬(âˆƒ (a : Ket) (b : Ket). Ïˆ = a âŠ— b)
      
    FUNC Measure(Ïˆ : Ket, P : Operator) -> (p : Real, Ïˆ' : Ket)
      WHERE P * P = P, P = P^â€ 
      
    REWRITE âŸ¨Ï†| * (|Ïˆâ‚âŸ© + |Ïˆâ‚‚âŸ©) = âŸ¨Ï†|Ïˆâ‚âŸ© + âŸ¨Ï†|Ïˆâ‚‚âŸ©
    REWRITE (âŸ¨Ï†â‚| + âŸ¨Ï†â‚‚|) * |ÏˆâŸ© = âŸ¨Ï†â‚|ÏˆâŸ© + âŸ¨Ï†â‚‚|ÏˆâŸ©
    REWRITE (c * |ÏˆâŸ©)^â€  = c^* * âŸ¨Ïˆ|
    REWRITE (|ÏˆâŸ© âŠ— |Ï†âŸ©)^â€  = âŸ¨Ïˆ| âŠ— âŸ¨Ï†|
    
    AXIOM TensorProductAssociativity {
      FORALL (x y z : Ket). (x âŠ— y) âŠ— z = x âŠ— (y âŠ— z)
    }
    
    AXIOM TensorProductDistributivity {
      FORALL (x y z : Ket). 
        x âŠ— (y + z) = (x âŠ— y) + (x âŠ— z)
        (x + y) âŠ— z = (x âŠ— z) + (y âŠ— z)
    }
  }
  
  STRUCTURE {
    DEF Bell00 = (|00âŸ© + |11âŸ©) / âˆš2
    DEF Bell01 = (|01âŸ© + |10âŸ©) / âˆš2
    DEF Bell10 = (|00âŸ© - |11âŸ©) / âˆš2
    DEF Bell11 = (|01âŸ© - |10âŸ©) / âˆš2
    
    DEF Teleportation(|ÏˆâŸ© : Ket, |Î²00âŸ© : Ket) {
      LET |ÏˆâŸ© âŠ— |Î²00âŸ© = |ÏˆâŸ© âŠ— ((|00âŸ© + |11âŸ©) / âˆš2)
      LET (_, |Ïˆ'âŸ© âŠ— |Î²'âŸ©) = Measure(|ÏˆâŸ© âŠ— |Î²00âŸ©, ğŸ™ âŠ— (|00âŸ©âŸ¨00| + |01âŸ©âŸ¨01|))
      LET |Ïˆ''âŸ© = MATCH |Î²'âŸ© WITH
        | |00âŸ© => ğŸ™ * |Ïˆ'âŸ©
        | |01âŸ© => X * |Ïˆ'âŸ©
        | |10âŸ© => Z * |Ïˆ'âŸ©
        | |11âŸ© => Y * |Ïˆ'âŸ©
      |Ïˆ''âŸ©  
    }
  }
  
  PROOFS {
    TACTIC ExpandKet(x) = MATCH x WITH
      | a |0âŸ© + b |1âŸ© => REWRITE x = Matrix[[a], [b]]
      | a |00âŸ© + b |01âŸ© + c |10âŸ© + d |11âŸ© => REWRITE x = Matrix[[a], [b], [c], [d]]
      
    TACTIC ExpandBra(x) = MATCH x WITH
      | a âŸ¨0| + b âŸ¨1| => REWRITE x = Matrix[[a, b]]
      | a âŸ¨00| + b âŸ¨01| + c âŸ¨10| + d âŸ¨11| => REWRITE x = Matrix[[a, b, c, d]]
      
    TACTIC ExpandOperator(P) = MATCH P WITH
      | |xâŸ©âŸ¨y| => REWRITE P = OuterProduct(|xâŸ©, âŸ¨y|)
      | P1 + P2 => REWRITE P = P1 + P2
      | P1 * P2 => REWRITE P = P1 * P2
      
    THEOREM TeleportationCorrectness {
      STATEMENT:
        FORALL (|ÏˆâŸ© : Ket). 
          Teleportation(|ÏˆâŸ©, Bell00) = |ÏˆâŸ©
          
      PROOF:
        LET |ÏˆâŸ© : Ket
        REWRITE |ÏˆâŸ© = a |0âŸ© + b |1âŸ© BY ExpandKet(|ÏˆâŸ©)
        
        HAVE Teleportation(|ÏˆâŸ©, Bell00)
          = Teleportation(a |0âŸ© + b |1âŸ©, (|00âŸ© + |11âŸ©) / âˆš2) BY DEFINITION
          
          = LET |ÏˆâŸ© âŠ— |Î²00âŸ© = (a |0âŸ© + b |1âŸ©) âŠ— ((|00âŸ© + |11âŸ©) / âˆš2)
            LET (_, |Ïˆ'âŸ© âŠ— |Î²'âŸ©) = Measure(|ÏˆâŸ© âŠ— |Î²00âŸ©, ğŸ™ âŠ— (|00âŸ©âŸ¨00| + |01âŸ©âŸ¨01|))
            LET |Ïˆ''âŸ© = MATCH |Î²'âŸ© WITH
              | |00âŸ© => ğŸ™ * |Ïˆ'âŸ©
              | |01âŸ© => X * |Ïˆ'âŸ© 
              | |10âŸ© => Z * |Ïˆ'âŸ©
              | |11âŸ© => Y * |Ïˆ'âŸ©
            |Ïˆ''âŸ© BY DEFINITION
            
          = LET |ÏˆâŸ© âŠ— |Î²00âŸ© = (a |000âŸ© + a |011âŸ© + b |100âŸ© + b |111âŸ©) / âˆš2 BY {
              (a |0âŸ© + b |1âŸ©) âŠ— ((|00âŸ© + |11âŸ©) / âˆš2)
                = ((a |0âŸ© + b |1âŸ©) âŠ— |00âŸ© + (a |0âŸ© + b |1âŸ©) âŠ— |11âŸ©) / âˆš2 BY TensorProductDistributivity {
                  (a |0âŸ© + b |1âŸ©) âŠ— |00âŸ© 
                    = a |0âŸ© âŠ— |00âŸ© + b |1âŸ© âŠ— |00âŸ© BY TensorProductDistributivity
                    = a |000âŸ© + b |100âŸ©
                  (a |0âŸ© + b |1âŸ©) âŠ— |11âŸ©
                    = a |0âŸ© âŠ— |11âŸ© + b |1âŸ© âŠ— |11âŸ© BY TensorProductDistributivity  
                    = a |011âŸ© + b |111âŸ©
                }
            }
            LET (_, |Ïˆ'âŸ© âŠ— |Î²'âŸ©) = Measure(|ÏˆâŸ© âŠ— |Î²00âŸ©, ğŸ™ âŠ— (|00âŸ©âŸ¨00| + |01âŸ©âŸ¨01|))
            LET |Ïˆ''âŸ© = MATCH |Î²'âŸ© WITH
              | |00âŸ© => ğŸ™ * |Ïˆ'âŸ© = a |0âŸ© + b |1âŸ©
              | |01âŸ© => X * |Ïˆ'âŸ© = a |1âŸ© + b |0âŸ© = b |0âŸ© + a |1âŸ©  
              | |10âŸ© => Z * |Ïˆ'âŸ© = a |0âŸ© - b |1âŸ© = a |0âŸ© + (-b) |1âŸ©
              | |11âŸ© => Y * |Ïˆ'âŸ© = i * (a |1âŸ© - b |0âŸ©) = (-b) |0âŸ© + a |1âŸ©
            |Ïˆ''âŸ© BY {
              Measure((a |000âŸ© + a |011âŸ© + b |100âŸ© + b |111âŸ©) / âˆš2, ğŸ™ âŠ— (|00âŸ©âŸ¨00| + |01âŸ©âŸ¨01|))
                = (1/2, (a |00âŸ© + b |11âŸ©) âŠ— |00âŸ©) OR
                  (1/2, (a |00âŸ© - b |11âŸ©) âŠ— |01âŸ©) OR  
                  (1/2, (a |01âŸ© + b |10âŸ©) âŠ— |10âŸ©) OR
                  (1/2, (a |01âŸ© - b |10âŸ©) âŠ— |11âŸ©) BY ExpandOperator, ExpandKet
            }
            
          = a |0âŸ© + b |1âŸ© OR 
            b |0âŸ© + a |1âŸ© OR
            a |0âŸ© + (-b) |1âŸ© OR
            (-b) |0âŸ© + a |1âŸ©
            
          = |ÏˆâŸ© BY ExpandKet(|ÏˆâŸ©) 
    }
  }
}





CONCEPT QuantumComputing {
  LANGUAGE {
    TYPE Qubit = (Î± : Complex, Î² : Complex) | Î±^2 + Î²^2 = 1
    TYPE Bra = Qubit
    TYPE Ket = Qubit
    
    NOTATION "|" "âŸ©" = Ket
    NOTATION "âŸ¨" "|" = Bra
    NOTATION "âŸ¨" q "|" q' "âŸ©" = InnerProduct(q, q')

    NOTATION "/" q1 "\\" "| x |" "/" q2 "\\" = TensorProduct(q1, x, q2)

    FUNC InnerProduct(âŸ¨a| : Bra, |bâŸ© : Ket) : Complex
    FUNC TensorProduct(|aâŸ© : Ket, |bâŸ© : Ket) : Ket
    FUNC TensorProduct(âŸ¨a| : Bra, âŸ¨b| : Bra) : Bra
    FUNC TensorProduct(|aâŸ© : Ket, A : Matrix, |bâŸ© : Ket) : Matrix
    FUNC TensorProduct(âŸ¨a| : Bra, A : Matrix, âŸ¨b| : Bra) : Matrix
    
    FUNC Hadamard : Matrix
    FUNC CNOT : Matrix
    
    AXIOM InnerProductConjugateSymmetry: âˆ€ (|aâŸ© : Ket) (|bâŸ© : Ket). âŸ¨a|bâŸ© = Conjugate(âŸ¨b|aâŸ©)
    AXIOM TensorInnerProduct: âˆ€ (|aâŸ© |a'âŸ© : Ket) (|bâŸ© |b'âŸ© : Ket). âŸ¨a|a'âŸ© * âŸ¨b|b'âŸ© = /âŸ¨a| âŸ¨b|\|InnerProduct|/|a'âŸ© |b'âŸ©\
  }
  
  STRUCTURE {
    DEF |0âŸ© = |1, 0âŸ©
    DEF |1âŸ© = |0, 1âŸ©
    DEF |+âŸ© = |1/âˆš2, 1/âˆš2âŸ©
    DEF |-âŸ© = |1/âˆš2, -1/âˆš2âŸ©
    
    DEF Bell00 = /|0âŸ© |0âŸ©\
    DEF Bell01 = /|0âŸ© |1âŸ©\
    DEF Bell10 = /|1âŸ© |0âŸ©\
    DEF Bell11 = /|1âŸ© |1âŸ©\
    
    DEF BellBasis = [Bell00, Bell01, Bell10, Bell11]
    
    DEF Entangled(|ÏˆâŸ© : Ket) = 
      Â¬âˆƒ (|aâŸ© |bâŸ© : Ket). |ÏˆâŸ© = /|aâŸ© |bâŸ©\
  }
  
  PROOFS {
    THEOREM BellStateEntanglement {
      STATEMENT: âˆ€ (|ÏˆâŸ© : BellBasis). Entangled(|ÏˆâŸ©)
      
      PROOF:
        LET |ÏˆâŸ© : BellBasis
        CASE |ÏˆâŸ© OF 
          Bell00 -> {
            ASSUME âˆƒ (|aâŸ© |bâŸ© : Ket). Bell00 = /|aâŸ© |bâŸ©\
            LET |aâŸ© |bâŸ© : Ket 
            ASSUME Bell00 = /|aâŸ© |bâŸ©\
            
            âŸ¨0|0âŸ© = /âŸ¨0| âŸ¨0|\|InnerProduct|/|aâŸ© |bâŸ©\ BY ASSUMPTION
                  = âŸ¨0|aâŸ© * âŸ¨0|bâŸ© BY TensorInnerProduct
            âŸ¨0|1âŸ© = /âŸ¨0| âŸ¨1|\|InnerProduct|/|aâŸ© |bâŸ©\ BY ASSUMPTION
                  = âŸ¨0|aâŸ© * âŸ¨1|bâŸ© BY TensorInnerProduct

            âŸ¨0|aâŸ© â‰  0 BY {
              âŸ¨0|aâŸ© = 0 -> âŸ¨0|0âŸ© = âŸ¨0|aâŸ© * âŸ¨0|bâŸ© = 0
              BUT âŸ¨0|0âŸ© = 1
            }
            âŸ¨1|bâŸ© = 0 BY {
              âŸ¨1|bâŸ© â‰  0 -> âŸ¨0|1âŸ© = âŸ¨0|aâŸ© * âŸ¨1|bâŸ© â‰  0 
              BUT âŸ¨0|1âŸ© = 0
            }

            |bâŸ© = |0âŸ© BY {
              |bâŸ© = Î²_0|0âŸ© + Î²_1|1âŸ©
              âŸ¨1|bâŸ© = 0 -> Î²_1 = 0
              |bâŸ© = Î²_0|0âŸ©
              âŸ¨b|bâŸ© = 1 -> Î²_0 = 1
            }

            Bell00 = /|0âŸ© |0âŸ©\
            CONTRADICTION
          }
          Bell01 -> {
            (* Similar to Bell00 case *)
          }  
          Bell10 -> {
            (* Similar to Bell00 case *)
          }
          Bell11 -> {
            (* Similar to Bell00 case *)
          }
    }
    
    THEOREM BellStateOrthonormality {
      STATEMENT: âˆ€ (|ÏˆâŸ© |Ï†âŸ© : BellBasis).
        âŸ¨Ïˆ|Ï†âŸ© = IF |ÏˆâŸ© = |Ï†âŸ© THEN 1 ELSE 0
      
      PROOF:
        LET |ÏˆâŸ© |Ï†âŸ© : BellBasis
        CASE (|ÏˆâŸ©, |Ï†âŸ©) OF
          (Bell00, Bell00) -> {
            âŸ¨Ïˆ|Ï†âŸ© = /âŸ¨0| âŸ¨0|\|InnerProduct|/|0âŸ© |0âŸ©\
                  = âŸ¨0|0âŸ© * âŸ¨0|0âŸ© BY TensorInnerProduct
                  = 1 * 1 
                  = 1
          }
          (Bell00, Bell01) -> {
            âŸ¨Ïˆ|Ï†âŸ© = /âŸ¨0| âŸ¨0|\|InnerProduct|/|0âŸ© |1âŸ©\
                  = âŸ¨0|0âŸ© * âŸ¨0|1âŸ© BY TensorInnerProduct  
                  = 1 * 0
                  = 0
          }
          (* Other cases... *)
    }
    
    THEOREM TeleportationProtocol {
      STATEMENT:
        LET |ÏˆâŸ© : Ket, 
            |Î²00âŸ© = /|0âŸ© |0âŸ©\,
            |Î²01âŸ© = /|0âŸ© |1âŸ©\, 
            |Î²10âŸ© = /|1âŸ© |0âŸ©\,
            |Î²11âŸ© = /|1âŸ© |1âŸ©\
        IN
        FORALL (a b : Bit).
          MAP(SWITCH a, b
              CASE 0, 0 => I
              CASE 0, 1 => X
              CASE 1, 0 => Z
              CASE 1, 1 => ZX
          , 
          /I âŸ¨Î²ab|\(/Hadamard |aâŸ©\ âŠ— |ÏˆâŸ©))
          = |ÏˆâŸ©
          
      PROOF:
        (* Omitted for brevity *)
    }
  }
}