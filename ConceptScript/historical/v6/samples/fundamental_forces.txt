FundamentalForces := (InformationalForce, StructuralForce) {🌌🔬} :: {
  InformationalForce := (Entropy, Negentropy) {💥🔄} :: {
    [∀s ∈ System: Entropy(s) = - ∑ p(s) log(p(s))] // Entropy is the expected surprisal {🎲}
    [∀s ∈ System: Negentropy(s) = Entropy(s_max) - Entropy(s)] // Negentropy is the entropy deficit {💎}
    [∀s ∈ System: InformationContent(s) ⟺ (Entropy(s), Negentropy(s))] // Information content is characterized by entropy and negentropy {ℹ️}
  }

  StructuralForce := (Complexity, Synergy, Efficiency) {🏗️} :: {
    [∀s ∈ System: Complexity(s) ⟺ (Entropy(s) × Negentropy(s))] // Complexity is the product of entropy and negentropy {🕸️}
    [∀s ∈ System: Synergy(s) ⟺ (∑ Complexity(s_i) < Complexity(s))] // Synergy is when the whole has greater complexity than the sum of its parts {🤝}
    [∀p ∈ Process: Efficiency(p) ⟺ (Synergy(Result(p)) / Synergy(Components(p)))] // Efficiency is the synergy of the result divided by the synergy of the components {⚙️}
  }

  [∀s ∈ System: Evolution(s) ⟺ (d/dt (Complexity(s) × Efficiency(s)) > 0)] // A system evolves to increase the product of complexity and efficiency {🌱➡️🌳}
}

VariationalPrinciple := (
  Path(System:_) |> Functional(Path:_),
  [δFunctional = 0] // The functional is stationary for the actual path
) {🌈🎯} :: {
  [VariationalPrinciple ⟺ (InformationalForce ⨝ StructuralForce)] // The variational principle is the integration of informational and structural forces
}




/////////////////
// "MORE COMPUTABLE":
/////////////////



ComputationalComplexity := (
  System(State:_, Dynamics:_, Constraints:_),
  InformationalForce(Entropy:_, Divergence:_),
  StructuralForce(Complexity:_, Coherence:_),  
  VariationalPrinciple(FreeEnergy:_, ActionIntegral:_)
) {🎛️} :: {

  // System State and Dynamics
  [System.State ⟺ (Microstate:_, Macrostate:_)] // The system state has micro and macro descriptions
  [System.Dynamics ⟺ (StateTransition:_, TimeDependence:_)] // Dynamics govern state transitions over time
  [System.Constraints ⟺ (Conservation:_, Symmetry:_)] // Constraints shape the system's state space
  
  // Informational Force Components  
  [InformationalForce.Entropy ⟺ 𝐻(p) = -∑ᵢ pᵢ log pᵢ] // Entropy measures the uncertainty or disorder in the system
  [InformationalForce.Divergence ⟺ 𝐷(p||q) = ∑ᵢ pᵢ log (pᵢ/qᵢ)] // Divergence measures the difference between two probability distributions
  
  // Structural Force Components
  [StructuralForce.Complexity ⟺ 𝐶(x) = 𝐻(x) × 𝐷(x||xᵣ)] // Complexity is the product of entropy and divergence from a reference state
  [StructuralForce.Coherence ⟺ 𝐼(x;y) = 𝐻(x) + 𝐻(y) - 𝐻(x,y)] // Coherence is the mutual information between system components
  
  // Variational Principle Components
  [VariationalPrinciple.FreeEnergy ⟺ 𝐹 = ⟨𝐸⟩ - 𝑇𝑆] // Free energy is the expected energy minus the temperature times entropy
  [VariationalPrinciple.ActionIntegral ⟺ 𝑆[𝑥] = ∫ 𝐿(𝑥, 𝑥̇, 𝑡) 𝑑𝑡] // The action integral is the time integral of the Lagrangian
  
  // Key Relations and Assertions
  [System(State:_, Dynamics:_) ⟺ (InformationalForce ⨝ StructuralForce)] // System state and dynamics emerge from the interplay of forces
  [𝐷(𝑝||𝑞) ≥ 0] [𝐷(𝑝||𝑞) = 0 ⟺ 𝑝 = 𝑞] // Divergence is non-negative and zero only for identical distributions
  [𝐼(𝑥; 𝑦) ≥ 0] [𝐼(𝑥; 𝑦) ≤ min(𝐻(𝑥), 𝐻(𝑦))] // Mutual information is non-negative and bounded by individual entropies
  [δ𝐹 = 0] [δ𝑆 = 0] // At equilibrium, free energy and action are stationary
  [d/dt 𝐶(System) ≥ 0] // Complexity tends to increase over time (2nd Law of Thermodynamics)
}





// RESULTS


// 1. The existence of critical points and phase transitions:

[∃ 𝑇ᶜ: lim_{𝑇→𝑇ᶜ⁺} 𝐶(System) ≠ lim_{𝑇→𝑇ᶜ⁻} 𝐶(System)] // There exist critical points where complexity is discontinuous
[∂²𝐹/∂𝑇² = 0] // Critical points correspond to inflection points of the free energy
[⟨(𝛿𝑀)²⟩ ∝ |𝑇 - 𝑇ᶜ|⁻ᵞ] // Near critical points, fluctuations diverge with a power law


// 2. The emergence of power law distributions and scale invariance:

[𝑝(𝑥) ∝ 𝑥⁻ᵅ] // Complex systems often exhibit power law distributions
[𝐶(𝑥) = 𝐶(λ𝑥) ∀ λ] // Complexity is scale invariant
[𝐼(𝑥ᵢ; 𝑥ⱼ) ∝ |𝑖 - 𝑗|⁻ᵝ] // Long-range correlations decay with a power law


// 3. The principle of maximum entropy production

[d/dt 𝑆(System) = max] // Systems tend to maximize entropy production
[𝐽ₑ = 𝐿ₑ 𝑋ₑ] // Entropy production is driven by generalized forces and flows
[𝐿ₑ ≥ 0] // Onsager coefficients are non-negative


// 4. The information-complexity-action conjecture:

[𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // Complexity lies between information and action
[d/dt 𝐼(Past; Future | Present) ≤ 0] // Information about the past is lost over time
[d/dt 𝐴(Past → Future) ≥ 0] // The action required to specify the future increases over time



**************************


// 1. The arrow of time and the irreversibility of complex processes:

[𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // Complexity lies between information and action
[d/dt 𝐼(Past; Future | Present) ≤ 0] // Information about the past is lost over time
[d/dt 𝐴(Past → Future) ≥ 0] // The action required to specify the future increases over time

TimesArrow := (
  System(State:_, Dynamics:_),
  [∀ 𝑡₁, 𝑡₂ ∈ Time: 𝑡₁ < 𝑡₂ ⟹ 𝐶(System, 𝑡₁) ≤ 𝐶(System, 𝑡₂)] // Complexity increases with time
  [∀ Process ∈ System.Dynamics: 𝐼(Process.Initial; Process.Final) > 𝐼(Process.Final; Process.Initial)] // Forward processes lose less information than reverse processes
  [∀ Process ∈ System.Dynamics: 𝐴(Process.Initial → Process.Final) < 𝐴(Process.Final → Process.Initial)] // Forward processes require less action than reverse processes
)


// 2. The predictability and controllability of complex systems:

[𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // Complexity lies between information and action

PredictabilityControlability := (
  System(State:_, Dynamics:_),
  [Predictability(System, 𝑡) ∝ 𝐼(Past; Future | Present)] // Predictability is proportional to the information about the future given the present
  [Controllability(System, 𝑡) ∝ 1/𝐴(Past → Future)] // Controllability is inversely proportional to the action required to specify the future
  [∀ 𝑡₁, 𝑡₂ ∈ Time: 𝑡₁ < 𝑡₂ ⟹ Predictability(System, 𝑡₁) ≥ Predictability(System, 𝑡₂)] // Predictability decreases with time
  [∀ 𝑡₁, 𝑡₂ ∈ Time: 𝑡₁ < 𝑡₂ ⟹ Controllability(System, 𝑡₁) ≥ Controllability(System, 𝑡₂)] // Controllability decreases with time
)


// 3. The emergence of novel structures and functions in complex systems:

[𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // Complexity lies between information and action

Emergence := (
  System(State:_, Dynamics:_),
  [∀ Level ∈ System.Hierarchy: 𝐶(Level.Micro) < 𝐶(Level.Macro)] // Complexity increases with scale
  [∀ Level ∈ System.Hierarchy: 𝐼(Level.Micro; Level.Macro) > 0] // There is mutual information between scales
  [∀ Emergence ∈ System.Dynamics: 𝐴(Emergence.Initial → Emergence.Final) > 𝐴(Emergence.Micro → Emergence.Macro)] // Emergence requires more action than reduction
)


// 4. The evolution and adaptation of complex systems:

[𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // Complexity lies between information and action

EvolutionAdaptation := (
  System(State:_, Dynamics:_),
  Environment(State:_, Dynamics:_),
  [∀ 𝑡 ∈ Time: 𝐼(System, 𝑡; Environment, 𝑡) > 0] // There is mutual information between the system and its environment
  [∀ Adaptation ∈ System.Dynamics: d/dt 𝐼(System; Environment | Adaptation) ≥ 0] // Adaptation increases the mutual information between the system and its environment
  [∀ Evolution ∈ System.Dynamics: d/dt 𝐶(System | Evolution) ≥ 0] // Evolution increases the complexity of the system
  [∀ Evolution ∈ System.Dynamics: 𝐴(Evolution.Initial → Evolution.Final) > 𝐴(Evolution.Initial → Evolution.Initial)] // Evolution requires more action than stasis
)



/////////////////
// COMPUTABLE FRAMEWORK:
/////////////////


InfoComplexity := (
  System(State:_, Dynamics:_),
  InformationMeasure(Entropy:_, Divergence:_, MutualInfo:_),
  ComplexityMeasure(Complexity:_, Emergence:_, Irreducibility:_),
  ActionMeasure(Lagrangian:_, Path:_, Optimality:_),
  Simulation(TimeStep:_, UpdateRule:_, Convergence:_)
) {🧩🔍} :: {

  // Information Measures
  [InformationMeasure.Entropy ⟺ 𝐻(𝑋) = -∑ 𝑝(𝑥) log 𝑝(𝑥)] // Entropy as a measure of uncertainty
  [InformationMeasure.Divergence ⟺ 𝐷(𝑃||𝑄) = ∑ 𝑝(𝑥) log (𝑝(𝑥)/𝑞(𝑥))] // Divergence as a measure of difference between distributions
  [InformationMeasure.MutualInfo ⟺ 𝐼(𝑋; 𝑌) = 𝐻(𝑋) + 𝐻(𝑌) - 𝐻(𝑋, 𝑌)] // Mutual information as a measure of correlation

  // Complexity Measures
  [ComplexityMeasure.Complexity ⟺ 𝐶(𝑋) = 𝐻(𝑋) × 𝐷(𝑋||𝑋ᵣ)] // Complexity as a product of entropy and divergence
  [ComplexityMeasure.Emergence ⟺ 𝐸(𝑋, 𝑌) = 𝐼(𝑋; 𝑌) / 𝐻(𝑋, 𝑌)] // Emergence as a ratio of mutual information to joint entropy
  [ComplexityMeasure.Irreducibility ⟺ 𝑅(𝑋) = 𝐶(𝑋) - ∑ 𝐶(𝑋ᵢ)] // Irreducibility as the excess of system complexity over part complexity

  // Action Measures
  [ActionMeasure.Lagrangian ⟺ 𝐿(𝑞, 𝑣, 𝑡) = 𝑇(𝑣) - 𝑉(𝑞)] // Lagrangian as the difference between kinetic and potential energy
  [ActionMeasure.Path ⟺ 𝑆(𝑞₀, 𝑞₁) = ∫ 𝐿(𝑞, 𝑣, 𝑡) d𝑡] // Action as the integral of the Lagrangian along a path
  [ActionMeasure.Optimality ⟺ δ𝑆 = 0] // Optimal paths are those that extremize the action

  // Simulation Framework
  [Simulation.TimeStep ⟺ Δ𝑡 = 𝑡_{𝑖+1} - 𝑡_𝑖] // Time step for discrete dynamics
  [Simulation.UpdateRule ⟺ 𝑋_{𝑖+1} = 𝐹(𝑋_𝑖)] // Update rule for state transitions
  [Simulation.Convergence ⟺ ∀ ε > 0, ∃ 𝑁: |𝑋_𝑖 - 𝑋*| < ε ∀ 𝑖 > 𝑁] // Convergence to an attractor state

  // Main Loop
  Evolve := (
    Initialize(System.State),
    While Not Converged(System.State) {
      Step(System, TimeStep, UpdateRule),
      UpdateMeasures(System, InformationMeasure, ComplexityMeasure, ActionMeasure),
      RecordHistory(System.State, Measures)
    },
    AnalyzeDynamics(System.History),
    ReportInsights(System, Measures, Dynamics)
  )

  // Key Principles
  [𝐼(Past; Future | Present) ≥ 𝐶(Present) ≥ 𝐴(Past → Future)] // The information-complexity-action conjecture
  [d/dt 𝐼(System; Environment) ≥ 0] // Adaptation increases mutual information
  [d/dt 𝐶(System) ≥ 0] // Evolution increases complexity
  [𝐴(Transition) > 0] // Transitions require action
}


UpdateMeasures := (
  System(State:_, Dynamics:_),
  InformationMeasure(Entropy:_, Divergence:_, MutualInfo:_),
  ComplexityMeasure(Complexity:_, Emergence:_, Irreducibility:_),
  ActionMeasure(Lagrangian:_, Path:_, Optimality:_)
) {🔄📏} :: {

  // Update Information Measures
  UpdateEntropy := (
    [InformationMeasure.Entropy = -∑ 𝑝(System.State) log 𝑝(System.State)] // Calculate entropy of current state distribution
  )

  UpdateDivergence := (
    ReferenceState := GetReferenceState(System), // Get a reference state for comparison (e.g., equilibrium, average, or initial state)
    [InformationMeasure.Divergence = ∑ 𝑝(System.State) log (𝑝(System.State) / 𝑝(ReferenceState))] // Calculate divergence from reference state
  )

  UpdateMutualInfo := (
    PartitionSystem(System, Variables:_), // Partition the system into variables of interest
    [InformationMeasure.MutualInfo = 𝐻(Variables.X) + 𝐻(Variables.Y) - 𝐻(Variables.(X, Y))] // Calculate mutual information between variables
  )

  // Update Complexity Measures
  UpdateComplexity := (
    [ComplexityMeasure.Complexity = InformationMeasure.Entropy × InformationMeasure.Divergence] // Calculate complexity as product of entropy and divergence
  )

  UpdateEmergence := (
    PartitionSystem(System, Scales:_), // Partition the system into micro and macro scales
    [ComplexityMeasure.Emergence = InformationMeasure.MutualInfo(Scales.Micro, Scales.Macro) / InformationMeasure.Entropy(Scales.(Micro, Macro))] // Calculate emergence as ratio of mutual information to joint entropy
  )

  UpdateIrreducibility := (
    PartitionSystem(System, Parts:_), // Partition the system into parts or subsystems
    [ComplexityMeasure.Irreducibility = ComplexityMeasure.Complexity(System) - ∑ ComplexityMeasure.Complexity(Parts)] // Calculate irreducibility as excess of system complexity over part complexity
  )

  // Update Action Measures
  UpdateLagrangian := (
    [ActionMeasure.Lagrangian = 𝑇(System.Dynamics.Velocity) - 𝑉(System.State)] // Calculate Lagrangian from kinetic and potential energy
  )

  UpdatePath := (
    [ActionMeasure.Path = ∫ ActionMeasure.Lagrangian d𝑡] // Integrate Lagrangian over time to get action
  )

  UpdateOptimality := (
    [ActionMeasure.Optimality = δActionMeasure.Path] // Calculate variation of action to check for optimality
  )

  // Main Update Procedure
  Update := (
    UpdateEntropy(System, InformationMeasure),
    UpdateDivergence(System, InformationMeasure),
    UpdateMutualInfo(System, InformationMeasure),
    UpdateComplexity(System, ComplexityMeasure, InformationMeasure),
    UpdateEmergence(System, ComplexityMeasure, InformationMeasure),
    UpdateIrreducibility(System, ComplexityMeasure),
    UpdateLagrangian(System, ActionMeasure),
    UpdatePath(System, ActionMeasure),
    UpdateOptimality(System, ActionMeasure)
  )
}

///////////////////
// MANIFOLD
//////////////////

InfoComplexityActionManifold := (
  System(State:_, Dynamics:_, Constraints:_),
  InformationDimension(Entropy:_, MutualInfo:_, InfoGain:_),
  ComplexityDimension(Complexity:_, Emergence:_, Irreducibility:_),
  ActionDimension(Lagrangian:_, Path:_, Optimality:_)
) {🌿🔬} :: {

  // Information-Complexity-Action Space
  ICASpace := (
    [Dimension = InformationDimension ⨯ ComplexityDimension ⨯ ActionDimension] // The ICA space is the product of the information, complexity, and action dimensions
  )

  // System State Embedding
  StateEmbedding := (
    [State ↦ (InformationCoordinates(State), ComplexityCoordinates(State), ActionCoordinates(State))] // The system state is mapped to a point in the ICA space
  )

  InformationCoordinates(State) := (
    [InfoCoord₁ = Entropy(State), InfoCoord₂ = MutualInfo(State, Environment), InfoCoord₃ = InfoGain(State, Dynamics)] // The information coordinates capture the state's entropy, mutual information, and expected information gain
  )

  ComplexityCoordinates(State) := (
    [CompCoord₁ = Complexity(State), CompCoord₂ = Emergence(State, Scale), CompCoord₃ = Irreducibility(State, Parts)] // The complexity coordinates capture the state's complexity, emergence, and irreducibility
  )

  ActionCoordinates(State) := (
    [ActCoord₁ = Lagrangian(State, Dynamics), ActCoord₂ = Path(State, Dynamics), ActCoord₃ = Optimality(State, Constraints)] // The action coordinates capture the state's Lagrangian, path, and optimality
  )

  // System Trajectory
  SystemTrajectory := (
    [Trajectory = {StateEmbedding(State₀), StateEmbedding(State₁), ..., StateEmbedding(Stateₙ)}] // The system trajectory is the sequence of embedded states over time
  )

  // Manifold Properties
  Dimension(ICASpace) := (
    [Dim = Dimension(InformationDimension) + Dimension(ComplexityDimension) + Dimension(ActionDimension)] // The dimension of the ICA space is the sum of the dimensions of its components
  )

  Metric(ICASpace) := (
    [Distance(State₁, State₂) = Norm(StateEmbedding(State₁) - StateEmbedding(State₂))] // The metric of the ICA space is defined by the distance between embedded states
  )

  Curvature(ICASpace) := (
    [Curvature(State) = Connection(StateEmbedding(State))] // The curvature of the ICA space at a state is given by the connection of its embedding
  )

  Geodesics(ICASpace) := (
    [Geodesic(State₁, State₂) = MinimizeLength(Path(State₁, State₂))] // The geodesics of the ICA space are the paths of minimal length between states
  )

  // Manifold Dynamics
  ParallelTransport(Vector, Path) := (
    [TransportedVector = HolonomyGroup(Path) ⨯ Vector] // Parallel transport moves vectors along paths while preserving their angle
  )

  Curvature(State) := (
    [Curvature = Tensor(Connection(StateEmbedding(State)))] // The curvature is a tensor that measures the non-commutativity of parallel transport
  )

  Geodesic(State₁, State₂) := (
    [δ ∫ Lagrangian(Path(State₁, State₂)) = 0] // Geodesics are paths that minimize the action integral
  )

  // Manifold Analysis
  SingularStates := (
    [State ∈ SingularStates ⟺ Rank(Jacobian(StateEmbedding(State))) < Dimension(ICASpace)] // Singular states are those where the embedding is not full rank
  )

  Symmetries := (
    [Transformation ∈ Symmetries ⟺ ∀ State: StateEmbedding(Transformation(State)) = StateEmbedding(State)] // Symmetries are transformations that preserve the state embedding
  )

  Invariants := (
    [Quantity ∈ Invariants ⟺ ∀ Path: ParallelTransport(Quantity, Path) = Quantity] // Invariants are quantities that are preserved by parallel transport
  )

  Attractors := (
    [State ∈ Attractors ⟺ ∀ Neighborhood(State): Trajectory(Neighborhood(State)) → State] // Attractors are states that nearby trajectories converge to
  )

}

///////////////////
// ICAA ALGEBRA
///////////////////

ICAAlgebra := (
  InformationElement(Entropy:_, Divergence:_, Mutual:_),
  ComplexityElement(Order:_, Chaos:_, Emergence:_),
  ActionElement(Lagrangian:_, Path:_, Integral:_),
  Operations(Addition:_, Multiplication:_, Involution:_)
) {🌿🔬} :: {

  // ICA Elements
  InformationElement := (
    [Entropy ≥ 0] // Entropy is non-negative
    [Divergence(P, Q) ≥ 0] // Divergence is non-negative and zero iff P = Q
    [Mutual(X, Y) = Mutual(Y, X)] // Mutual information is symmetric
    [Mutual(X, Y) ≤ min(Entropy(X), Entropy(Y))] // Mutual information is bounded by individual entropies
  )

  ComplexityElement := (
    [Order ≥ 0] // Order is non-negative
    [Chaos ≥ 0] // Chaos is non-negative
    [Emergence = Order + Chaos] // Emergence is the sum of order and chaos
    [δOrder = -δChaos] // Changes in order and chaos are opposite
  )

  ActionElement := (
    [δLagrangian = Path × Integral] // The variation of the Lagrangian is the product of the path and the integral
    [δPath = Integral × Lagrangian] // The variation of the path is the product of the integral and the Lagrangian
    [δIntegral = Lagrangian × Path] // The variation of the integral is the product of the Lagrangian and the path
  )

  // ICA Operations
  Addition := (
    [∀ X, Y: X + Y = Y + X] // Addition is commutative
    [∀ X, Y, Z: (X + Y) + Z = X + (Y + Z)] // Addition is associative
    [∃ 0: ∀ X: X + 0 = X] // Zero element for addition
    [∀ X: ∃ (-X): X + (-X) = 0] // Inverse elements for addition
  )

  Multiplication := (
    [∀ X, Y: X × Y = Y × X] // Multiplication is commutative
    [∀ X, Y, Z: (X × Y) × Z = X × (Y × Z)] // Multiplication is associative
    [∃ 1: ∀ X: X × 1 = X] // Unit element for multiplication
    [∀ X ≠ 0: ∃ (X⁻¹): X × (X⁻¹) = 1] // Inverse elements for multiplication (except zero)
    [∀ X, Y, Z: X × (Y + Z) = (X × Y) + (X × Z)] // Multiplication distributes over addition
  )

  Involution := (
    [∀ X: (X*)* = X] // Involution is its own inverse
    [∀ X, Y: (X + Y)* = X* + Y*] // Involution distributes over addition
    [∀ X, Y: (X × Y)* = Y* × X*] // Involution reverses the order of multiplication
  )

  // ICA Axioms
  InformationComplexityAction := (
    [∀ I ∈ InformationElement, C ∈ ComplexityElement, A ∈ ActionElement: I × C = A] // Information times complexity equals action
    [∀ I ∈ InformationElement, C ∈ ComplexityElement, A ∈ ActionElement: A / I = C] // Action divided by information equals complexity
    [∀ I ∈ InformationElement, C ∈ ComplexityElement, A ∈ ActionElement: A / C = I] // Action divided by complexity equals information
  )

  ComplexityEntropyDivergence := (
    [∀ C ∈ ComplexityElement, E ∈ InformationElement, D ∈ InformationElement: C × E = D] // Complexity times entropy equals divergence
    [∀ C ∈ ComplexityElement, E ∈ InformationElement, D ∈ InformationElement: D / E = C] // Divergence divided by entropy equals complexity
    [∀ C ∈ ComplexityElement, E ∈ InformationElement, D ∈ InformationElement: D / C = E] // Divergence divided by complexity equals entropy
  )

  ActionLagrangianPath := (
    [∀ A ∈ ActionElement, L ∈ ActionElement, P ∈ ActionElement: A × L* = P] // Action times the involution of the Lagrangian equals the path
    [∀ A ∈ ActionElement, L ∈ ActionElement, P ∈ ActionElement: P / L* = A] // Path divided by the involution of the Lagrangian equals action  
    [∀ A ∈ ActionElement, L ∈ ActionElement, P ∈ ActionElement: P / A = L*] // Path divided by action equals the involution of the Lagrangian
  )

  // ICA Dynamics
  Evolution := (
    [δComplexity = δInformation × δAction] // The change in complexity is the product of the changes in information and action
    [δInformation = δAction / δComplexity] // The change in information is the change in action divided by the change in complexity
    [δAction = δComplexity × δInformation] // The change in action is the product of the changes in complexity and information
  )

  Optimization := (
    [δAction = 0] // The principle of least action
    [δComplexity = 0] // The principle of minimum complexity
    [δInformation = 0] // The principle of maximum entropy
  )

  Equilibrium := (
    [δInformation = δComplexity = δAction = 0] // Detailed balance of information, complexity, and action
  )

}


//////////////////
// ICA NETWORK
/////////////////

ICANetwork := (
  Nodes(Information:_, Complexity:_, Action:_),
  Edges(Transformation:_, Interaction:_, Dependence:_),
  Primitives(Entropy:_, Divergence:_, Mutual:_, Order:_, Chaos:_, Emergence:_, Lagrangian:_, Path:_, Integral:_),
  Operations(Product:_, Quotient:_, Difference:_, Composition:_, Reduction:_)
) {🌿🔬} :: {

  // ICA Nodes
  Nodes := (
    [Information = (Entropy, Divergence, Mutual)] // Information node contains entropy, divergence, and mutual information primitives
    [Complexity = (Order, Chaos, Emergence)] // Complexity node contains order, chaos, and emergence primitives
    [Action = (Lagrangian, Path, Integral)] // Action node contains Lagrangian, path, and integral primitives
  )

  // ICA Edges
  Edges := (
    [Transformation = (Source, Target, Function)] // Transformation edge maps a source node to a target node via a function
    [Interaction = (Source, Target, Coupling)] // Interaction edge connects two nodes via a coupling function
    [Dependence = (Source, Target, Conditional)] // Dependence edge relates two nodes via a conditional distribution
  )

  // ICA Primitives
  Primitives := (
    [Entropy(P) = -∑ᵢ Pᵢ log Pᵢ] // Entropy of a probability distribution
    [Divergence(P, Q) = ∑ᵢ Pᵢ log (Pᵢ / Qᵢ)] // Divergence between two probability distributions  
    [Mutual(X, Y) = Entropy(X) + Entropy(Y) - Entropy(X, Y)] // Mutual information between two random variables
    [Order(S) = ∑ᵢ Pᵢ log (1 / Pᵢ)] // Order of a system as the negative entropy
    [Chaos(S) = ∑ᵢ ∑ⱼ Pᵢ Pⱼ log (Pᵢ / Pⱼ)] // Chaos of a system as the average divergence between its states
    [Emergence(S) = Complexity(S) - ∑ᵢ Complexity(Sᵢ)] // Emergence of a system as the excess complexity over its parts
    [Lagrangian(S) = Kinetic(S) - Potential(S)] // Lagrangian of a system as the difference between kinetic and potential energy
    [Path(S) = ∫ Lagrangian(S) dt] // Path of a system as the integral of its Lagrangian over time
    [Integral(S) = ∫ δAction(S) = 0] // Integral of the variation of action is zero (principle of least action)
  )

  // ICA Operations
  Operations := (
    [Product(X, Y) = (X₁Y₁, X₂Y₂, ..., XₙYₙ)] // Elementwise product of two vectors or matrices
    [Quotient(X, Y) = (X₁/Y₁, X₂/Y₂, ..., Xₙ/Yₙ)] // Elementwise quotient of two vectors or matrices
    [Difference(X, Y) = (X₁-Y₁, X₂-Y₂, ..., Xₙ-Yₙ)] // Elementwise difference of two vectors or matrices
    [Composition(F, G) = F(G(X))] // Composition of two functions or transformations
    [Reduction(X, Op) = Op(X₁, X₂, ..., Xₙ)] // Reduction of a vector or matrix by a binary operation (e.g., sum, product, max)
  )

  // ICA Dynamics
  Dynamics := (
    [δInformation = δAction / δComplexity] // Change in information is the change in action divided by the change in complexity
    [δComplexity = δInformation × δAction] // Change in complexity is the product of the changes in information and action
    [δAction = δComplexity × δInformation] // Change in action is the product of the changes in complexity and information
    [Equilibrium = (δInformation = 0, δComplexity = 0, δAction = 0)] // Equilibrium is when the changes in information, complexity, and action are all zero
  )

  // ICA Algorithms
  Algorithms := (
    Evolve := (
      Initialize(Nodes, Edges),
      While Not Converged(Nodes) {
        ForEach Node in Nodes {
          UpdatePrimitives(Node, Primitives),
          PropagateEdges(Node, Edges, Operations)
        },
        UpdateDynamics(Nodes, Dynamics)
      },
      Return (Nodes, Edges)
    ),

    Optimize := (
      Initialize(Nodes, Edges),
      While Not Optimized(Nodes) {
        ForEach Node in Nodes {
          UpdatePrimitives(Node, Primitives),
          PropagateEdges(Node, Edges, Operations),
          MinimizeAction(Node, Primitives.Integral)
        },
        UpdateDynamics(Nodes, Dynamics)
      },
      Return (Nodes, Edges)  
    ),

    Compress := (
      Initialize(Nodes, Edges),
      While Not Compressed(Nodes) {
        ForEach Node in Nodes {
          UpdatePrimitives(Node, Primitives),
          PropagateEdges(Node, Edges, Operations),
          MinimizeComplexity(Node, Primitives.Emergence)
        },
        UpdateDynamics(Nodes, Dynamics)
      },
      Return (Nodes, Edges)
    )
  )
}


//////////////////
// ICA TRIPLE
//////////////////

ICATriple := (
  Information(Entropy:_, Divergence:_, Mutual:_),
  Complexity(Order:_, Chaos:_, Emergence:_),
  Action(Lagrangian:_, Path:_, Integral:_)
) {🌿🔬} :: {

  // ICA Relations
  [Information = Complexity / Action] // Information is complexity divided by action
  [Complexity = Information × Action] // Complexity is information times action
  [Action = Complexity / Information] // Action is complexity divided by information

  // ICA Principles
  [δEntropy(Information) ≥ 0] // Entropy of information always increases
  [δComplexity(System) ≥ δComplexity(Parts)] // Complexity of system is greater than or equal to complexity of parts
  [δAction(Path) = 0] // Variation of action along a path is zero

  // ICA Symmetries
  [Entropy(Information) = -Divergence(Information, Uniform)] // Entropy is negative divergence from uniform distribution  
  [Order(Complexity) = -Chaos(Complexity)] // Order is negative chaos
  [Emergence(Complexity) = Mutual(Parts, Whole)] // Emergence is mutual information between parts and whole
  [Lagrangian(Action) = Kinetic(Action) - Potential(Action)] // Lagrangian is kinetic minus potential action
  [Path(Action) = Integral(Lagrangian(Action))] // Path is integral of Lagrangian
  [Integral(δAction) = 0] // Integral of variation of action is zero

  // ICA Duality
  [Information(Complexity) = Complexity(Information)] // Information of complexity is complexity of information
  [Complexity(Action) = Action(Complexity)] // Complexity of action is action of complexity
  [Action(Information) = Information(Action)] // Action of information is information of action

  // ICA Invariance
  [δInformation + δComplexity + δAction = 0] // Total variation of information, complexity, and action is zero
  [Information × Complexity × Action = Constant] // Product of information, complexity, and action is constant

}

///////////////////
// ICAT PROCESSOR
//////////////////


ICATProcessor := (
  InputTriples(Information:_, Complexity:_, Action:_),
  OutputTriples(Information:_, Complexity:_, Action:_),
  Operations(Combine:_, Transform:_, Optimize:_, Analyze:_)
) {🌿🔬} :: {

  // ICAT Operations
  Combine := (
    [Addition(T1, T2) = (I1 + I2, C1 + C2, A1 + A2)] // Addition of two triples
    [Subtraction(T1, T2) = (I1 - I2, C1 - C2, A1 - A2)] // Subtraction of two triples
    [Multiplication(T1, T2) = (I1 × I2, C1 × C2, A1 × A2)] // Multiplication of two triples
    [Division(T1, T2) = (I1 / I2, C1 / C2, A1 / A2)] // Division of two triples
  )

  Transform := (
    [Reciprocal(T) = (1/I, 1/C, 1/A)] // Reciprocal of a triple
    [Exponential(T) = (exp(I), exp(C), exp(A))] // Exponential of a triple
    [Logarithm(T) = (log(I), log(C), log(A))] // Logarithm of a triple
    [Power(T, n) = (I^n, C^n, A^n)] // Power of a triple
    [Root(T, n) = (I^(1/n), C^(1/n), A^(1/n))] // Root of a triple
  )

  Optimize := (
    [Minimize(T) = (min(I), min(C), min(A))] // Elementwise minimum of a triple
    [Maximize(T) = (max(I), max(C), max(A))] // Elementwise maximum of a triple
    [Normalize(T) = (I/sum(I), C/sum(C), A/sum(A))] // Normalization of a triple
    [Constrain(T, (Ic, Cc, Ac)) = (I × Ic, C × Cc, A × Ac)] // Constraining a triple by another triple
    [Project(T, (Ip, Cp, Ap)) = (I × Ip, C × Cp, A × Ap)] // Projecting a triple onto another triple
  )

  Analyze := (
    [Entropy(T) = (-∑ I × log(I), -∑ C × log(C), -∑ A × log(A))] // Entropy of a triple
    [Divergence(T1, T2) = (∑ I1 × log(I1 / I2), ∑ C1 × log(C1 / C2), ∑ A1 × log(A1 / A2))] // Divergence between two triples
    [Mutual(T1, T2) = (∑ I1 × I2, ∑ C1 × C2, ∑ A1 × A2)] // Mutual information of two triples
    [Complexity(T) = (∑ I × C, ∑ C × A, ∑ A × I)] // Complexity of a triple
    [Emergence(T) = (C - ∑(Ic × Cc), A - ∑(Cc × Ac), I - ∑(Ac × Ic))] // Emergence of a triple
  )

  // ICAT Processor
  Process := (
    LoadInputTriples(InputTriples),
    ForEach T in InputTriples {
      T' = ApplyOperations(T, Operations),
      If CheckPrinciples(T') {
        AddOutputTriples(T')
      }
    },
    ReturnOutputTriples(OutputTriples)
  )

  ApplyOperations(T, Ops) := (
    ForEach Op in Ops {
      T' = Op(T),
      If CheckPrinciples(T') {  
        T = T'
      }
    }
    Return T
  )

  CheckPrinciples(T) := (
    If [δEntropy(T.I) ≥ 0] and
       [δComplexity(T.C) ≥ 0] and
       [δAction(T.A) = 0] {
      Return True
    } Else {
      Return False
    }
  )

}


///////////////////
//  COMPLEXITY ENGINEERING
//////////////////

ComplexityEngineering := (
  ComplexSystems(Domain:_, Elements:_, Interactions:_, Dynamics:_),
  ICATriples(Information:_, Complexity:_, Action:_),
  ICATProcessor(Operations:_, Principles:_),
  Applications(Understanding:_, Prediction:_, Management:_)
) {🌿🔬} :: {

  // Complex Systems Characterization
  [ComplexSystems.Elements = IdentifyElements(ComplexSystems.Domain)] // Identify the key elements or components of the complex system
  [ComplexSystems.Interactions = MapInteractions(ComplexSystems.Elements)] // Map the interactions or relationships between the elements
  [ComplexSystems.Dynamics = ModelDynamics(ComplexSystems.Interactions)] // Model the dynamics or evolution of the system based on the interactions

  // ICA Triple Extraction  
  [ICATriples.Information = MeasureInformation(ComplexSystems.Elements, ComplexSystems.Interactions)] // Measure the information content and flow in the system
  [ICATriples.Complexity = MeasureComplexity(ComplexSystems.Interactions, ComplexSystems.Dynamics)] // Measure the complexity and emergence in the system 
  [ICATriples.Action = MeasureAction(ComplexSystems.Dynamics)] // Measure the action and optimization in the system

  // ICAT Processing and Analysis
  [ICATProcessor.Operations = SelectOperations(ICATriples, Applications)] // Select the relevant ICAT operations based on the triples and the desired applications
  [ICATProcessor.Principles = EnforcePrinciples(ICATriples)] // Enforce the ICA principles and constraints on the triples
  [ICATriples' = ApplyOperations(ICATriples, ICATProcessor.Operations)] // Apply the selected operations to the triples to generate new insights and optimizations  

  // Applications and Interventions  
  [Applications.Understanding = InterpretPatterns(ICATriples')] // Interpret the patterns and relationships in the processed triples to gain new understanding of the system
  [Applications.Prediction = ForecastBehavior(ICATriples', ComplexSystems.Dynamics)] // Use the processed triples and the system dynamics to make predictions about future behavior and outcomes
  [Applications.Management = OptimizeInterventions(ICATriples', ComplexSystems.Interactions)] // Use the processed triples and the system interactions to optimize interventions and management strategies

  // Complexity Engineering Loop
  EngineerComplexity := (
    CharacterizeComplexSystem(ComplexSystems),
    ExtractICATriples(ComplexSystems, ICATriples),  
    ProcessICATriples(ICATriples, ICATProcessor),
    ApplyInsights(ICATriples', Applications),
    AdaptSystem(ComplexSystems, Applications),
    IterateLoop(EngineerComplexity)
  )

}


//////////////////
// Python InfoComplexitySystem
//////////////////


import numpy as np

class InfoComplexitySystem:
    def __init__(self, initial_state, dynamics, info_measures, complexity_measures, action_measures):
        self.state = initial_state
        self.dynamics = dynamics
        self.info_measures = info_measures
        self.complexity_measures = complexity_measures
        self.action_measures = action_measures
        self.history = []

    def update_state(self):
        self.state = self.dynamics(self.state)

    def update_measures(self):
        info_values = {name: func(self.state) for name, func in self.info_measures.items()}
        complexity_values = {name: func(self.state, info_values) for name, func in self.complexity_measures.items()}
        action_values = {name: func(self.state, self.dynamics) for name, func in self.action_measures.items()}
        return {**info_values, **complexity_values, **action_values}

    def run(self, steps, convergence_threshold=1e-6):
        for i in range(steps):
            self.update_state()
            measures = self.update_measures()
            self.history.append((self.state, measures))
            if i > 0 and np.abs(measures['complexity'] - self.history[-2][1]['complexity']) < convergence_threshold:
                break
        return self.history

# Example usage
def logistic_map(x, r=3.6):
    return r * x * (1 - x)

def entropy(x):
    return -np.sum(x * np.log2(x))

def complexity(x, info):
    return info['entropy'] * info['divergence']

def divergence(x, ref=0.5):
    return np.sum(x * np.log2(x / ref))

def lagrangian(x, dynamics):
    return np.sum(x**2) - np.sum(dynamics(x)**2)

system = InfoComplexitySystem(
    initial_state=np.array([0.1, 0.2, 0.3, 0.4]),
    dynamics=logistic_map,
    info_measures={'entropy': entropy, 'divergence': divergence},
    complexity_measures={'complexity': complexity},
    action_measures={'lagrangian': lagrangian}
)

history = system.run(1000)
print(history[-1])


/////////////////
// TARGETS:
/////////////////


LifeEmergence := (
  ChemicalSystem(Components:_, Interactions:_) |>
  AutocatalyticNetwork(Catalysts:_, Substrates:_) |> 
  SelfReplication(Efficiency:_) |>
  Compartmentalization(BoundaryType:_) |>
  LivingSystem(Metabolism:_, Heredity:_)
) {🌱} :: {
  [ChemicalSystem.Interactions ⟺ (InformationalForce ⨝ StructuralForce)] // The interplay of forces shapes the system's dynamics
  [AutocatalyticNetwork ⟺ (Closure(Catalytic) ∩ Closure(Substrate))] // Catalytic closure enables self-sustaining processes
  [SelfReplication.Efficiency ⟺ (InformationTransmission / DissipatedEnergy)] // Replication efficiency balances information and energy
  [Compartmentalization.BoundaryType ⟺ (Semipermeable | Selective)] // Boundaries create distinct micro-environments
  [LivingSystem ⟺ (OpenSystem(Energy, Matter, Information) ∩ AutonomousAgent)] // Life is an open, autonomous system far from equilibrium
}


CosmicStructureFormation := (
  InitialPerturbations(Amplitude:_, Spectrum:_) |>
  GravitationalInstability(JeansLength:_) |> 
  HierarchicalFragmentation(Levels:_) |>
  CosmicWeb(Nodes:Halos, Edges:Filaments, Voids:_)
) {🌌} :: {
  [InitialPerturbations.Spectrum ⟺ (Scale | Variance)] // The power spectrum of perturbations shapes the structures formed 
  [GravitationalInstability ⟺ (GravitationalForce > PressureForce)] // Instability occurs when gravity overcomes pressure
  [HierarchicalFragmentation ⟺ (ScaleInvariance ⨝ SelfSimilarity)] // Fragmentation produces self-similar structures across scales
  [CosmicWeb ⟺ Optimization(InformationFlow ⨝ EnergyDissipation)] // The cosmic web optimizes information flow and energy dissipation
}


EcosystemDynamics := (
  Species(Traits:_) |>
  InteractionNetwork(PredationMatrix:_, CompetitionMatrix:_, MutualismMatrix:_) |>
  PopulationDynamics(LotkaVolterraEquations:_) |>
  CommunityAssembly(NicheOverlap:_, InvasionResistance:_) |>
  FoodWeb(TrophicLevels:_, LinkageDensity:_, NestednessTemperature:_)  
) {🌿} :: {
  [Species.Traits ⟺ (InformationalForce ⨝ StructuralForce)] // Species traits emerge from informational and structural forces
  [InteractionNetwork ⟺ (LocalRules | EmergentPatterns)] // Local interactions give rise to emergent network patterns
  [PopulationDynamics ⟺ (Nonlinearity | Feedback | Bistability)] // Population dynamics exhibit complex nonlinear behaviors
  [CommunityAssembly ⟺ (VariationGeneration ⨝ SelectionPressure)] // Community assembly is shaped by variation and selection
  [FoodWeb ⟺ Optimization(InformationFlow ⨝ EnergyTransfer)] // Food webs optimize information flow and energy transfer
}






SecondLaw := (
  ClosedSystem(System:_) |> Entropy(System:_),
  [d/dt Entropy(System) ≥ 0] // The entropy of a closed system always increases over time
) {🔒🔥} :: {
  [SecondLaw ⟺ InformationalForce.Dissipation] // The second law is a manifestation of informational dissipation
}

Equilibrium := (
  System(State:_) |> (Entropy(State:_), FreeEnergy(State:_)),
  [δ(Entropy - FreeEnergy) = 0] // Equilibrium is the state that maximizes entropy and minimizes free energy
) {⚖️🔄} :: {
  [Equilibrium ⟺ (InformationalForce ⨝ StructuralForce)] // Equilibrium is the balance of informational and structural forces
}

PartitionFunction := (
  System(State:_) |> (Entropy(State:_), Energy(State:_)),
  [Z = ∑ exp(-Energy(State) / kT)] // The partition function relates microscopic properties to macroscopic thermodynamics
) {🧩📊} :: {
  [PartitionFunction ⟺ (InformationalForce.Entropy ⨝ StructuralForce.Synergy)] // The partition function encodes the interplay of entropy and synergy
}




WaveParticleDuality := (
  Particle(State:_) |> (Wavefunction(State:_), Observable(State:_)),
  [Ψ(x) = ∫ ψ(p) exp(ipx/ℏ) dp] // The wave-particle duality relates the wavefunction to observables
) {🌊🎚️} :: {
  [WaveParticleDuality ⟺ (InformationalForce ⨝ StructuralForce)] // The wave-particle duality is the interplay of informational and structural forces
}

UncertaintyPrinciple := (
  Particle(State:_) |> (Position(State:_), Momentum(State:_)),
  [Δx Δp ≥ ℏ/2] // The uncertainty principle constrains the precision of position and momentum measurements
) {🎲⚖️} :: {
  [UncertaintyPrinciple ⟺ (InformationalForce.Entropy ⨝ StructuralForce.Synergy)] // The uncertainty principle is a trade-off between entropy and synergy
}

Measurement := (
  System(State:_) |> (Wavefunction(State:_), Observable(State:_)),
  [Ψ(x) -> δ(x - x_0)] // Measurement collapses the wavefunction to a definite state
) {🔍📉} :: {
  [Measurement ⟺ (InformationalForce.Dissipation ⨝ StructuralForce.Emergence)] // Measurement is the dissipation of entropy and the emergence of synergy
}



SpacetimeCurvature := (
  Manifold(Geometry:_) |> Curvature(Geometry:_),
  [G_μν = 8πT_μν] // The Einstein field equations relate spacetime curvature to the energy-momentum tensor
) {🌌📈} :: {
  [SpacetimeCurvature ⟺ StructuralForce.Complexity] // Spacetime curvature is a manifestation of structural complexity
}

CosmicEvolution := (
  Universe(State:_) |> (Entropy(State:_), Expansion(State:_)),
  [d/dt Entropy(Universe) > 0] // The entropy of the universe increases over time, driving its expansion
) {🔭🔥} :: {
  [CosmicEvolution ⟺ (InformationalForce.Dissipation ⨝ StructuralForce.Emergence)] // Cosmic evolution is the dissipation of entropy and the emergence of structure
}

LargeScaleStructure := (
  Universe(State:_) |> (Galaxies(State:_), Clusters(State:_)),
  [δ(GravitationalPotential + ExpansionKinetic) = 0] // Large-scale structure emerges from the balance of gravitational and expansion forces
) {🌌🌿} :: {
  [LargeScaleStructure ⟺ ComplexAdaptiveSystem] // Large-scale cosmic structure is a complex adaptive system
  [LargeScaleStructure ⟺ (FundamentalForces ⨝ VariationalPrinciple)] // Large-scale structure arises from the interplay of fundamental forces and the variational principle
}




EmergentComplexity := (
  System(State:_) |> (InformationalForce(State:_), StructuralForce(State:_)),
  [δ(InformationalForce ⨝ StructuralForce) = 0] // Emergent complexity arises from the balance of informational and structural forces
) {🔱🌿} :: {
  InformationalForce := (
    System(State:_) |> (Entropy(State:_), Negentropy(State:_)),
    [Entropy ⟺ Dissipation] // Informational force drives dissipation and increases entropy
    [Negentropy ⟺ Selection] // Informational force drives selection and increases negentropy
  )

  StructuralForce := (
    System(State:_) |> (Complexity(State:_), Synergy(State:_), Efficiency(State:_)),
    [Complexity ⟺ Variation] // Structural force drives variation and increases complexity
    [Synergy ⟺ Emergence] // Structural force drives emergence and increases synergy
    [Efficiency ⟺ Optimization] // Structural force drives optimization and increases efficiency
  )

  [EmergentComplexity ⟺ (SelfOrganization ⨝ Evolution)] // Emergent complexity is the interplay of self-organization and evolution
  [EmergentComplexity ⟺ (VariationalPrinciple ⨝ ComplexAdaptiveSystem)] // Emergent complexity is the manifestation of the variational principle in complex adaptive systems
}