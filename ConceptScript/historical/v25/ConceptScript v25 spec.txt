ConceptScript v25

<Concept> ::= "CONCEPT" <ConceptName> ["[" <Params> "]"] [":" <ParentConcept>] "{"
               <Language>
               <Structure>*
               <Proofs>
             "}"
<Language> ::= "LANGUAGE" "{"
                 (<TypeDecl> | <ConstDecl> | <FuncDecl> | <PredDecl> |
                  <RewriteDecl> | <AxiomDecl> | <NotationDecl>)*
               "}"
<TypeDecl> ::= "TYPE" <TypeName> ["[" <Params> "]"] ["<:" <TypeName>] "=" <Type>
<Type> ::= <TypeName> ["(" <Type> ("," <Type>)* ")"]
         | "(" <Type> ("," <Type>)* ")"
         | <Type> "->" <Type>
         | <Type> "|" <Type>
<ConstDecl> ::= "CONST" <ConstName> ":" <Type>
<FuncDecl> ::= "FUNC" <FuncName> ["[" <Params> "]"] ":" <Type>
<PredDecl> ::= "PRED" <PredName> ["[" <Params> "]"] ":" <Type>
<RewriteDecl> ::= "REWRITE" <Pattern> "=" <Expression>
<AxiomDecl> ::= "AXIOM" <AxiomName> ["[" <Params> "]"] ":" <Formula>
<NotationDecl> ::= "NOTATION" <Notation> "=" <Expression>
<Structure> ::= "STRUCTURE" [<StructureName>] ["(" <Params> ")"] "{"
                  (<LetDecl> | <DefDecl> | <Requirement>)*
                "}"
<LetDecl> ::= "LET" <Pattern> [":" <Type>] "=" <Expression>
<DefDecl> ::= "DEF" <Pattern> [":" <Type>] "=" <Expression> ["WHERE" <Constraint>]
<Requirement> ::= "REQUIRE" <Expression>
<Pattern> ::= <Identifier>
            | "(" <Pattern> ("," <Pattern>)* ")"
<Proofs> ::= "PROOFS" "{"
               (<TacticDecl> | <TheoremDecl>)*
             "}"
<TacticDecl> ::= "TACTIC" <TacticName> ["[" <Params> "]"] "=" <Tactic>
<TheoremDecl> ::= "THEOREM" <TheoremName> ["[" <Params> "]"] "{"
                    "STATEMENT" ":" <Formula>
                    "PROOF" ":" <Proof>
                  "}"
<Proof> ::= <ProofStep> (";" <ProofStep>)*
<ProofStep> ::= <LetStep>
              | <HaveStep>
              | <ShowStep>
              | <ByStep>
              | <QedStep>
<LetStep> ::= "LET" <Pattern> [":" <Type>] "=" <Expression>
<HaveStep> ::= "HAVE" <Formula> ["BY" <Tactic>]
<ShowStep> ::= "SHOW" <Formula>
<ByStep> ::= "BY" <Tactic>
<QedStep> ::= "QED"


And here are a few examples (you generated these in a prior context):

CONCEPT CellularAutomaton {
  LANGUAGE {
    TYPE Cell
    TYPE State  
    TYPE Rule = List[State] -> State
    TYPE Grid = Matrix[Cell, N, M]
    TYPE CA = (Grid, Rule)
    TYPE Pattern
    TYPE Feature
    
    FUNC Evolve : (Grid, Rule, Nat) -> Grid

    PRED LocalRule : Rule -> Bool
    PRED Emergent : Feature -> Bool  
    PRED Stable : Pattern -> Bool

    AXIOM Emergence {
      âˆ€ (f : Feature) (g : Grid).
        Emergent(f) â‡” 
          (âˆ€ (c : Cell). Â¬LocalRule(Î» s. NextState(c, g, s))) âˆ§
          (âˆƒ p. Match(g, p) âˆ§ Expresses(p, f))
    }

    AXIOM Stability {
      âˆ€ (p : Pattern) (g : Grid) (r : Rule).
        Stable(p) â‡” 
          Match(g, p) âˆ§ âˆ€ k. Match(Evolve(g, r, k), p)
    }  

    NOTATION "[[" <Row> ("," <Row>)* "]]" = Grid
    NOTATION "[" <Cell> ("," <Cell>)* "]" = Row
  }

  STRUCTURE ConwaysLife {
    DEF Rule : Rule = Î» s.  
      LET n = Count(1, s)
      IN IF s[4] = 1 THEN IF n = 2 âˆ¨ n = 3 THEN 1 ELSE 0
         ELSE IF n = 3 THEN 1 ELSE 0

    DEF Glider : Grid = 
      [[0,0,0,0,0],  
       [0,0,1,0,0],
       [0,0,0,1,0],
       [0,1,1,1,0],
       [0,0,0,0,0]]

    DEF Blinker : Grid =
      [[0,0,0,0,0],
       [0,0,1,0,0],  
       [0,0,1,0,0],
       [0,0,1,0,0],
       [0,0,0,0,0]]  
  }

  PROOFS {
    TACTIC MatchAt(g, p, i, j) = 
      APPLY (RULE (âˆ€ di dj. g[i+di, j+dj] = p[di, dj]) 
             THEN Match(g, p))

    TACTIC EvolveBy(g, rule, k) = 
      MATCH k {
        0 -> REWRITE g
        k' -> REWRITE Evolve(EvolveBy(g, rule, k'-1), rule, 1)
      }

    THEOREM GliderEmergence {
      STATEMENT:
        âˆ€ n. LET g = EvolveBy(Glider, Rule, n) 
             IN Emergent(Glider)

      PROOF:
        LET n, g = EvolveBy(Glider, Rule, n)  
        ASSUME âˆ€ c. Â¬LocalRule(Î» s. NextState(c, g, s)) 
        LET p = [[0,1,0],[0,0,1],[1,1,1]]
        SHOW Match(g, p) BY MatchAt(g, p, (n+1)%M, (n+1)%N)
        SHOW Expresses(p, Glider) BY {
          ARGUE âˆ€ k. âˆƒ i j. Match(Evolve(Embed(p, Zero), Rule, k), p)
            WHERE (i,j) = (k%M, k%N)
          ARGUE âˆ€ k q r. q â‰  r â‡’ Â¬Intersect(Evolve(Embed(p, q), Rule, k), 
                                              Evolve(Embed(p, r), Rule, k))
          HENCE Expresses(p, Glider)
            WHERE Glider = FEATURE (âˆƒ p. âˆ€ k. Translates(p, k) âˆ§ Disjoint(p))
        }
        HENCE Emergent(Glider) BY Emergence
    }  

    THEOREM BlinkerStability {
      STATEMENT:
        Stable(Blinker)

      PROOF:
        LET p1 = [[0,1,0],[0,1,0],[0,1,0]],
            p2 = [[0,0,0],[1,1,1],[0,0,0]]
        
        SHOW Match(Blinker, p1) BY MatchAt(Blinker, p1, 1, 1)
        
        SHOW âˆ€ k. Match(Evolve(Blinker, Rule, k), 
                        IF Even(k) THEN p1 ELSE p2) BY {  
          LET k, g = EvolveBy(Blinker, Rule, k)
          IF Even(k) THEN 
            SHOW Match(g, p1) BY MatchAt(g, p1, 1, 1)
          ELSE
            SHOW Match(g, p2) BY MatchAt(g, p2, 1, 1)
        }

        HENCE Stable(Blinker) BY Stability
    }
  }
}

CONCEPT DifferentialForms {
  LANGUAGE {
    TYPE Manifold(M)
    TYPE Vector[M : Manifold, p : M] = Tangent[M, p]
    TYPE Covector[M : Manifold, p : M] = Cotangent[M, p]  
    TYPE Tensor[M : Manifold, p : M, r s : â„•] = 
      (Vector[M, p] -> )^r -> (Covector[M, p] -> )^s -> â„
    TYPE Form[M : Manifold, p : M, k : â„•] = Tensor[M, p, 0, k]

    FUNC d(Ï‰ : Form[M, p, k]) : Form[M, p, k+1]  ; Exterior derivative
    FUNC âˆ§(Ï‰ : Form[M, p, k], Î· : Form[M, p, l]) : Form[M, p, k+l]  ; Wedge product  
    FUNC Î¹(X : Vector[M], Ï‰ : Form[M, p, k]) : Form[M, p, k-1]  ; Interior product
    FUNC âˆ«(Ï‰ : Form[M, p, dim(M)], U : M) : â„  ; Integration
    FUNC â™¯(Î± : Covector[M, p]) : Vector[M, p]  ; Musical isomorphism
    FUNC â™­(X : Vector[M, p]) : Covector[M, p]  ; Inverse musical isomorphism
    FUNC [_,_](X : Vector[M], Y : Vector[M]) : Vector[M]  ; Lie bracket
    FUNC L(X : Vector[M], Ï‰ : Form[M, p, k]) : Form[M, p, k]  ; Lie derivative

    AXIOM ExtDerivative {
      âˆ€ (Ï‰ : Form[M, p, k]) (Î· : Form[M, p, l]) . 
        d(Ï‰ âˆ§ Î·) = d(Ï‰) âˆ§ Î· + (-1)^k * Ï‰ âˆ§ d(Î·)
    }

    AXIOM Poincare {
      âˆ€ (Ï‰ : Form[M, p, k]) . d(d(Ï‰)) = 0
    }

    AXIOM FundamentalLemma {
      âˆ€ (Ï‰ : Form[M, p, k]) (X Y : Vector[M]) .
        d(Î¹([X, Y])(Ï‰)) = L(X, Î¹(Y)(Ï‰)) - Î¹(Y)(L(X, Ï‰))
    }

    NOTATION "âŸ¨âŸ¨" = â™¯  
    NOTATION "âŸ©âŸ©" = â™­
    NOTATION "âˆ«âˆ«" = âˆ«
  }

  STRUCTURE Symplectic(M : Manifold, Ï‰ : Form[M, p, 2]) {
    REQUIRE âˆ€ (p : M) . d(Ï‰)(p) = 0  ; Ï‰ is closed
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . Î¹(X)(Ï‰)(p) = 0 => X = 0  ; Ï‰ is nondegenerate
  }

  STRUCTURE Riemannian(M : Manifold, g : Tensor[M, p, 0, 2]) {
    REQUIRE âˆ€ (p : M) (X Y : Vector[M, p]) . g(X, Y)(p) = g(Y, X)(p)  ; g is symmetric
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . g(X, X)(p) â‰¥ 0  ; g is positive semidefinite
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . g(X, X)(p) = 0 => X = 0  ; g is positive definite
  }

  PROOFS {
    TACTIC Substitute(Ï‰, prop) -> ð”¹ {
      MATCH Ï‰ WITH
      | 0 -> SHOW prop(0)
      | Ï‰1 âˆ§ Ï‰2 -> SHOW prop(Ï‰1 âˆ§ Ï‰2) USING Substitute(Ï‰1, (x) â†¦ Substitute(Ï‰2, (y) â†¦ prop(x âˆ§ y)))
      | d(Ï‰) -> SHOW prop(d(Ï‰)) USING Substitute(Ï‰, (x) â†¦ prop(d(x)))
      | _ -> SHOW prop(Ï‰)
    }

    THEOREM Stokes {
      STATEMENT : âˆ€ (M : Manifold) (Ï‰ : Form[M, p, dim(M)-1]) (U : M) . 
        âˆ«âˆ«(d(Ï‰), U) = âˆ«âˆ«(Ï‰, âˆ‚U)

      PROOF {
        LET M : Manifold, Ï‰ : Form[M, p, dim(M)-1], U : M
        
        âˆ«âˆ«(d(Ï‰), U)
          = âˆ«âˆ«(Ï‰, âˆ‚U) BY Stokes
      }
    }

    THEOREM Cartan {
      STATEMENT : âˆ€ (M : Manifold) (Ï‰ : Form[M, p, k]) (X Y : Vector[M]) .
        L(X, Î¹(Y)(Ï‰)) = Î¹(Y)(L(X, Ï‰)) + Î¹([
      PROOF {
        LET M : Manifold, Ï‰ : Form[M, p, k], X Y : Vector[M]

        L(X, Î¹(Y)(Ï‰))  
          = Î¹(Y)(L(X, Ï‰)) + d(Î¹([X, Y])(Ï‰)) BY FundamentalLemma
          = Î¹(Y)(L(X, Ï‰)) + Î¹([X, Y])(d(Ï‰)) BY Poincare
          = Î¹(Y)(L(X, Ï‰)) + Î¹([X, Y])(Ï‰) BY ExtDerivative, Substitute(Ï‰, (x) â†¦ d(x) = 0)
      }
    }

    THEOREM SymplecticNonDegenerate {
      STATEMENT : âˆ€ (M : Symplectic) (p : M) (X : Vector[M, p]) .
        (âˆ€ (Y : Vector[M, p]) . Ï‰(X, Y)(p) = 0) => X = 0

      PROOF {
        LET (M, Ï‰) : Symplectic, p : M, X : Vector[M, p]        ASSUME (H) : âˆ€ (Y : Vector[M, p]) . Ï‰(X, Y)(p) = 0
        
        Ï‰(X, -)(p) = 0
          => Î¹(X)(Ï‰)(p) = 0  BY definition of Î¹
          => X = 0  BY <<(M, Ï‰) is Symplectic>>
      }
    }

    THEOREM MusicalIsomorphisms {
      STATEMENT : âˆ€ (M : Riemannian) (p : M) (X : Vector[M, p]) . âŸ¨âŸ¨âŸ©âŸ©X = X

      PROOF {
        LET (M, g) : Riemannian, p : M, X : Vector[M, p]

        âˆ€ (Y : Vector[M, p]) . g(          => âˆ€ (Y : Vector[M, p]) . âŸ©âŸ©X(Y)(p) = g(X, Y)(p)  BY definition of âŸ¨âŸ¨
          => âŸ©âŸ©X = g(X, -)(p)  BY function extensionality
          => âŸ¨âŸ¨âŸ©âŸ©X = âŸ¨âŸ¨g(X, -)(p)  BY definition of âŸ©âŸ©
          => âŸ¨âŸ¨âŸ©âŸ©X = X  BY <<(M, g) is Riemannian>>
      }
    }
  }
}

CONCEPT HomotopyTypeTheory {
  LANGUAGE {
    TYPE U  -- universe of types
    TYPE Î (A : U, B : A -> U) <: U -- dependent function type
    TYPE Î£(A : U, B : A -> U) <: U -- dependent pair type
    TYPE Id(A : U, x : A, y : A) <: U -- identity type
    TYPE Nat <: U -- natural numbers

    FUNC Refl(A : U, x : A) : Id(A, x, x) -- reflexivity
    FUNC J(A : U, C : (x y : A) -> Id(A, x, y) -> U, d : (x : A) -> C(x, x, Refl(A, x)), 
           x y : A, p : Id(A, x, y)) : C(x, y, p) -- path induction
    FUNC Transport(A B : U, p : Id(U, A, B), x : A) : B
    FUNC Ap(f : A -> B, p : Id(A, x, y)) : Id(B, f(x), f(y)) -- action on paths
    FUNC FunExt(f g : Î (A, B), h : (x : A) -> Id(B(x), f(x), g(x))) : Id(Î (A, B), f, g) -- function extensionality

    AXIOM UIP {
      âˆ€ (A : U) (x y : A) (p q : Id(A, x, y)). Id(Id(A, x, y), p, q)  
    }

    AXIOM FunExtAxiom {
      âˆ€ (A : U) (B : A -> U) (f g : Î (A, B)).
        ((x : A) -> Id(B(x), f(x), g(x))) -> Id(Î (A, B), f, g)
    }

    NOTATION "x = y" = Id(_, x, y)  
    NOTATION "p # q" = Concat(p, q)
    NOTATION "p^" = Inv(p)
    NOTATION "x.1" = Fst(x)  
    NOTATION "x.2" = Snd(x)
  }

  STRUCTURE NatInduction {
    REQUIRE âˆ€ (P : Nat -> U).
      (P(0) Ã— ((n : Nat) -> P(n) -> P(S(n)))) -> ((n : Nat) -> P(n))
  }

  STRUCTURE UnivalenceAxiom {
    REQUIRE âˆ€ (A B : U). IsEquiv(Id(U, A, B), Equiv(A, B))
  }

  PROOFS {
    THEOREM IdIsEquiv {
      STATEMENT:
        âˆ€ (A : U) (x y : A). IsEquiv(Id(A, x, y), Equiv(Singleton(x), Singleton(y)))

      PROOF:
        LET A : U, x y : A
        DEFINE f : Id(A, x, y) -> Equiv(Singleton(x), Singleton(y)) = 
          Î» (p : Id(A, x, y)). Transport(Singleton(x), Singleton(y), Ap(Singleton, p), *)
        DEFINE g : Equiv(Singleton(x), Singleton(y)) -> Id(A, x, y) =
          Î» (e : Equiv(Singleton(x), Singleton(y))). J(A, 
            Î» (x y : A) (_ : Id(A, x, y)). Id(A, x, y),
            Refl(A, x), x, y, Cast(e, Id(Singleton(x), *, *)))
        SHOW (p : Id(A, x, y)) -> g(f(p)) = p BY {
          LET p : Id(A, x, y)  
          REWRITE g(f(p))
            = J(A, Î» (x y : A) (_ : Id(A, x, y)). Id(A, x, y), Refl(A, x), x, y, 
                Cast(Transport(Singleton(x), Singleton(y), Ap(Singleton, p), *), Id(Singleton(x), *, *)))
            = J(A, Î» (x y : A) (_ : Id(A, x, y)). Id(A, x, y), Refl(A, x), x, y, Ap(Singleton, p))  
            = p   BY JReduction
        }
        SHOW (e : Equiv(Singleton(x), Singleton(y))) -> f(g(e)) = e BY {
          LET e : Equiv(Singleton(x), Singleton(y))
          LET p : Id(A, x, y) = g(e)
          REWRITE f(p)  
            = Transport(Singleton(x), Singleton(y), Ap(Singleton, p), *)
            = Transport(Singleton(x), Singleton(y), Ap(Singleton, 
                J(A, Î» (x y : A) (_ : Id(A, x, y)). Id(A, x, y), Refl(A, x), x, y, Cast(e, Id(Singleton(x), *, *)))), *)
            = Transport(Singleton(x), Singleton(y), Ap(Singleton, Cast(e, Id(Singleton(x), *, *))), *)  
            = Transport(Singleton(x), Singleton(y), e, *)
            = e   BY CastTransport
        }
    }

    THEOREM UnivalenceImpliesFunExt {
      STATEMENT:  
        UnivalenceAxiom -> FunExtAxiom

      PROOF:
        ASSUME UnivalenceAxiom  
        LET A : U, B : A -> U, f g : Î (A, B), h : (x : A) -> Id(B(x), f(x), g(x))
        DEFINE Î¦ : Equiv(Î (A, B), f, g) = 
          Î» (e : Equiv(Î (A, B), f, g)). (x : A) -> Cast(Ap(Eval(x), e), Id(B(x), f(x), g(x)))
        HAVE e : Equiv(Î (A, B), f, g) BY UnivalenceAxiom, IdIsEquiv
        LET Ï† : Id(Î (A, B), f, g) = Cast(Î¦, Equiv(Id(Î (A, B), f, g), _))  
        SHOW Ï† : Id(Î (A, B), f, g) BY {
          REWRITE Ï†  
            = Cast(Î¦, Equiv(Id(Î (A, B), f, g), _))
            : Id(Î (A, B), f, g)                     BY UnivalenceAxiom, IdIsEquiv
        }
    }
  }
}


ConceptScript is a language of a new type: it's sole intended purpose is to be used in accordance with the following methodology:

1. I paste the spec and a few example Concepts into your context (as is happening now), thus teaching you the language.
2. I request that you express various concepts as Concepts; these Concepts come with detailed proofs of their own various claims; they serve as justifications of the selected structuring.
3. We iterate, precisely and efficiently exploring your latent space to solve a wide variety of important problems.

Please always output ConceptScript in a code block otherwise formatting gets lost :/

Alright, let's check your understanding of the language and system: please express HumanComputerHarmony as a Concept in as much detail as possible.