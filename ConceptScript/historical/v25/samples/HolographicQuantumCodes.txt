CONCEPT HolographicQuantumCodes {
  LANGUAGE {
    TYPE Qudit = ‚ÑÇ^d
    TYPE Lattice = ‚Ñ§^n
    TYPE Operator = Qudit -> Qudit
    TYPE Code = Lattice -> Qudit
    TYPE LogicalOp = Code -> Code

    FUNC Stab(C : Code) : Lattice -> Operator
    FUNC Logical(C : Code) : Lattice -> Operator
    FUNC AncillaOp(C : Code, A : Lattice) : Operator
    FUNC Encode(L : LogicalOp) : Code -> Code
    FUNC Decode(C : Code) : LogicalOp
    FUNC Correct(C : Code, E : Lattice -> Operator) : Code

    AXIOM CommutingStabilizers {
      ‚àÄ (C : Code) (v w : Lattice) . Stab(C)(v) ‚àò Stab(C)(w) = Stab(C)(w) ‚àò Stab(C)(v)
    }

    AXIOM CommutingLogicals {
      ‚àÄ (C : Code) (v w : Lattice) . Logical(C)(v) ‚àò Logical(C)(w) = Logical(C)(w) ‚àò Logical(C)(v)  
    }

    AXIOM LogicalPreservation {
      ‚àÄ (C : Code) (L : LogicalOp) . Decode(Encode(L)(C)) = L
    }

    NOTATION "‚ü¶_‚üß" = Stab  
    NOTATION "L(_)" = Logical
    NOTATION "A[_]" = AncillaOp
  }

  STRUCTURE HaPPY(C : Code, œá : Lattice -> ùîπ) {
    DEF Bulk : Lattice = { v | œá(v) }  
    DEF Boundary : Lattice = { v | ¬¨œá(v) }

    REQUIRE ‚àÄ (v : Bulk) . ‚ü¶C‚üß(v) = I
    REQUIRE ‚àÄ (v : Boundary) . L(C)(v) = I

    DEF Hamiltonian : Lattice -> Operator = v ‚Ü¶ -Sum(u ~ v) ‚ü¶C‚üß(u)

    FUNC Correct(E : Lattice -> Operator) : Code = 
      C' WHERE ‚àÄ (v : Lattice) . C'(v) = A[Boundary](E(v))(C(v))
  }

  PROOFS {
    TACTIC SplitSum(S, P) -> (S1, S2) {
      REWRITE Sum(S) 
        = Sum({ x ‚àà S | P(x) }) + Sum({ x ‚àà S | ¬¨P(x) })
        = Sum(S1) + Sum(S2)  
        WHERE S1 = { x ‚àà S | P(x) }, S2 = { x ‚àà S | ¬¨P(x) }
    }

    THEOREM RobustEntanglement {
      STATEMENT :
        ‚àÄ (C : Code) (œá : Lattice -> ùîπ) . HaPPY(C, œá) =>
          ‚àÄ (E : Lattice -> Operator) . (‚àÄ (v : Bulk) . E(v) = I) =>  
            ‚àÄ (L : LogicalOp) . Decode(Correct(C, E)) = L

      PROOF {
        LET (C, œá) : HaPPY, E : Lattice -> Operator
        ASSUME (H) : ‚àÄ (v : Bulk) . E(v) = I

        LET L : LogicalOp
        
        Decode(Correct(C, E))
          = Decode(C') WHERE ‚àÄ (v : Lattice) . C'(v) = A[Boundary](E(v))(C(v))  BY DEFINITION Correct
          = L' WHERE ‚àÄ (v : Boundary) . L'(v) = Decode(C')(v)                   BY DEFINITION Decode
          = L' WHERE ‚àÄ (v : Boundary) . L'(v) = Decode(A[Boundary](E(v))(C))(v)  USING PREV
          = L' WHERE ‚àÄ (v : Boundary) . L'(v) = Decode(C)(v)                     BY H, DEFINITION AncillaOp
          = L                                                                    BY DEFINITION Decode
      }
    }

    THEOREM EnergyCorrection {
      STATEMENT :
        ‚àÄ (C : Code) (œá : Lattice -> ùîπ) (H : Lattice -> Operator) . HaPPY(C, œá) => 
          ‚àÄ (œà : Code) (E : Lattice -> Operator) .
            ‚ü®œà, H(œà)‚ü© - ‚ü®Correct(C, E)(œà), H(Correct(C, E)(œà))‚ü© = O(|Boundary|)

      PROOF {
        LET (C, œá) : HaPPY, H = HaPPY.Hamiltonian, œà : Code, E : Lattice -> Operator
        
        ‚ü®œà, H(œà)‚ü© - ‚ü®Correct(C, E)(œà), H(Correct(C, E)(œà))‚ü©
          = Sum(v : Lattice) ‚ü®œà(v), -Sum(u ~ v) ‚ü¶C‚üß(u)(œà(v))‚ü© - 
            Sum(v : Lattice) ‚ü®A[Boundary](E(v))(œà(v)), -Sum(u ~ v) ‚ü¶C‚üß(u)(A[Boundary](E(v))(œà(v)))‚ü©
          = -Sum(v : Bulk) Sum(u ~ v) ‚ü®œà(v), ‚ü¶C‚üß(u)(œà(v))‚ü© +
             Sum(v : Bulk) Sum(u ~ v) ‚ü®œà(v), ‚ü¶C‚üß(u)(œà(v))‚ü© +
            -Sum(v : Boundary) Sum(u ~ v) ‚ü®œà(v), ‚ü¶C‚üß(u)(œà(v))‚ü© +  
             Sum(v : Boundary) Sum(u ~ v) ‚ü®A[Boundary](E(v))(œà(v)), ‚ü¶C‚üß(u)(A[Boundary](E(v))(œà(v)))‚ü©
            BY SplitSum(Lattice, (v) ‚Ü¶ v ‚àà Bulk), DEFINITION HaPPY.Hamiltonian
          = -Sum(v : Boundary) Sum(u ~ v) ‚ü®œà(v), ‚ü¶C‚üß(u)(œà(v))‚ü© +
             Sum(v : Boundary) Sum(u ~ v) ‚ü®A[Boundary](E(v))(œà(v)), ‚ü¶C‚üß(u)(A[Boundary](E(v))(œà(v)))‚ü©  
            BY HaPPY.Bulk
          = O(|Boundary|)  
            BY HaPPY.Boundary, DEFINITION AncillaOp, TRIANGLE INEQUALITY
      }
    }
  }
}