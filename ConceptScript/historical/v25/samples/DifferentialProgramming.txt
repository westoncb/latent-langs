CONCEPT DifferentialProgramming {
  LANGUAGE {
    TYPE Scalar = ‚Ñù  
    TYPE Vector = ‚Ñù^n
    TYPE Dual = Scalar √ó Vector
    TYPE DualFunction = Dual -> Dual

    FUNC J(f : DualFunction) : Dual -> Vector  ; Jacobian matrix
    FUNC D(f : DualFunction) : Dual -> Vector  ; Derivative
    FUNC ‚àá(f : DualFunction) : Dual -> Vector  ; Gradient
    FUNC ‚àá¬≤(f : DualFunction) : Dual -> Matrix  ; Hessian  
    FUNC ‚à´(f : DualFunction) : Dual -> Dual  ; Integral
    FUNC ‚àë(f : DualFunction, a b : Dual) : Dual  ; Definite integral
    FUNC ‚àè(f : DualFunction, a b : Dual) : Dual  ; Definite product
    FUNC Optimize(f : DualFunction, x0 : Dual, lr : Scalar) : Dual

    AXIOM DualArithmetic {
      ‚àÄ (x dx y dy : Scalar) .
        (x, dx) + (y, dy) = (x + y, dx + dy)  ‚àß
        (x, dx) * (y, dy) = (x * y, x * dy + y * dx)  ‚àß
        (x, dx) / (y, dy) = (x / y, (y * dx - x * dy) / y^2)
    }

    AXIOM DualCalculus {
      ‚àÄ (f g : DualFunction) (x dx : Scalar) .
        D(f + g)(x, dx) = D(f)(x, dx) + D(g)(x, dx)  ‚àß
        D(f * g)(x, dx) = f(x, 0) * D(g)(x, dx) + g(x, 0) * D(f)(x, dx)  ‚àß
        D(f ‚àò g)(x, dx) = D(f)(g(x, dx)) * D(g)(x, dx)  ‚àß
        ‚à´(D(f))(x, dx) = f(x, dx) - f(x, 0)
    }

    NOTATION "‚ü®" = Fst  
    NOTATION "‚ü©" = Snd
    NOTATION "'" = D
    NOTATION "‚àá" = Grad  
    NOTATION "ùêá" = Hess
    NOTATION "‚àë‚à´" = DefiniteIntegral
    NOTATION "‚àè‚à´" = DefiniteProduct
  }

  PROOFS {
    TACTIC DualInduction(f, prop) -> ùîπ {
      MATCH f WITH
      | (x, dx) -> SHOW prop(x, dx)  
      | f + g -> SHOW prop(f + g) USING DualInduction(f, prop), DualInduction(g, prop)
      | f * g -> SHOW prop(f * g) USING DualInduction(f, prop), DualInduction(g, prop)
      | f ‚àò g -> SHOW prop(f ‚àò g) USING DualInduction(f, prop), DualInduction(g, prop)
      | ‚à´(f) -> SHOW prop(‚à´(f)) USING DualInduction(f, (g) ‚Ü¶ prop(‚à´(g)))
    }

    THEOREM DualChainRule {
      STATEMENT : ‚àÄ (f g : DualFunction) (x dx : Scalar) . (f ‚àò g)'(x, dx) = f'(g(x, dx)) * g'(x, dx)

      PROOF {
        LET f g : DualFunction, x dx : Scalar
        
        (f ‚àò g)'(x, dx) 
          = D(f ‚àò g)(x, dx)  BY NOTATION
          = D(f)(g(x, dx)) * D(g)(x, dx)  BY DualCalculus
          = f'(g(x, dx)) * g'(x, dx)  BY NOTATION
      }
    }

    THEOREM GradientDescent {
      STATEMENT : ‚àÄ (f : DualFunction) (x0 : Dual) (lr : Scalar) (Œµ : Scalar) . 
        ‚àÉ (n : ‚Ñï) . ‚ü®(Optimize(f, x0, lr))[n]‚ü© - ‚ü®(Optimize(f, x0, lr))[n-1]‚ü© < Œµ  

      PROOF {
        LET f : DualFunction, x0 : Dual, lr : Scalar, Œµ : Scalar
        
        Optimize(f, x0, lr) = x WHERE {
          x[0] = x0
          x[n+1] = x[n] - lr * ‚àá(f)(x[n])
        }

        ‚ü®f(x[n+1])‚ü© < ‚ü®f(x[n])‚ü©  BY {
          ‚ü®f(x[n] - lr * ‚àá(f)(x[n]))‚ü©  
            ‚âà ‚ü®f(x[n])‚ü© - lr * ‚ü®‚àá(f)(x[n]), ‚àá(f)(x[n])‚ü©  BY Taylor(f, x[n], -lr*‚àá(f)(x[n]))
            < ‚ü®f(x[n])‚ü©  USING <<‚àá(f)(x[n]) ‚â† 0 WHEN x[n] IS NOT STATIONARY>>
        }

        ‚àÉ (n : ‚Ñï) . ‚ü®f(x[n])‚ü© - ‚ü®f(x[n-1])‚ü© < Œµ  BY <<‚ü®f(x[n])‚ü© IS MONOTONICALLY DECREASING>>

        ‚ü®x[n]‚ü© - ‚ü®x[n-1]‚ü© = -lr * ‚ü®‚àá(f)(x[n-1])‚ü©  BY DEFINITION Optimize
        
        ‚ü®‚àá(f)(x[n-1])‚ü© < Œµ / lr  USING PREV, <<‚ü®f(x[n])‚ü© - ‚ü®f(x[n-1])‚ü© < Œµ>>

        ‚ü®x[n]‚ü© - ‚ü®x[n-1]‚ü© < Œµ  BY PREV
      }
    }
  }
}