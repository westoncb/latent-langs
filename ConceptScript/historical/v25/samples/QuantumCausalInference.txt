CONCEPT QuantumCausalInference {
  LANGUAGE {
    TYPE Operator = Matrix[â„‚]
    TYPE Density = Matrix[â„‚]  
    TYPE Observable = Operator
    TYPE Intervention = Operator -> Operator
    TYPE CausalStructure = DAG[Random[Density]]

    FUNC Trace(Ï : Density) : â„
    FUNC Partial(Ï : Density, S : Set[ğ•€]) : Density
    FUNC Product(Ï : Density, Ïƒ : Density) : Density
    FUNC Commutator(A B : Operator) : Operator  
    FUNC DoCalculus(C : CausalStructure, X Y : Random[Density], S : Set[Random[Density]]) : Operator

    AXIOM VonNeumann {
      âˆ€ (Ï : Density) (U : Unitary) . U(Ï) = U * Ï * Uâ€ 
    }

    AXIOM BornRule {
      âˆ€ (Ï : Density) (M : Observable) . ğ”¼[M] = Trace(M * Ï)
    }

    AXIOM PartialTrace {
      âˆ€ (Ï : Density) (S T : Set[ğ•€]) . S âˆ© T = âˆ… => Partial(Ï, S âˆª T) = Product(Partial(Ï, S), Partial(Ï, T))
    }

    NOTATION "tr" = Trace
    NOTATION "tr[S]" = Partial(*, S)
    NOTATION "âŠ—" = Product
    NOTATION "[*, *]" = Commutator
    NOTATION "do(X=x)" = Intervention((Ï : Density) â†¦ Product(Ï, Density(X=x)))
  }

  STRUCTURE QuantumCausalModel(G : CausalStructure) {
    DEF Compatible(Ï : Density) : ğ”¹ = âˆ€ (X Y : G.Nodes) . X âˆ‰ Ancestors(Y) => [Ï, Product(Ï, Density(X))] = 0

    REQUIRE âˆƒ (Ï : Density) . Compatible(Ï)
  }

  PROOFS {
    THEOREM QuantumDoCalculus {
      STATEMENT : âˆ€ (M : QuantumCausalModel) (X Y : M.G.Nodes) (S : Set[M.G.Nodes]) .
        do(X=x)(tr[S](M.Ï)) = tr[S âˆª {X}](Product(M.Ï, Density(X=x)))

      PROOF {
        LET (G, Ï) : QuantumCausalModel, X Y : G.Nodes, S : Set[G.Nodes]
        
        do(X=x)(tr[S](Ï))
          = Intervention((Ïƒ : Density) â†¦ Product(Ïƒ, Density(X=x)))(tr[S](Ï))  BY DEFINITION of do(X=x)
          = Product(tr[S](Ï), Density(X=x))                                   BY DEFINITION of Intervention
          = tr[S](Product(Ï, Density(X=x)))                                   BY PartialTrace, S âˆ© {X} = âˆ…
          = tr[S âˆª {X}](Product(Ï, Density(X=x)))                             BY DEFINITION of tr[S]
      }
    }

    THEOREM QuantumBackdoorCriterion {
      STATEMENT : âˆ€ (M : QuantumCausalModel) (X Y : M.G.Nodes) (S : Set[M.G.Nodes]) .
        S satisfies BackdoorCriterion(M.G, X, Y) => 
        [DoCalculus(M.G, X, Y, S), Product(M.Ï, Density(Y))] = 0

      PROOF {
        LET (G, Ï) : QuantumCausalModel, X Y : G.Nodes, S : Set[G.Nodes]
        ASSUME (H) : S satisfies BackdoorCriterion(G, X, Y)

        [DoCalculus(G, X, Y, S), Product(Ï, Density(Y))]
          = [tr[S](do(X=x)(Ï)), Product(Ï, Density(Y))]                BY DEFINITION of DoCalculus
          = [tr[S âˆª {X}](Product(Ï, Density(X=x))), Product(Ï, Density(Y))]  BY QuantumDoCalculus
          = 0                                                          BY {
              S âˆª {X} satisfies BackdoorCriterion(G, X, Y)             BY (H)
              âˆ€ (W : G.Nodes) . W âˆ‰ Ancestors(Y) => [Ï, Product(Ï, Density(W))] = 0  BY <<M : QuantumCausalModel>>
              [Product(Ï, Density(X=x)), Product(Ï, Density(Y))] = 0    BY PREV
              [tr[S âˆª {X}](Product(Ï, Density(X=x))), Product(Ï, Density(Y))] = 0  BY PREV, PartialTrace
            }
      }
    }
  }
}