CONCEPT EvolvingCategories {
  LANGUAGE {
    TYPE DynCategory {
      C : Category
      R : âˆ€(A B : C.Obj). C(A, B) -> C(A, B)
    }

    FUNC Evolve(D : DynCategory, n : Nat) : Category
    FUNC LimitCategory(D : DynCategory) : Category

    FUNC EvolvingFunctor[D E : DynCategory] {
      F : Functor[D.C, E.C]
      Commutes : âˆ€(A B : D.C.Obj). F.ArrowMap âˆ˜ D.R = E.R âˆ˜ F.ArrowMap  
    } 

    FUNC ColimitCategory(J : DynCategory -> Category) : Category

    TYPE Topos {
      C : Category
      Î© : C.Obj
      âˆ€(A : C.Obj). Power(A) : C.Obj
      âˆ€(A B : C.Obj). Exp(A, B) : C.Obj
    }

    FUNC Tripos(T : Topos) : Topos
    FUNC EvolvingTopos(T : Topos, L : Language) : DynCategory
    
    AXIOM Colimits {
      âˆ€(J : DynCategory -> Category). 
        âˆƒ!(C : Category) (F : Functor[ColimitCategory(J), C]).
          Univ((D : DynCategory) â†¦ âˆƒ!(G : Functor[J(D), C]). F âˆ˜ InJ(D) = G)  
    }

    AXIOM LimitAgreement {
      âˆ€(D : DynCategory). LimitCategory(D) = ColimitCategory((n : Nat) â†¦ Evolve(D, n))
    }
  }

  PROOFS {
    TACTIC DynUnfold(D : DynCategory, n : Nat, X : Evolve(D,n).Obj) = 
      MATCH n WITH
      | 0 => X
      | k+1 => DynUnfold(D, k, R(X))

    TACTIC Grothendieck(J : DynCategory -> Category, F : Functor[ColimitCategory(J), C]) = {
      LET Î”C : DynCategory = {
        C = C
        R = Î»(A B : C.Obj). Î»(f : C(A, B)). ğŸ™_B
      }

      DEFINE Îµ_C : Nat(F âˆ˜ InJ(Î”C), ğŸ™_C) = 
        Î»(X : C.Obj). ğŸ™_X

      SHOW Univ((D : DynCategory) (G : Functor[J(D), C]) â†¦ 
        âˆƒ!(Î± : Nat(G, F âˆ˜ InJ(D))). Îµ_C âˆ˜ Î± = ğŸ™_G)
    }

    THEOREM EvolutionaryLogic {
      STATEMENT:
        âˆ€(T : Topos) (L : Language) (Ï† : Formula[L]). 
          (âŠ¢_L Ï†) <=> (âŠ¢_{Tripos(EvolvingTopos(T, L))} Ï†)
      
      PROOF {
        LET T : Topos, L : Language, Ï† : Formula[L]
        
        âŠ¢_L Ï†
          <=> âˆƒ(n : Nat). âŠ¢_{Evolve(EvolvingTopos(T, L), n)} Ï†   BY LimitAgreement
          <=> âˆƒ(n : Nat). âŠ¢_{Evolve(Tripos(EvolvingTopos(T, L)), n)} Ï†   BY naturality of Tripos
          <=> âŠ¢_{ColimitCategory((n : Nat) â†¦ Evolve(Tripos(EvolvingTopos(T, L)), n))} Ï†   BY Colimits  
          <=> âŠ¢_{Tripos(EvolvingTopos(T, L))} Ï†   BY LimitAgreement
      }
    }
  }
}