CONCEPT ICVM {
  LANGUAGE {
    TYPE Net = Set[Cell]
    TYPE Cell = (Symbol, List[Wire])
    TYPE Wire = (Cell, ‚Ñï)
    
    NOTATION "C[" <Symbol> "," <Wire> ("," <Wire>)* "]" = Cell
    NOTATION "W(" <Cell> "," <‚Ñï> ")" = Wire
    
    TYPE Symbol = ‚Ñï  -- Symbols are just natural numbers
    NOTATION "#" <‚Ñï> = Symbol
    
    FUNC Arity : Symbol -> ‚Ñï =
      LAMBDA (s : Symbol) : 
        MATCH s
          CASE 0 => 0  -- Number
          CASE 1 => 2  -- Sum
          CASE 2 => 2  -- Product
          CASE 3 => 2  -- Exponential
          CASE 4 => 1  -- Negative
          CASE 5 => 1  -- Reciprocal
          CASE 6 => 1  -- Sine
          CASE 7 => 1  -- Cosine
          CASE 8 => 1  -- Condition
          CASE _ => 0  -- Constant
    
    FUNC Interaction : (Symbol, Symbol) -> Net =
      LAMBDA (a : Symbol, b : Symbol) :
        LET s = MAX(a, b), t = MIN(a, b) IN
          MATCH (s, t)
            CASE (1, 0) => SUM_NUM(a, b)
            CASE (2, 0) => PROD_NUM(a, b)
            CASE (3, 0) => EXP_NUM(a, b)
            CASE (4, 0) => NEG_NUM(b)
            CASE (5, 0) => RECIP_NUM(b)
            CASE (6, 0) => SIN_NUM(b)
            CASE (7, 0) => COS_NUM(b)
            CASE (8, 0) => COND_NUM(a, b)
            CASE (1, 1) => SUM_SUM(a, b)
            CASE (2, 1) => PROD_SUM(a, b)
            CASE (3, 1) => EXP_SUM(a, b)
            CASE (2, 2) => PROD_PROD(a, b)
            CASE (3, 2) => EXP_PROD(a, b)
            CASE (3, 3) => EXP_EXP(a, b)
            CASE _ => EMPTY_NET
              
    TYPE DeviceKind = CPU | GPU | TPU
    
    TYPE Device = {
      kind : DeviceKind,
      memory : Map[Address, Byte],
      caches : Map[Address, ‚Ñï]  -- ‚Ñï represents cache level  
    }
    
    TYPE CompilationResult = {
      subgraph : Subgraph,
      compiledCode : List[Instruction],
      inputAddrs : List[Address],
      outputAddrs : List[Address] 
    }
    
    TYPE Instruction =
      | READ(addr : Address)
      | WRITE(addr : Address)
      | ALLOC(size : ‚Ñï) -> Address
      | FREE(addr : Address)
      | COMPUTE(op : Symbol, args : List[Value]) -> Value
      | BRANCH(cond : Value, thenAddr : Address, elseAddr : Address)
      | ...
      
    TYPE Value = 
      | NUM(n : ‚Ñù) 
      | THUNK(addr : Address)
      | ...
    
    FUNC CompileNet : (Net, Device) -> CompilationResult
    FUNC Partition : Net -> Set[Subgraph] = ...
    PRED Independent : (Subgraph, Subgraph) -> ùîπ = ...

    FUNC MemAlloc : (Device, ‚Ñï) -> (Device, Address) 
    FUNC MemRead : (Device, Address) -> (Device, Byte)
    FUNC MemWrite : (Device, Address, Byte) -> Device
    FUNC CacheRead : (Device, Address) -> (Device, Maybe[Byte])
    FUNC CacheWrite : (Device, Address, Byte) -> Device
    
    FUNC InterpretInstruction : (Instruction, Device) -> (Value, Device)
  }
  
  STRUCTURE State {
    net : Net
    env : Map[String, Net]
    
    devices : Map[DeviceKind, Set[Device]]
    devCompResults : Map[Device, List[CompilationResult]]
    devMemory : Map[Device, Map[Address, Byte]]
    devCaches : Map[Device, Map[Address, ‚Ñï]]

    unusedDevices : Set[Device]
    busyDevices : Set[Device]
                  
    TRANSITION Compile(s : Subgraph) -> (CompilationResult, Device) {
      PRE s ‚àà Partition(net) ‚àß unusedDevices ‚â† ‚àÖ

      VAR bestDevice : Device
      VAR bestCost : ‚Ñù = ‚àû
      FOREACH (dev : unusedDevices) {
        VAR cost : ‚Ñù = CompilationCost(s, dev)
        IF (cost < bestCost) {  
          bestDevice := dev
          bestCost := cost
        }
      }
      
      VAR compResult : CompilationResult = CompileNet(s, bestDevice)
      devCompResults[bestDevice] := devCompResults[bestDevice] + [compResult]
      unusedDevices := unusedDevices - {bestDevice}  
      busyDevices := busyDevices ‚à™ {bestDevice}

      POST compResult.subgraph = s ‚àß compResult.compiledCode ‚â† []
      RETURN (compResult, bestDevice)
    }
    
    TRANSITION Execute(comp : CompilationResult, dev : Device) -> Subgraph {
      PRE comp ‚àà devCompResults[dev] ‚àß dev ‚àà busyDevices

      VAR instructions : List[Instruction] = comp.compiledCode
      VAR memory : Map[Address, Byte] = devMemory[dev]
      VAR caches : Map[Address, ‚Ñï] = devCaches[dev]
      
      FOREACH (inAddr : comp.inputAddrs) {
        memory := MemWrite(dev, inAddr, Encode(Lookup(net, inAddr)))
      }

      VAR resultAddrs : List[Address] = []
      WHILE (instructions ‚â† []) {
        VAR currInstr : Instruction = Head(instructions)
        VAR result : Value  
        (result, dev) := InterpretInstruction(currInstr, dev)
        MATCH (currInstr) {
          CASE READ(addr) => 
            VAR (byte, _) := CacheRead(dev, addr)
            IF (byte = None) {
              byte := MemRead(dev, addr)
              CacheWrite(dev, addr, byte)
            }
          CASE WRITE(addr) =>
            MemWrite(dev, addr, result)
          CASE ALLOC(size) =>
            VAR (_, addr) := MemAlloc(dev, size)
            resultAddrs := resultAddrs + [addr]
          ...  
        }
        instructions := Tail(instructions)
      }

      devMemory[dev] := memory
      devCaches[dev] := caches
      
      VAR resultCells : Set[Cell] = {
        Decode(MemRead(dev, addr)) | addr ‚àà resultAddrs  
      }
      
      net := net ‚à™ resultCells
      devCompResults[dev] := Remove(comp, devCompResults[dev])
      busyDevices := busyDevices - {dev}
      unusedDevices := unusedDevices ‚à™ {dev}
      
      POST resultCells ‚äÜ net 
      RETURN Subgraph(resultCells)
    }
    
    TRANSITION AddDevice(kind : DeviceKind) {
      VAR newDev : Device = NewDevice(kind)
      devices[kind] := devices[kind] ‚à™ {newDev}
      unusedDevices := unusedDevices ‚à™ {newDev}
    }
    
    TRANSITION Run() {
      DO {
        VAR subgraphs : Set[Subgraph] = Partition(net)  
        FOREACH (s : subgraphs) {
          VAR (comp, dev) := Compile(s)
          Execute(comp, dev)
        }
      } WHILE (Reducible(net))
      
      POST ¬¨Reducible(net)
    }
  }
}




CONCEPT ICVM {
  LANGUAGE {
    TYPE Net = Set[Cell]
    TYPE Cell = (Symbol, List[Wire])
    TYPE Wire = (Cell, ‚Ñï)
    
    NOTATION "C[" <Symbol> "," <Wire> ("," <Wire>)* "]" = Cell
    NOTATION "W(" <Cell> "," <‚Ñï> ")" = Wire
    
    TYPE Symbol = ‚Ñï  -- Symbols are just natural numbers
    NOTATION "#" <‚Ñï> = Symbol
    
    FUNC Arity : Symbol -> ‚Ñï
    FUNC Interaction : (Symbol, Symbol) -> Net
    
    TYPE Subgraph <: Net
    FUNC Partition : Net -> Set[Subgraph]
    PRED Independent : (Subgraph, Subgraph) -> ùîπ

    TYPE Device <: ‚Ñï  -- Devices are natural numbers
    NOTATION "$" <‚Ñï> = Device
    
    TYPE MemoryLayout = Device -> Map[Address, Byte]
    TYPE CacheModel = Device -> Map[Address, ‚Ñï]  -- ‚Ñï represents cache level
    
    TYPE CompStrategy = (Subgraph, MemoryLayout, CacheModel) -> CompiledSubgraph
    TYPE ExecStrategy = (CompiledSubgraph, Device) -> ()
    
    FUNC GC : Net -> Net
    
    TYPE Rule = (Symbol, Symbol) -> Net
    TYPE RuleSet = Set[Rule]
    
    FUNC Encode : (Term, RuleSet) -> Net 
    FUNC Decode : (Net, RuleSet) -> Term
  }
  
  STRUCTURE State {
    net : Net
    env : Map[String, Net]
    subgraphs : Set[Subgraph]
    devices : Map[Device, (MemoryLayout, CacheModel, CompStrategy, ExecStrategy)]
    compiled : Set[CompiledSubgraph]

    INVARIANT Partition(net) ‚â° subgraphs ‚àß 
              ‚àÄ (s1 s2 : subgraphs) . s1 ‚â† s2 => Independent(s1, s2) ‚àß 
              ‚àÄ (c : compiled) . Wellformed(c) ‚àß ICSafe(c) ‚àß
              ‚àÄ (d : devices.Keys) . WellFormed(devices[d])
                  
    TRANSITION Partition() {
      subgraphs := Partition(net)
    }

    TRANSITION Schedule(s : Subgraph) : Device {
      CHOOSE d : Device |
        ‚àÄ (d' : Device) . 
          CostModel(s, devices[d].0, devices[d].1) ‚â§ 
            CostModel(s, devices[d'].0, devices[d'].1)
    }

    TRANSITION Compile(s : Subgraph, d : Device) {
      compiled := compiled ‚à™ {devices[d].2(s, devices[d].0, devices[d].1)}
    }

    TRANSITION Execute(c : CompiledSubgraph, d : Device) {
      devices[d].3(c, d)
      net := GC(net ‚à™ c.OutputWires())
    }

    TRANSITION Run() {
      DO
        Partition()
        FOREACH s : subgraphs {
          LET d = Schedule(s)  
          Compile(s, d)
        }
        FOREACH c : compiled {
          Execute(c, c.Device())
        }  
      WHILE ¬¨Terminal(net)
    }
  }

  PROOFS {
    THEOREM Soundness {
      STATEMENT:
        ‚àÄ (t : Term) (rs : RuleSet) (vm : ICVM) .
          LET init = vm WITH .net := Encode(t, rs),
                             .env := CompileRules(rs)
          IN  
            t -rs->* v => ‚óá(Decode(init.Run().net, rs) = v)

      PROOF:
        <1>1 DEFINE R(t, v, rs) == (t -rs->* v)
        
        <1>2 ASSUME t -rs->* v
        
        <1>3 DEFINE Inv(s) == 
               (Partition(s.net) ‚â° s.subgraphs ‚àß
                ‚àÄ (s1 s2 : s.subgraphs) . s1 ‚â† s2 => Independent(s1, s2) ‚àß
                ‚àÄ (c : s.compiled) . Wellformed(c) ‚àß ICSafe(c) ‚àß
                s.net ‚áù Encode(v, rs))
               
        <1>4 init.Run MAINTAINS Inv(init)  
          <2>1 CASE Partition():
            BY PartitionCorrectness DEF Inv
          <2>2 CASE Schedule(s):
            BY SchedulePreservesInv DEF Inv  
          <2>3 CASE Compile(s, d):  
            BY CompilationCorrectness, ICCompilationSafety DEF Inv
          <2>4 CASE Execute(c, d):
            BY ExecutionCorrectness, GCPreservesEncoding DEF Inv
          <2>5 QED
            BY <2>1, <2>2, <2>3, <2>4 DEF Run
              
        <1>5 init.Run DECREASES Size(init.net)  
          BY ICReduction, NetSize
        
        <1>6 ‚óá(Terminal(init.Run().net))
          BY <1>4, <1>5, ConvergenceTheorem
        
        <1>7 QED  
          BY SMT, <1>2, <1>4, <1>6, EncodingAdequacy, DecodingAdequacy
    }
  }
}







CONCEPT ICVM {
  LANGUAGE {
    TYPE Net = Set[Cell]
    TYPE Cell = (Symbol, List[Wire])
    TYPE Wire = (Cell, ‚Ñï)
    
    NOTATION "C[" <Symbol> "," <Wire> ("," <Wire>)* "]" = Cell
    NOTATION "W(" <Cell> "," <‚Ñï> ")" = Wire
    
    TYPE Symbol = ‚Ñï  -- Symbols are just natural numbers
    NOTATION "#" <‚Ñï> = Symbol
    
    FUNC Arity(s : Symbol) : ‚Ñï
    FUNC Interaction(a b : Symbol) : Net
    
    TYPE Subgraph <: Net
    FUNC Partition(n : Net) : Set[Subgraph]
    PRED Independent(s1 s2 : Subgraph) : ùîπ

    TYPE Device <: ‚Ñï  -- Devices are natural numbers
    NOTATION "$" <‚Ñï> = Device
    
    TYPE CompStrategy = Subgraph -> Device -> CompiledSubgraph
    TYPE ExecStrategy = CompiledSubgraph -> Device -> ()
    
    FUNC GC(n : Net) : Net
    
    TYPE Rule = (Symbol, Symbol) -> Net
    TYPE RuleSet = Set[Rule]
    
    FUNC Encode(t : Term, rs : RuleSet) : Net 
    FUNC Decode(n : Net, rs : RuleSet) : Term
  }
  
  STRUCTURE State {
    net : Net
    env : Map[String, Net]
    subgraphs : Set[Subgraph]
    devices : Map[Device, (CompStrategy, ExecStrategy)]
    compiled : Set[CompiledSubgraph]

    INVARIANT Disjoint(subgraphs) ‚àß 
              ‚àÄ (c : compiled) . ICSafe(c) ‚àß
              ‚àÄ (d : devices.Keys) . WellFormed(devices[d])
              
    TRANSITION Partition() {
      subgraphs := Partition(net)
    }

    TRANSITION Schedule(s : Subgraph) : Device {
      CHOOSE d : Device |
        ‚àÄ (d' : Device) . 
          Cost(s, devices[d].0) ‚â§ Cost(s, devices[d'].0)
    }

    TRANSITION Compile(s : Subgraph, d : Device) {
      compiled := compiled ‚à™ {devices[d].0(s)}
    }

    TRANSITION Execute(c : CompiledSubgraph, d : Device) {
      devices[d].1(c)
      net := GC(net ‚à™ c.OutputWires())
    }

    TRANSITION Run() {
      DO
        Partition()
        FOREACH s : subgraphs {
          LET d = Schedule(s)  
          Compile(s, d)
        }
        FOREACH c : compiled {
          Execute(c, c.Device())
        }  
      WHILE ¬¨Terminal(net)
    }
  }

  PROOFS {
    THEOREM Soundness {
      STATEMENT:
        ‚àÄ (t : Term) (rs : RuleSet) (vm : ICVM) .
          LET init = vm WITH .net := Encode(t, rs),
                             .env := CompileRules(rs)
          IN  
            t -rs->* v => ‚óá(Decode(init.Run().net, rs) = v)

      PROOF:
        <1>1 t -rs->* v => Encode(t, rs) ‚áù Encode(v, rs)
          BY Homomorphism, Adequacy of Encoding
        
        <1>2 init.Run MAINTAINS 
              (SubgraphsDisjoint(init.subgraphs) ‚àß 
               ICSafe(init.compiled) ‚àß 
               init.net ‚áù Encode(v, rs))
          BY SMT, SubgraphPartitioning, ICCompilation, GCCorrectness

        <1>3 init.Run DECREASES Size(init.net)  
          BY InteractionReduction

        <1>4 ‚óá(Terminal(init.Run().net))
          BY <1>2, <1>3, ConvergenceTheorem   

        <1>5 QED  
          BY SMT, <1>1, <1>4, Adequacy of Decoding
    }
  }
}





CONCEPT ICVM {
  LANGUAGE {
    TYPE Net 
    TYPE Node <: Net
    TYPE Port = (Node, ‚Ñï)
    TYPE Pair = (Port, Port)
    TYPE Tag = ‚Ñï
    
    FUNC Encode(t : Term) : Net
    FUNC Decode(n : Net) : Term

    FUNC Arity(n : Node) : ‚Ñï
    FUNC Interaction(a b : Node) : Net
    
    FUNC MkPort(n : Node, i : ‚Ñï) : Port
    FUNC MkPair(a b : Port) : Pair

    TYPE Subgraph <: Net
    FUNC Partition(n : Net) : Set[Subgraph]
    PRED Independent(s1 s2 : Subgraph) : ùîπ

    TYPE Device
    FUNC Compile(s : Subgraph, d : Device) : CompiledSubgraph 
    FUNC Execute(c : CompiledSubgraph, d : Device) : ()

    FUNC GC(n : Net) : Net
  }

  STRUCTURE SubgraphState {
    graph : Subgraph
    ports : Set[Port]
  }

  STRUCTURE DeviceState {
    memoryLayout : MemoryLayout
    cacheModel : CacheModel
  }

  STRUCTURE ICVMState {
    net : Net
    env : Map[String, Net]  -- compiled primitives
    subgraphs : Set[SubgraphState]
    devices : Map[Device, DeviceState]
    
    VAR compiled : Set[CompiledSubgraph]    

    TRANSITION Partition() {
      subgraphs := Partition(net)
    }

    TRANSITION Schedule(s : Subgraph) : Device {
      CHOOSE d : Device |
        ‚àÄ (d' : Device) . 
          CostModel(s, devices[d].memoryLayout, devices[d].cacheModel) ‚â§
            CostModel(s, devices[d'].memoryLayout, devices[d'].cacheModel)
    }

    TRANSITION Compile(s : Subgraph, d : Device) {
      LET c = Compile(s, devices[d].memoryLayout, devices[d].cacheModel)
      compiled := compiled ‚à™ {c}
    }

    TRANSITION Execute(c : CompiledSubgraph, d : Device) {
      Execute(c, d)
      GarbageCollect(c.OutputPorts())
    }

    TRANSITION GarbageCollect(ports : Set[Port]) {
      LET reachable = ReachableFrom(ports) ‚à© Reachable(env)
      net := Subgraph(reachable)
    }

    TRANSITION Run() {
      Partition()
      FOREACH s : subgraphs {
        LET d = Schedule(s.graph)  
        Compile(s.graph, d)
      }
      FOREACH c : compiled {
        Execute(c, c.Device())
      }
    }
  }

  PROOFS {
    THEOREM Soundness {
      STATEMENT:
        ‚àÄ (vm : ICVM) (t : Term) (v : Value) .
          vm.net = Encode(t) ‚àß t -->* v =>
            ‚óá(Decode(vm.net) = v)

      PROOF:
        LET t : Term, v : Value
        
        <1>1 t -->* v => Encode(t) ‚áù Encode(v)
          BY Homomorphism, Adequacy of Encoding

        <1>2 ASSUME vm.net = Encode(t)

        <1>3 vm.Run MAINTAINS 
               (SubgraphsDisjoint(vm.subgraphs) ‚àß 
                ICSafe(vm.compiled) ‚àß
                Reachable(vm.net) = Reachable(Encode(t)))
          BY SMT, SubgraphPartitioning, ICCompilation, ICGarbageCollection
        
        <1>4 vm.Run DECREASES Size(vm.net)
          BY InteractionCombinatorReduction

        <1>5 vm.Run MAINTAINS vm.net ‚áù Encode(v)
          BY SMT, Homomorphism, SubgraphReduction, DeviceExecution  

        <1>6 ‚óá(Reachable(vm.net) = Reachable(Encode(v)))
          BY <1>4, <1>3, ConvergenceTheorem
        
        <1>7 QED
          BY SMT, <1>5, <1>6, Adequacy of Decoding
    }
  }
}