CONCEPT FractalReinforcement {
  LANGUAGE {
    TYPE State = â„^n
    TYPE Action = â„^m 
    TYPE Reward = â„
    TYPE Policy = State -> Action
    TYPE Value = State -> â„
    TYPE Transition = State Ã— Action -> State
    TYPE Fractal = State -> â„

    FUNC Bellman(ğœ‹ : Policy, T : Transition, r : Reward, Î³ : â„) : Value
    FUNC Hausdorff(X : State -> â„, d : â„) : â„
    FUNC Mandelbrot(c : â„‚, n : â„•) : â„‚
    FUNC IFS(w : (State -> State)^k, p : â„^k) : State -> State

    AXIOM Contraction {
      âˆ€ (T : Transition) (ğœ‹ : Policy) (r : Reward) (Î³ : â„) (U V : Value) .
        |Bellman(ğœ‹, T, r, Î³)(U) - Bellman(ğœ‹, T, r, Î³)(V)| â‰¤ Î³ * max[s] |U(s) - V(s)|
    }

    AXIOM FractalDimension {
      âˆ€ (F : Fractal) . lim[d->0] log(Hausdorff(F, d)) / log(1/d) = Hausdorff(F)  
    }

    NOTATION "ğ”¹" = Bellman
    NOTATION "â„" = Hausdorff
    NOTATION "â„³" = Mandelbrot
  }

  STRUCTURE FractalMDP(T : Transition, r : Reward, Î³ : â„, F : Fractal) {
    DEF Optimal(U : Value) : Policy = (s : State) â†¦ argmax[a : Action] ğ”¼[T(s, a)] (r(s, a) + Î³ * U)

    DEF Iterate(U : Value) : Value = ğ”¹(Optimal(U), T, r, Î³)(U)

    REQUIRE âˆ€ (s : State) . F(s) = r(s, Optimal(Iterate^âˆ)(s))
  }

  PROOFS {
    THEOREM ValueFractal {
      STATEMENT : âˆ€ (M : FractalMDP) . â„(M.F) â‰¤ log(ğ”¼[sâ‚~M.T(sâ‚€, aâ‚€)] Î³ * |M.F(sâ‚) - M.F(sâ‚€)|) / log(1/Î³)

      PROOF {
        LET (T, r, Î³, F) : FractalMDP
        
        â„(F)
          = lim[d->0] log(â„(F, d)) / log(1/d)  BY FractalDimension
          â‰¤ lim[d->0] log(ğ”¼[sâ‚~T(sâ‚€, aâ‚€)] Î³ * |F(sâ‚) - F(sâ‚€)|) / log(1/d)  BY {
              LET U = Iterate^âˆ, V = U
              
              |U(sâ‚) - U(sâ‚€)| 
                = |ğ”¹(Optimal(U), T, r, Î³)(U)(sâ‚) - ğ”¹(Optimal(U), T, r, Î³)(U)(sâ‚€)|
                â‰¤ Î³ * max[s] |U(s) - V(s)|  BY Contraction
                = Î³ * |U(sâ‚) - U(sâ‚€)|  BY CHOOSING sâ‚, sâ‚€ 
              
              â„(F, d)
                = ğ”¼[sâ‚~T(sâ‚€, aâ‚€)] |F(sâ‚) - F(sâ‚€)| / d  BY definition
                = ğ”¼[sâ‚~T(sâ‚€, aâ‚€)] |U(sâ‚) - U(sâ‚€)| / d  BY <<M : FractalMDP>>
                â‰¤ ğ”¼[sâ‚~T(sâ‚€, aâ‚€)] Î³ * |U(sâ‚) - U(sâ‚€)| / d  USING PREV
            }
          = log(ğ”¼[sâ‚~T(sâ‚€, aâ‚€)] Î³ * |F(sâ‚) - F(sâ‚€)|) / log(1/Î³)  BY ALGEBRA
      }
    }

    THEOREM FractalRL {
      STATEMENT : âˆ€ (M : FractalMDP) . â„³(r âˆ˜ (Optimal âˆ˜ Iterate^n), n) â†’ M.F 

      PROOF {
        LET (T, r, Î³, F) : FractalMDP
        
        SUFFICES SHOW âˆ€ (n : â„•) . |â„³(r âˆ˜ (Optimal âˆ˜ Iterate^n), n)(s) - F(s)| â‰¤ Î³^n * max[s] |Iterate^n(s) - F(s)|

        LET n : â„•, s : State

        |â„³(r âˆ˜ (Optimal âˆ˜ Iterate^n), n)(s) - F(s)|
          = |r(s, Optimal(Iterate^n)(s)) - r(s, Optimal(Iterate^âˆ)(s))|  BY definition of â„³, F
          â‰¤ |r(s, Optimal(Iterate^n)(s)) - ğ”¹(Optimal(Iterate^âˆ), T, r, Î³)(Iterate^n)(s)| +
            |ğ”¹(Optimal(Iterate^âˆ), T, r, Î³)(Iterate^n)(s) - r(s, Optimal(Iterate^âˆ)(s))|  BY TRIANGLE INEQUALITY  
          â‰¤ Î³ * |Iterate^n(s) - Iterate^âˆ(s)| + 
            |ğ”¹(Optimal(Iterate^âˆ), T, r, Î³)(Iterate^n)(s) - ğ”¹(Optimal(Iterate^âˆ), T, r, Î³)(Iterate^âˆ)(s)|  BY DEFINITION of ğ”¹
          â‰¤ Î³ * |Iterate^n(s) - F(s)| + Î³ * max[s] |Iterate^n(s) - Iterate^âˆ(s)|  BY Contraction
          â‰¤ Î³^n * max[s] |Iterate^n(s) - F(s)|  BY ITERATING PREV n TIMES
      }
    }
  }
}