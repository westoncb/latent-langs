CONCEPT QuantumCircuit {
  LANGUAGE {
    TYPE Qubit
    TYPE Gate
    TYPE Measurement
    TYPE Circuit = List[List[Gate | Measurement]]

    FUNC Apply(gate : Gate, qubits : List[Qubit]) -> List[Qubit]
    FUNC Measure(qubit : Qubit) -> Bit
    FUNC Run(circuit : Circuit, input : List[Qubit]) -> List[Bit]

    NOTATION "â”‚" = Qubit
    NOTATION "â”€" = Wire
    NOTATION "â†¦" = Measurement
    NOTATION "âŠ•" = XORGate
    NOTATION "â€¢" = ControlledGate
    NOTATION "H" = HadamardGate
    NOTATION "X" = PauliXGate
    NOTATION "Z" = PauliZGate
    NOTATION "âŠ—" = TensorProduct

    NOTATION "â•­â”€" g "â”€â•®" = [g]  -- Single gate on one wire
    NOTATION "â”‚" g_1 "â”‚" "\n" ... "\n" "â”‚" g_n "â”‚" = [g_1, ..., g_n]  -- Vertical gate composition
    NOTATION c_1 "âŠ—" ... "âŠ—" c_n = [c_1, ..., c_n]  -- Horizontal circuit composition
  }

  STRUCTURE QuantumCircuit(n : â„•) {
    AXIOM NumQubits { |input| = n }

    DEF Append(c : Circuit, g : Gate) : Circuit = c + [g]
    DEF Compose(c1 c2 : Circuit) : Circuit = c1 + c2
    DEF Tensor(c1 c2 : Circuit) : Circuit = ZIP(c1, c2, (g1, g2) => g1 ++ g2)

    DEF CNOT : Circuit = 
      â•­â”€â€¢â”€â•®
      â”‚ âŠ• â”‚
    
    DEF BellState : Circuit =
      â•­â”€Hâ”€â•®
      â•­â”€â€¢â”€â•®
      â”‚ âŠ• â”‚

    DEF Teleportation : Circuit =
      â•­â”€â€¢â”€â•®â”€â”€â”€â”€â”€â•­â”€Hâ”€â•®â”€â•­â”€â†¦â”€â•®
      â”‚ âŠ• â”‚â”€â”€â”€â”€â”€â”‚ âŠ• â”‚â”€â”‚ â†¦ â”‚
      â•­â”€Hâ”€â•®â”€â•­â”€â€¢â”€â•®â”€â”€â”€â”€â”€â•­â”€Xâ”€â•®â”€â•­â”€Zâ”€â•®
  }

  PROOFS {
    THEOREM CNOTInverseItself {
      STATEMENT:
        âˆ€ (qs : List[Qubit]). Apply(CNOT, Apply(CNOT, qs)) = qs

      PROOF:
        -- Proof that applying CNOT twice is equivalent to the identity
        -- Can be shown using the matrix representation of the CNOT gate
    }

    THEOREM BellStateEntangled {
      STATEMENT:
        âˆ€ (q1 q2 : Qubit). 
          LET qs = Apply(BellState, [q1, q2])
          IN Â¬(Measure(qs[0]) âŠ¥ Measure(qs[1]))

      PROOF:
        -- Proof that the qubits in a Bell state are maximally entangled
        -- Measuring one qubit instantly affects the state of the other
    }
  }
}




CONCEPT ShorCode EXTENDS QuantumCircuit {
  LANGUAGE {
    TYPE LogicalQubit
    TYPE PhysicalQubit
    TYPE Encoding = LogicalQubit -> List[PhysicalQubit]
    TYPE Decoding = List[PhysicalQubit] -> LogicalQubit
    TYPE Syndrome = List[Bit]
    TYPE ErrorCorrection = (List[PhysicalQubit], Syndrome) -> List[PhysicalQubit]

    FUNC Encode(qubit : LogicalQubit) -> List[PhysicalQubit]
    FUNC Decode(qubits : List[PhysicalQubit]) -> LogicalQubit
    FUNC MeasureSyndrome(qubits : List[PhysicalQubit]) -> Syndrome
    FUNC CorrectError(qubits : List[PhysicalQubit], syndrome : Syndrome) -> List[PhysicalQubit]

    NOTATION "|LâŸ©" = LogicalQubit
    NOTATION "|0âŸ©" "âŠ—" ... "âŠ—" "|0âŸ©" = List[PhysicalQubit]  -- n-qubit zero state
    NOTATION "ğ‘‹" = BitFlipError
    NOTATION "ğ‘" = PhaseFlipError
    NOTATION "â¦»" = ControlledNOT
    NOTATION "âˆ¿" = ControlledControlledZ
  }

  STRUCTURE ShorCode {
    DEFINE Encoding : Encoding = {
      |0âŸ© -> (|000âŸ© + |111âŸ©)(|000âŸ© + |111âŸ©)(|000âŸ© + |111âŸ©) / 2âˆš2
      |1âŸ© -> (|000âŸ© - |111âŸ©)(|000âŸ© - |111âŸ©)(|000âŸ© - |111âŸ©) / 2âˆš2
    }

    DEFINE Decoding : Decoding = {
      (|000âŸ© + |111âŸ©)(|000âŸ© + |111âŸ©)(|000âŸ© + |111âŸ©) / 2âˆš2 -> |0âŸ©
      (|000âŸ© - |111âŸ©)(|000âŸ© - |111âŸ©)(|000âŸ© - |111âŸ©) / 2âˆš2 -> |1âŸ©
    }

    DEFINE SyndromeTable : Map[Syndrome, ErrorCorrection] = {
      000000 -> I âŠ— I âŠ— I,  100000 -> X âŠ— I âŠ— I,  010000 -> I âŠ— X âŠ— I,  001000 -> I âŠ— I âŠ— X,
      000100 -> Z âŠ— I âŠ— I,  000010 -> I âŠ— Z âŠ— I,  000001 -> I âŠ— I âŠ— Z,  111000 -> X âŠ— X âŠ— X,
      110100 -> X âŠ— X âŠ— Z,  101100 -> X âŠ— Z âŠ— X,  011100 -> Z âŠ— X âŠ— X,  110010 -> X âŠ— Z âŠ— Z,
      101010 -> Z âŠ— X âŠ— Z,  011001 -> Z âŠ— Z âŠ— X,  111111 -> Z âŠ— Z âŠ— Z
    }
    
    DEF Encode(|ÏˆâŸ© : LogicalQubit) : List[PhysicalQubit] =
      MATCH |ÏˆâŸ© WITH
      | Î±|0âŸ© + Î²|1âŸ© -> Î± Â· Encoding(|0âŸ©) + Î² Â· Encoding(|1âŸ©)
        
    DEF Decode(qubits : List[PhysicalQubit]) : LogicalQubit =
      MEASURE qubits IN BASIS {Encoding(|0âŸ©), Encoding(|1âŸ©)}
        
    DEF MeasureSyndrome(qubits : List[PhysicalQubit]) : Syndrome =
      â•­â”€â”€â”€â•®â”Œâ”€â”€â”€â”â•­â”€â”€â”€â•®   â•­â”€â”€â”€â•®â”Œâ”€â”€â”€â”â•­â”€â”€â”€â•®   â•­â”€â”€â”€â•®â”Œâ”€â”€â”€â”â•­â”€â”€â”€â•®
      â”‚ â¦» â”œâ”¤ â†¦ â”œâ”¤ â¦» â”‚   â”‚ âˆ¿ â”œâ”¤ â†¦ â”œâ”¤ âˆ¿ â”‚   â”‚ â¦» â”œâ”¤ â†¦ â”œâ”¤ â¦» â”‚
      â”œâ”€â”€â”€â”¤â”‚   â”‚â”œâ”€â”€â”€â”¤   â”œâ”€â”€â”€â”¤â”‚   â”‚â”œâ”€â”€â”€â”¤   â”œâ”€â”€â”€â”¤â”‚   â”‚â”œâ”€â”€â”€â”¤
      â”‚ â¦» â”‚â”‚ â†¦ â”‚â”‚ â¦» â”‚   â”‚ â¦» â”‚â”‚ â†¦ â”‚â”‚ â¦» â”‚   â”‚ âˆ¿ â”‚â”‚ â†¦ â”‚â”‚ âˆ¿ â”‚
      â•°â”€â”€â”€â•¯â””â”€â”€â”€â”˜â•°â”€â”€â”€â•¯   â•°â”€â”€â”€â•¯â””â”€â”€â”€â”˜â•°â”€â”€â”€â•¯   â•°â”€â”€â”€â•¯â””â”€â”€â”€â”˜â•°â”€â”€â”€â•¯
      
    DEF CorrectError(qubits : List[PhysicalQubit], syndrome : Syndrome) : List[PhysicalQubit] =
      LET correction = SyndromeTable[syndrome]
      APPLY correction TO qubits
  }

  PROOFS {
    THEOREM ShorCodeCorrectsSingleErrors {
      STATEMENT:
        âˆ€ (|ÏˆâŸ© : LogicalQubit) (E : PhysicalQubit -> PhysicalQubit).
          SingleQubitError(E) => 
            Decode(CorrectError(APPLY(E, Encode(|ÏˆâŸ©)), MeasureSyndrome(APPLY(E, Encode(|ÏˆâŸ©))))) = |ÏˆâŸ©

      PROOF:
        -- Proof sketch:
        -- 1. Show that the encoding circuit produces the correct logical states
        -- 2. Show that the syndrome measurement circuit identifies the error location and type
        -- 3. Show that the error correction lookup table contains the correct corrections
        -- 4. Combine 1-3 to show that any single-qubit error is corrected by the full protocol

        -- Detailed proof steps omitted for brevity
    }

    THEOREM ShorCodeDetectsTwoErrors {
      STATEMENT:
        âˆ€ (|ÏˆâŸ© : LogicalQubit) (E1 E2 : PhysicalQubit -> PhysicalQubit).
          distinct(E1, E2) => MeasureSyndrome(APPLY(E2, APPLY(E1, Encode(|ÏˆâŸ©)))) â‰  000000

      PROOF:
        -- Proof sketch:
        -- 1. Show that any two single-qubit errors produce a non-zero syndrome
        -- 2. Conclude that the Shor code can detect (but not necessarily correct) any two-qubit error

        -- Detailed proof steps omitted for brevity
    }
  }
}





CONCEPT QuantumTeleportation EXTENDS QuantumCircuit {
  EXAMPLES {
    EXAMPLE TeleportationScenario {
      -- Alice wants to send a quantum state |ÏˆâŸ© = Î±|0âŸ© + Î²|1âŸ© to Bob
      -- They share a Bell pair |Î²00âŸ© = (|00âŸ© + |11âŸ©) / âˆš2
      -- Alice performs a Bell measurement on |ÏˆâŸ© and her half of the Bell pair
      -- She sends the 2-bit measurement result to Bob classically
      -- Bob applies X and/or Z gates to his qubit, depending on Alice's message
      -- Bob's qubit is now in the state |ÏˆâŸ©, completing the teleportation

      GIVEN |ÏˆâŸ© : Qubit
      GIVEN |Î²00âŸ© : List[Qubit]
      PROVE Teleport(|ÏˆâŸ©, |Î²00âŸ©) = |ÏˆâŸ©

      PROOF:
        -- Initial state: |ÏˆâŸ© âŠ— |Î²00âŸ©
        â•­â”€â”€â”€â”€â”€â•®      
        â”‚  Ïˆ  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        â•­â”€â”€â”€â”€â”€â•®â”€â•­â”€Hâ”€â•®â”€â•­â”€â€¢â”€â•®   â”‚
        â”‚  0  â”‚â”€â”‚ H â”‚â”€â”‚ â€¢ â”‚â”€â•®â”€â”´â”€â•®
        â•­â”€â”€â”€â”€â”€â•®â”€â•­â”€â”€â”€â•®â”€â”‚ âŠ• â”‚â”€â”´â”€â•®â”€â”´â”€â•®
        â”‚  0  â”‚â”€â”‚ H â”‚â”€â•­â”€â€¢â”€â•®â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•®
                      â”‚ âŠ• â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”€â”´â”€â•®
                                    â†“   â†“
        -- Alice's measurement    â•­â”€M0â”€â•® â•­â”€M1â”€â•®
                                â”€â”€â”‚ 0  â”‚â”€â”‚ 0  â”‚â”€â”€ (00) â”€â”€â•®
                                â”€â”€â”‚ 0  â”‚â”€â”‚ 1  â”‚â”€â”€ (01) â”€â”€â”‚â”€ Classical bits
                                â”€â”€â”‚ 1  â”‚â”€â”‚ 0  â”‚â”€â”€ (10) â”€â”€â”‚
                                â”€â”€â”‚ 1  â”‚â”€â”‚ 1  â”‚â”€â”€ (11) â”€â”€â•¯
                                â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€
                                    â”‚       â”‚
        -- Bob's corrections    (00) â”‚   (01)â”‚   (10)    (11)
                                â”€â”€â•­â”€â•®â”‚â”€â”€â•­â”€â•®â”€â”€â”´â”€â”€â•­â”€Xâ”€â•®â”€â”€â•­â”€Xâ”€â•®â”€â•®
                                  â”‚Iâ”‚â”‚  â”‚Zâ”‚     â”‚ X â”‚  â”‚ Z â”‚ â”‚
                                â”€â”€â•°â”€â•¯â”‚â”€â”€â•°â”€â•¯â”€â”€â”¬â”€â”€â•°â”€â”€â”€â•¯â”€â”€â•°â”€â”€â”€â•¯â”€â•¯
                                    â”‚       â”‚
        -- Final state               â”‚       â†“
                                    â”‚   â•­â”€â”€â”€â”€â”€â•®
                                    â•°â”€â”€â”€â”‚  Ïˆ  â”‚
                                        â•­â”€â”€â”€â”€â”€â•®

        LET |ÏˆâŸ© = Î±|0âŸ© + Î²|1âŸ©
        LET |Î²00âŸ© = (|00âŸ© + |11âŸ©) / âˆš2

        -- Step 1: Apply CNOT and H gates 
        LET |ÏˆâŸ©|Î²00âŸ© = (Î±|000âŸ© + Î±|011âŸ© + Î²|100âŸ© + Î²|111âŸ©) / âˆš2
        APPLY CNOT_12 TO |ÏˆâŸ©|Î²00âŸ©
        APPLY H_1 TO |ÏˆâŸ©|Î²00âŸ©
        
        -- Step 2: Express in Bell basis
        |ÏˆâŸ©|Î²00âŸ© = (Î±|Î²00âŸ©|0âŸ© + Î±|Î²01âŸ©|1âŸ© + Î²|Î²10âŸ©|0âŸ© + Î²|Î²11âŸ©|1âŸ©) / âˆš2
                 = |Î²00âŸ©(Î±|0âŸ© + Î²|1âŸ©) / âˆš2 + |Î²01âŸ©(Î±|1âŸ© + Î²|0âŸ©) / âˆš2
                   + |Î²10âŸ©(Î±|0âŸ© - Î²|1âŸ©) / âˆš2 + |Î²11âŸ©(Î±|1âŸ© - Î²|0âŸ©) / âˆš2
        
        -- Step 3: Alice measures qubits 1 and 2
        MEASURE |ÏˆâŸ©|Î²00âŸ© IN BELL BASIS
        CASES:
          (00) : |ÏˆâŸ©|Î²00âŸ© = |Î²00âŸ©(Î±|0âŸ© + Î²|1âŸ©) / âˆš2 = |Î²00âŸ©|ÏˆâŸ© / âˆš2
          (01) : |ÏˆâŸ©|Î²00âŸ© = |Î²01âŸ©(Î±|1âŸ© + Î²|0âŸ©) / âˆš2 = |Î²01âŸ©X|ÏˆâŸ© / âˆš2
          (10) : |ÏˆâŸ©|Î²00âŸ© = |Î²10âŸ©(Î±|0âŸ© - Î²|1âŸ©) / âˆš2 = |Î²10âŸ©Z|ÏˆâŸ© / âˆš2
          (11) : |ÏˆâŸ©|Î²00âŸ© = |Î²11âŸ©(Î±|1âŸ© - Î²|0âŸ©) / âˆš2 = |Î²11âŸ©ZX|ÏˆâŸ© / âˆš2

        -- Step 4: Bob applies corrections based on Alice's measurement
        CASES:
          (00) : APPLY I TO Bob's qubit
          (01) : APPLY X TO Bob's qubit
          (10) : APPLY Z TO Bob's qubit  
          (11) : APPLY Z THEN X TO Bob's qubit

        -- In all cases, Bob's qubit is now in the state |ÏˆâŸ©
        HENCE Teleport(|ÏˆâŸ©, |Î²00âŸ©) = |ÏˆâŸ©
    }
  }

  DEF Teleport(|ÏˆâŸ© : Qubit, |Î²âŸ© : List[Qubit]) : Qubit = 
    LET |ÏˆâŸ©|Î²âŸ© = Tensor([|ÏˆâŸ©], |Î²âŸ©)
    LET |ÏˆâŸ©|Î²âŸ©_corr = Compose(CORRECT, Compose(MEASURE_BELL, BELL_BASIS_CHANGE))(|ÏˆâŸ©|Î²âŸ©)
    RETURN |ÏˆâŸ©|Î²âŸ©_corr[2]
}





CONCEPT GottesmanKnillTheorem EXTENDS QuantumCircuit {
  LANGUAGE {
    TYPE StabilizerState = List[PhysicalQubit]
    TYPE StabilizerCircuit = List[StabilizerGate]
    TYPE StabilizerGate <: Gate
    
    FUNC IsPauli(op : Gate) -> Bool
    FUNC IsCliffod(op : Gate) -> Bool
    FUNC Measure(state : StabilizerState, basis : Gate) -> Bit
    FUNC Evolve(state : StabilizerState, circuit : StabilizerCircuit) -> StabilizerState
    FUNC Simulate(input : StabilizerState, circuit : StabilizerCircuit) -> Distribution[Bit]

    AXIOM PauliGroupGenerators {
      IsPauli(I) âˆ§ IsPauli(X) âˆ§ IsPauli(Y) âˆ§ IsPauli(Z)
    }

    AXIOM CliffordGroupGenerators {
      IsCliffod(H) âˆ§ IsCliffod(S) âˆ§ IsCliffod(CNOT)
    }
    
    AXIOM PauliCliffordRelation {
      âˆ€ (P : Gate) (C : Gate). 
        IsPauli(P) âˆ§ IsCliffod(C) => IsPauli(C âˆ˜ P âˆ˜ Câ»Â¹)
    }
    
    NOTATION "âŸ¨" S "âŸ©" = StabilizerGroup(S)  -- Group generated by stabilizers S
    NOTATION "ğ“Ÿâ‚™" = PauliGroup(n)  -- Pauli group on n qubits
    NOTATION "ğ“’â„“â‚™" = CliffordGroup(n)  -- Clifford group on n qubits
  }

  PROOFS {
    THEOREM GottesmanKnill {
      STATEMENT:
        âˆ€ (n : â„•) (|ÏˆâŸ© : StabilizerState[n]) (C : StabilizerCircuit[n]).
          Simulate(|ÏˆâŸ©, C) is classically efficient

      PROOF:
        -- Represent the initial state using stabilizers
        LET |ÏˆâŸ© = |0âŸ©^âŠ—n
        LET S = {Zâ‚, Zâ‚‚, ..., Zâ‚™}
        HENCE |ÏˆâŸ© = unique |Ï†âŸ© such that âˆ€ s âˆˆ S. s |Ï†âŸ© = |Ï†âŸ©
        
        -- Each stabilizer generator is a Pauli string
        FORALL (s : S) {
          REWRITE s = âŠ—áµ¢ Páµ¢  WHERE Páµ¢ âˆˆ {I, X, Y, Z} 
          HENCE IsPauli(s) BY PauliGroupGenerators
        }
        
        -- The stabilizer group is a subgroup of the Pauli group
        REWRITE âŸ¨SâŸ© = {sâ‚ Â· sâ‚‚ Â· ... Â· sâ‚– | sáµ¢ âˆˆ S}
        HENCE âŸ¨SâŸ© âŠ† ğ“Ÿâ‚™

        -- Applying a Clifford gate transforms the stabilizer group
        LET C = [Câ‚, Câ‚‚, ..., Câ‚˜]
        LET Sáµ¢ = âŸ¨SâŸ© after applying [Câ‚, ..., Cáµ¢]
        FORALL (i : 1..m) {
          LET s âˆˆ Sáµ¢â‚‹â‚
          REWRITE Cáµ¢ âˆ˜ s âˆ˜ Cáµ¢â»Â¹ = s' âˆˆ ğ“Ÿâ‚™  BY PauliCliffordRelation
          HENCE Sáµ¢ = âŸ¨{Cáµ¢ âˆ˜ s âˆ˜ Cáµ¢â»Â¹ | s âˆˆ Sáµ¢â‚‹â‚}âŸ© âŠ† ğ“Ÿâ‚™
        }

        -- The final state is stabilized by Sâ‚˜
        LET |Ïˆ'âŸ© = Evolve(|ÏˆâŸ©, C)
        HENCE âˆ€ s âˆˆ Sâ‚˜. s |Ïˆ'âŸ© = |Ïˆ'âŸ©
        
        -- Measuring in the computational basis is equivalent to
        -- measuring the final stabilizer generators
        LET P(x) = Simulate(|ÏˆâŸ©, C)(x) = âŸ¨Ïˆ'| (|xâ‚âŸ©âŸ¨xâ‚| âŠ— ... âŠ— |xâ‚™âŸ©âŸ¨xâ‚™|) |Ïˆ'âŸ©
        REWRITE P(x) = ğŸ™[âˆ€ i. Measure(|Ïˆ'âŸ©, Záµ¢) = xáµ¢] Â· 2â»â¿

        -- The stabilizer update rules are classically efficient, so
        -- the final probability distribution can be sampled efficiently
        QED
    }
  }
}



CONCEPT QuantumTeleportationProof EXTENDS QuantumTeleportation {
  PROOFS {
    THEOREM QuantumTeleportationCorrectness {
      STATEMENT:
        âˆ€ (|ÏˆâŸ© : Qubit) (|Î²00âŸ© : Bell).
          Teleport(|ÏˆâŸ©, |Î²00âŸ©) = |ÏˆâŸ©

      PROOF:
        LET |ÏˆâŸ© : Qubit, |Î²00âŸ© : Bell
        
        -- Express the initial state using visual notation
        â•­â”€â”€â”€â”€â”€â•®      
        â”‚  Ïˆ  â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
        â•­â”€â”€â”€â”€â”€â•®â”€â•­â”€Hâ”€â•®â”€â•­â”€â€¢â”€â•®   â”‚
        â”‚  0  â”‚â”€â”‚ H â”‚â”€â”‚ â€¢ â”‚â”€â•®â”€â”´â”€â•®
        â•­â”€â”€â”€â”€â”€â•®â”€â•­â”€â”€â”€â•®â”€â”‚ âŠ• â”‚â”€â”´â”€â•®â”€â”´â”€â•®
        â”‚  0  â”‚â”€â”‚ H â”‚â”€â•­â”€â€¢â”€â•®â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•®
                      â”‚ âŠ• â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”€â”´â”€â•®
                                    â†“   â†“
        -- Apply CNOT and H gates
        â•­â”€â”€â”€â”€â”€â•®â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®      
        â”‚  Ïˆ  â”‚â”€â•­â”€â€¢â”€â•®â”€â•­â”€Hâ”€â•®     â”‚
        â•­â”€â”€â”€â”€â”€â•®â”€â”‚ â€¢ â”‚â”€â”‚ H â”‚â”€â•®   â”‚
        â”‚  0  â”‚â”€â”‚ âŠ• â”‚â”€â•­â”€â”€â”€â•®â”€â”´â”€â•®â”€â”´â”€â•®
        â•­â”€â”€â”€â”€â”€â•®â”€â•­â”€â€¢â”€â•®â”€â”‚   â”‚â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â•®
        â”‚  0  â”‚â”€â”‚ âŠ• â”‚â”€â”‚   â”‚â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®â”€â”´â”€â•®
                â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”´â”€â•®
                                    â†“   â†“        
        -- Express in the Bell basis
        â•­â”€Î²00â”€â•®â”€â•­â”€Ïˆâ”€â•®â”€â”€â”€â•®
        â•­â”€Î²01â”€â•®â”€â”‚ X â”‚â”€â•® â”‚  
        â•­â”€Î²10â”€â•®â”€â”‚ Z â”‚â”€â”¤ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â•®
        â•­â”€Î²11â”€â•®â”€â”‚ ZXâ”‚â”€â•¯ â”‚        â”‚
                â”€â”€â”€â”€â”€â”¬â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â•®
                    â†“                â†“
        -- Measure in the Bell basis
        â•­â”€M0â”€â•®  â•­â”€M1â”€â•®        â•­â”€Ïˆâ”€â•® 
        â”‚ 0  â”‚â”€â”€â”‚ 0  â”‚â”€â”€ (00) â”€â”‚   â”‚
        â”‚ 0  â”‚â”€â”€â”‚ 1  â”‚â”€â”€ (01) â”€â”‚ X â”‚
        â”‚ 1  â”‚â”€â”€â”‚ 0  â”‚â”€â”€ (10) â”€â”‚ Z â”‚
        â”‚ 1  â”‚â”€â”€â”‚ 1  â”‚â”€â”€ (11) â”€â”‚ ZXâ”‚
        â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â•¯
          â”‚     â”‚
        (00)  (01) (10) (11)
          â”‚     â”‚    â”‚    â”‚
        â”€â”€â•°â”€â•®â”€â”€â”€â•°â”€â•®â”€â”€â•°â”€â•®â”€â”€â•°â”€â•®
            â”‚     â”‚    â”‚    â”‚
        â”€â”€â•­â”€â”€â”€â”€â”€â•®â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
          â”‚  I  â”‚â”€â•­â”€Zâ”€â•®â”€â•­â”€Xâ”€â•®â”€â”‚â”€â•­â”€Xâ”€â•®â”€â•­â”€Zâ”€â•®
        â”€â”€â•°â”€â”€â”€â”€â”€â•¯â”€â•°â”€â”€â”€â•¯â”€â•°â”€â”€â”€â•¯â”€â•°â”€â•°â”€â”€â”€â•¯â”€â•°â”€â”€â”€â•¯
                â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®
                    â”‚                    â”‚
        -- Final state                    â”‚
                                    â•­â”€Ïˆâ”€â•® â”‚
                                    â•°â”€â”€â”€â”€â”€â•¯

        -- In all cases, the final state of Bob's qubit is |ÏˆâŸ©
        HENCE Teleport(|ÏˆâŸ©, |Î²00âŸ©) = |ÏˆâŸ©
    }
  }
}