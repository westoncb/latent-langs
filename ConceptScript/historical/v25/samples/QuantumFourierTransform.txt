CONCEPT QuantumFourierTransform {
  LANGUAGE {
    TYPE Ket[n] -- n-qubit quantum state
    TYPE Bra[n] -- dual of n-qubit quantum state
    TYPE Operator[n] -- operator on n-qubit states

    FUNC Tensor(a : Ket[n], b : Ket[m]) : Ket[n+m] -- tensor product of states
    FUNC Tensor(A : Operator[n], B : Operator[m]) : Operator[n+m] -- tensor product of operators  
    FUNC Compose(A : Operator[n], B : Operator[n]) : Operator[n] -- composition of operators
    FUNC Apply(A : Operator[n], v : Ket[n]) : Ket[n] -- application of operator to state
    FUNC InnerProduct(a : Bra[n], b : Ket[n]) : Complex -- inner product of states
    FUNC OuterProduct(a : Ket[n], b : Bra[n]) : Operator[n] -- outer product of states

    FUNC QFT[n] : Operator[n] -- n-qubit quantum Fourier transform  
    FUNC InverseQFT[n] : Operator[n] -- inverse of n-qubit quantum Fourier transform

    AXIOM QFTUnitarity {
      โ (n : Nat). Compose(QFT[n], InverseQFT[n]) = Compose(InverseQFT[n], QFT[n]) = I[n]  
    }

    NOTATION "โ" = Tensor
    NOTATION "โ" = Compose  
    NOTATION "โจ" a "|" b "โฉ" = InnerProduct(a, b)
    NOTATION "|" a "โฉโจ" b "|" = OuterProduct(a, b)
    NOTATION "๐นโ" = QFT
    NOTATION "๐นโโปยน" = InverseQFT
  }

  STRUCTURE QuantumState[n] {
    DEF Zero : Ket[n] = |0โฉ^โn
    DEF Basis(k : 0..2^n-1) : Ket[n] = |kโฉ  

    DEF Measure(v : Ket[n]) : 0..2^n-1 =  
      SAMPLE k WITH PROBABILITY |โจk|vโฉ|^2

    REQUIRE โ (v : Ket[n]). โจv|vโฉ = 1
  }

  STRUCTURE QuantumComputation[n] {
    DEF ApplyQFT(v : Ket[n]) : Ket[n] = ๐นโ |vโฉ
    DEF ApplyInverseQFT(v : Ket[n]) : Ket[n] = ๐นโโปยน |vโฉ  

    DEF QFTAddition(a : Ket[n], b : Ket[n]) : Ket[n] =
      LET |ฯโฉ = |aโฉ โ |bโฉ
      IN ๐นโโปยน ((๐นโ |aโฉ) โ (๐นโ |bโฉ))

    DEF EstimatePeriod(f : Ket[n] -> Ket[1]) : Nat =  
      LET |ฯโฉ = ๐นโ (โแตข |iโฉ โ |f(i)โฉ)  
      IN ROUND(1 / Measure(|ฯโฉ))
  }

  PROOFS {
    TACTIC Hadamard(H, n) = {
      H[0] = |+โฉ
      H[n+1] = H[n] โ |+โฉ
    }

    THEOREM QFTHadamard {  
      STATEMENT:
        โ (n : Nat). QFT[n] = H[n]

      PROOF:  
        BY INDUCTION on n
        BASE CASE: n = 0
          SHOW QFT[0] = H[0] BY {
            QFT[0] 
              = I                   BY DEFINITION QFT
              = |0โฉโจ0| + |1โฉโจ1|     BY DEFINITION I
              = |+โฉ                 BY DEFINITION |+โฉ
              = H[0]                BY DEFINITION H
          }
        INDUCTIVE CASE: n = k + 1
          IH: QFT[k] = H[k]
          SHOW QFT[k+1] = H[k+1] BY {
            QFT[k+1]
              = (I โ QFT[k]) โ (CZ โ I^โk) โ (I โ H[k])  BY DEFINITION QFT
              = (I โ H[k]) โ (CZ โ I^โk) โ (I โ H[k])    BY IH  
              = H[k] โ |+โฉ                               BY DEFINITION H, CZ
              = H[k+1]                                   BY DEFINITION H
          }
    }

    THEOREM QFTFourierSampling {
      STATEMENT:
        โ (f : Ket[n] -> Ket[1]) (k : 0..2^n-1).
          LET |ฯโฉ = ๐นโ (โแตข |iโฉ โ |f(i)โฉ)  
          IN Measure(|ฯโฉ) = k WITH PROBABILITY |โจk|ฯโฉ|^2 โ |๐(k)|^2 / 2^n

      PROOF:
        LET f : Ket[n] -> Ket[1], k : 0..2^n-1
        LET |ฯโฉ = ๐นโ (โแตข |iโฉ โ |f(i)โฉ)
        REWRITE |ฯโฉ
          = ๐นโ (โแตข |iโฉ โ |f(i)โฉ)  
          = โแตข ๐นโ (|iโฉ โ |f(i)โฉ)                     BY LINEARITY ๐นโ
          = โแตข (๐นโ |iโฉ) โ |f(i)โฉ                     BY MIXED PRODUCT PROPERTY
          = โแตข (โโฑผ ๐โฟโฝโฑสฒโพ |jโฉ) โ |f(i)โฉ               BY DEFINITION ๐นโ
            WHERE ๐ = e^(2ฯi/2^n)
          = โโฑผ (โแตข ๐โฟโฝโฑสฒโพ |f(i)โฉ) |jโฉ                 BY REARRANGING SUMS
          = โโฑผ ๐(j) |jโฉ                              BY DEFINITION DISCRETE FOURIER TRANSFORM
            WHERE ๐(j) = โแตข ๐โฟโฝโฑสฒโพ f(i)  
        
        SHOW Measure(|ฯโฉ) = k WITH PROBABILITY |โจk|ฯโฉ|^2 BY QuantumState.Measure  

        REWRITE |โจk|ฯโฉ|^2
          = |โจk| (โโฑผ ๐(j) |jโฉ) |^2
          = |โโฑผ ๐(j) โจk|jโฉ|^2                         BY LINEARITY โจ|โฉ
          = |๐(k)|^2                                BY ORTHONORMALITY |jโฉ

        SHOW |๐(k)|^2 / 2^n โ |๐(k)|^2 BY {
          |๐(k)|^2 / 2^n  
            = (|โแตข ๐โฟโฝโฑแตโพ f(i)|^2) / 2^n              BY DEFINITION ๐
            โ (โแตข |f(i)|^2) / 2^n                    BY PARSEVAL'S THEOREM
            โ |๐(k)|^2                              BY NORMALIZATION โแตข |f(i)|^2 โ 1
        }
    }
  }
}