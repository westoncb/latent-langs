CONCEPT FractalManifolds {
  LANGUAGE {
    TYPE FM[H : (0,1), M : Manifold] <: Manifold
    TYPE Measure[S] = (S -> ‚Ñù‚â•0) ‚à™ {‚àû}
    TYPE HausdorffDim = Manifold -> (0,‚àû)

    FUNC Iterate(f : M -> M, n : ‚Ñï) : M -> M
    FUNC Attractor(f : M -> M) : ùí´(M)  
    FUNC BoxCounting(S, Œµ) : ‚Ñï

    AXIOM Contraction {
      ‚àÄ (f : M -> M) . ‚àÉ (c : (0,1)) . 
        ‚àÄ (x y : M) . d(f(x), f(y)) ‚â§ c * d(x, y)
    }

    NOTATION "f^n" = Iterate(f, n)
    NOTATION "Œ¥[S]" = HausdorffDim(S)
    NOTATION "N[Œµ]" = BoxCounting(S, Œµ)
  }

  STRUCTURE FractalManifold(H : (0,1), M : Manifold) : FM[H, M] {
    DEF Metric(x y : M) : ‚Ñù‚â•0 = inf{ Œ£[i=1 to n] d(xi, xi+1)^H | x1 = x, xn+1 = y, n : ‚Ñï }

    REQUIRE ‚àÄ (x y z : M) . 
      Metric(x, y) ‚â§ Metric(x, z) + Metric(z, y)
  }

  PROOFS {
    THEOREM HausdorffMeasure {
      STATEMENT : ‚àÄ (S : FM[H, M]) . 
        Œº[H](S) = lim[Œµ->0] (inf{ Œ£[i=1 to ‚àû] diam(Ui)^H | S ‚äÜ ‚ãÉ[i=1 to ‚àû] Ui, diam(Ui) < Œµ })

      PROOF {
        LET S : FM[H, M], Œµ : ‚Ñù>0, Œ¥ = HausdorffDim(S)
        
        Œº[H](S) 
          = lim[Œµ->0] (inf{ Œ£ diam(Ui)^H | S ‚äÜ ‚ãÉ Ui, diam(Ui) < Œµ })  BY definition
          ‚âà lim[Œµ->0] (Œµ^(H-Œ¥) * N[Œµ](S))                            BY {
              N[Œµ](S) ‚âà C * Œµ^-Œ¥                                     BY definition of Œ¥
              diam(Ui) ‚âà Œµ                                           FOR "optimal" cover {Ui}
              Œ£ diam(Ui)^H ‚âà N[Œµ] * Œµ^H ‚âà C * Œµ^(H-Œ¥)                USING PREV, PREV
            }
          = C * lim[Œµ->0] Œµ^(H-Œ¥)
          = 0     IF H < Œ¥
            ‚àû     IF H > Œ¥
            C     IF H = Œ¥                                          BY properties of limits
      }
    }

    THEOREM Density {
      STATEMENT : ‚àÄ (S : FM[H, M]) (f : M -> M | f is contraction) .
        Œ¥[Attractor(f)] = -log[c](N) 
        WHERE N = lim[n->‚àû] (card(Fix(f^n)))^(1/n), c = contraction factor of f

      PROOF {
        LET S : FM[H, M], f : M -> M, A = Attractor(f), Œ¥ = Œ¥[A]
        ASSUME (1) : f is contraction with factor c

        lim[n->‚àû] (f^n(S)) = A                                      BY definition of attractor
        
        lim[Œµ->0] (N[Œµ](A) / N[Œµ](f^n(S))) = c^(n*Œ¥)                BY {
          N[Œµ](f^n(S)) ‚âà N[c^n*Œµ](S)                                BY (1)
          N[Œµ](A) ‚âà C1 * Œµ^-Œ¥                                       BY definition of Œ¥
          N[c^n*Œµ](S) ‚âà C2 * (c^n*Œµ)^-Œ¥ ‚âà C2 * c^(-n*Œ¥) * Œµ^-Œ¥      BY definition of Œ¥
          lim[Œµ->0] (C1 / (C2 * c^(-n*Œ¥))) = c^(n*Œ¥)                USING PREV, PREV
        }

        lim[n->‚àû] (card(Fix(f^n)))^(1/n) = N                        BY definition of N
        
        log[c](N) 
          = log[c](lim[n->‚àû] (card(Fix(f^n)))^(1/n))
          = lim[n->‚àû] log[c]((card(Fix(f^n)))^(1/n))               BY continuity of log
          = lim[n->‚àû] (1/n) * log[c](card(Fix(f^n)))
          = lim[n->‚àû] (log[c^n](card(Fix(f^n))))
          = -Œ¥                                                      USING PREV, PREV
      }
    }
  }
}



CONCEPT FractalNetworks {
  LANGUAGE {
    TYPE Node
    TYPE Edge = (Node, Node)
    TYPE Graph = (Set[Node], Set[Edge])
    TYPE Subgraph[G : Graph] = { S : Graph | S.Nodes ‚äÜ G.Nodes, S.Edges ‚äÜ G.Edges }
    TYPE Degree[G : Graph] = Node -> ‚Ñï
    TYPE Clustering[G : Graph] = Node -> [0,1]
    TYPE Centrality[G : Graph] = Node -> ‚Ñù‚â•0

    FUNC ShortestPath[G : Graph](n1 n2 : Node) : ‚Ñï ‚à™ {‚àû}
    FUNC Dijkstra[G : Graph](source : Node) : (Node -> ‚Ñù‚â•0)

    AXIOM SmallWorld {
      ‚àÄ (G : Graph | G is connected) (n : G.Nodes) . 
        avg[m : G.Nodes](ShortestPath[G](n, m)) ‚àà O(log(|G.Nodes|))
    }

    AXIOM ScaleFree {
      ‚àÄ (G : Graph) . 
        Pr[n : G.Nodes](Degree[G](n) = k) ‚àù k^(-Œ≥) for some Œ≥ > 0
    }
  }

  STRUCTURE FractalNetwork(H : (0,1), G : Graph) : FractalManifold[H, G] {
    DEF ClusteringDimension : (0,‚àû) = 
      lim[Œµ->0](log(avg[n : G.Nodes](|{ m : Ball[n, Œµ] | G.Edges(n, m) }|)) / log(1/Œµ))

    DEF Density(S : Subgraph[G]) : ‚Ñù = 
      |S.Edges| / |S.Nodes|^H

    REQUIRE ‚àÄ (S T : Subgraph[G]) . 
      d(S, T) = inf[f : S ‚âÖ T] max[n : S.Nodes] Dijkstra[G](f(n))(n)

    REQUIRE ‚àÄ (S : Subgraph[G]) . 
      Œ¥[S] = ClusteringDimension
  }

  PROOFS {
    THEOREM Densification {
      STATEMENT : ‚àÄ (F : FractalNetwork[H, G]) (S : Subgraph[G]) .
        Density(S) ‚àù |S.Nodes|^(1-H)

      PROOF {
        LET F : FractalNetwork[H, G], S : Subgraph[G], Œ¥ = ClusteringDimension, d = Density(S)
        
        |Ball[n, Œµ]| ‚àù Œµ^Œ¥                                  FOR n : S.Nodes   BY definition of Œ¥
        |S| ‚àù diam(S)^Œ¥                                     BY covering S with balls of size ‚âà diam(S)
        |S| ‚àù |S.Nodes|^(Œ¥/H)                               USING PREV, PREV
        d = |S.Edges| / |S.Nodes|^H                         BY definition of d
        d ‚àù |S|^(1-H/Œ¥) / |S.Nodes|^H                       USING PREV
        d ‚àù (|S.Nodes|^(Œ¥/H))^(1-H/Œ¥) / |S.Nodes|^H         USING PREV
        d ‚àù |S.Nodes|^(Œ¥/H - Œ¥/H + 1 - H)
        d ‚àù |S.Nodes|^(1-H)                                 BY ALGEBRA
      }
    }

    THEOREM RichClubScaling {
      STATEMENT : ‚àÄ (F : FractalNetwork[H, G]) (k : ‚Ñï) . 
        Œ¶(k) ‚àù k^(1/H - 1)
        WHERE Œ¶(k) = 2 * |{ (n, m) : G.Edges | Degree[G](n) ‚â• k, Degree[G](m) ‚â• k }| / (|{ n : G.Nodes | Degree[G](n) ‚â• k }| * (|{ n : G.Nodes | Degree[G](n) ‚â• k }| - 1))

      PROOF {
        LET F : FractalNetwork[H, G], k : ‚Ñï, Œ¥ = ClusteringDimension
        LET N‚â•k = { n : G.Nodes | Degree[G](n) ‚â• k }, E‚â•k = { (n, m) : G.Edges | n ‚àà N‚â•k, m ‚àà N‚â•k }

        |N‚â•k| ‚àù k^(-Œ≥)                                      BY ScaleFree
        |E‚â•k| ‚àù |N‚â•k|^(2-H)                                 BY Densification
        |E‚â•k| ‚àù k^(-Œ≥*(2-H))                                USING PREV, PREV
        Œ¶(k) = 2 * |E‚â•k| / (|N‚â•k| * (|N‚â•k| - 1))            BY definition of Œ¶
        Œ¶(k) ‚àù k^(-Œ≥*(2-H)) / (k^(-2*Œ≥))                    USING PREV, PREV
        Œ¶(k) ‚àù k^(2*Œ≥ - Œ≥*(2-H))
        Œ¶(k) ‚àù k^(Œ≥*H)
        Œ≥ = 1/H                                             BY ASSUME Œ≥ = 1/H
        Œ¶(k) ‚àù k^(1/H - 1)                                  USING PREV, PREV
      }
    }
  }
}



CONCEPT FractalNetworks {
  LANGUAGE {
    TYPE Network = (Nodes : ùí´(Node), Edges : ùí´(Node √ó Node))
    TYPE Degree = Node -> ‚Ñï
    TYPE Clustering = Node -> [0,1]
    TYPE Distance = Node √ó Node -> ‚Ñù‚â•0

    FUNC ShortestPath(x y : Node) : ‚Ñù‚â•0
    FUNC LocalDimension(x : Node, r : ‚Ñù‚â•0) : ‚Ñù‚â•0
    FUNC Centrality(x : Node) : ‚Ñù

    NOTATION "Œ≥[x]" = Degree(x)
    NOTATION "C[r]" = Clustering(x, r)
    NOTATION "d[x,y]" = Distance(x, y)
  }

  STRUCTURE FractalNetwork : Network {
    REQUIRE ‚àÉ (H : (0,1)) . 
      ‚àÄ (x : Node) . lim[r->‚àû] LocalDimension(x, r) = H

    DEF FractalDimension : ‚Ñù = H FROM REQUIRE

    FUNC LocalDimension(x : Node, r : ‚Ñù‚â•0) : ‚Ñù‚â•0 = 
      log[Œ≥[x]](card({ y : Node | d[x,y] ‚â§ r }))

    FUNC Metric(x y : Node) : ‚Ñù‚â•0 = 
      inf{ Œ£[i=1 to n] d[xi, xi+1]^H | x1 = x, xn+1 = y, n : ‚Ñï }

    REQUIRE ‚àÄ (x y z : Node) . 
      Metric(x, y) ‚â§ Metric(x, z) + Metric(z, y)
  }

  PROOFS {
    THEOREM SmallWorld {
      STATEMENT : ‚àÄ (F : FractalNetwork) (x y : Node) .
        E[ShortestPath(x, y)] ‚â§ C * log[card(Nodes)](d[x,y])
        WHERE C = 1 / FractalDimension(F)

      PROOF {
        LET F : FractalNetwork, H = FractalDimension(F)
        LET x y : Node, d = d[x,y], Œ¥ = LocalDimension(x, d)

        ShortestPath(x, y) 
          ‚â§ Metric(x, y)                                  BY definition of shortest path
          ‚â§ d^H                                            BY definition of Metric
          = exp(H * log(d))
          = card(Nodes)^(H * log[card(Nodes)](d))         BY ALGEBRA
          ‚â§ card(Nodes)^(H * log[card(Nodes)](d[x,y]))    USING d ‚â§ d[x,y]
          ‚â§ card(Nodes)^(Œ¥ * log[card(Nodes)](d[x,y]))    BY H ‚â§ Œ¥
          = C * log[card(Nodes)](d[x,y])                  WHERE C = 1/H
        
        HENCE E[ShortestPath(x, y)] ‚â§ C * log[card(Nodes)](d[x,y])  
      }
    }

    THEOREM Centrality {
      STATEMENT : ‚àÄ (F : FractalNetwork) (x : Node) . 
        Centrality(x) ‚àù card({ r : ‚Ñù‚â•0 | C[r](x) ‚â• 1/2 })

      PROOF {
        LET F : FractalNetwork, x : Node

        Centrality(x)
          ‚àù ‚à´[0 to ‚àû] C[r](x) dr                      BY definition
          ‚àù ‚à´[0 to ‚àû] ùüô{C[r](x) ‚â• 1/2} dr            BY ALGEBRA
          = Œº({ r : ‚Ñù‚â•0 | C[r](x) ‚â• 1/2 })            BY definition of Lebesgue measure
          ‚àù card({ r : ‚Ñù‚â•0 | C[r](x) ‚â• 1/2 })         BY MEASURE THEORY
      }
    }
  }  
}

