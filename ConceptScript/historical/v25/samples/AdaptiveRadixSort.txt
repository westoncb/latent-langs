CONCEPT AdaptiveRadixSort {
  LANGUAGE {
    TYPE Digit
    TYPE Key = List[Digit]
    TYPE Bucket = List[Key]  

    FUNC Sort(keys : List[Key]) : List[Key]
    FUNC MaxLen(keys : List[Key]) : Nat
    FUNC GetDigit(key : Key, i : Nat) : Digit
    FUNC CollectDigits(keys : List[Key], i : Nat) : List[Digit]
    FUNC Freq(digits : List[Digit]) : List[Nat]
    FUNC ToBuckets(keys : List[Key], i : Nat) : List[Bucket]
    FUNC Flatten(buckets : List[Bucket]) : List[Key]

    AXIOM Sorted {
      ‚àÄ (k : List[Key]) (i : Nat) . 
        i ‚â• MaxLen(k) ‚áí Sorted(k)
    }

    AXIOM Partitioned {
      ‚àÄ (bb : List[Bucket]) (i : Nat) . 
        (‚àÄ (b : Bucket) . b ‚àà bb ‚áí 
          (‚àÄ (k1 k2 : Key) . k1 ‚àà b ‚àß k2 ‚àà b ‚áí 
            Take(k1, i) = Take(k2, i))) ‚áí
        Partitioned(bb, i)
    }
  }

  STRUCTURE AdaptiveRadixSort {
    DEF Sort(keys : List[Key]) : List[Key] = 
      LET maxLen = MaxLen(keys)
          f(i) = IF i ‚â• maxLen THEN keys
                 ELSE LET digits = CollectDigits(keys, i)
                          freq = Freq(digits)
                      IN IF Uniform(freq) 
                         THEN f(i+1) 
                         ELSE LET buckets = ToBuckets(keys, i)
                              IN Flatten(Map(b ‚Ü¶ Sort(b), buckets))
      IN f(0)

    DEF Uniform(freq : List[Nat]) : ùîπ = 
      All(n ‚Ü¶ n = freq[0], freq)

    DEF CollectDigits(keys : List[Key], i : Nat) : List[Digit] =
      FlatMap(k ‚Ü¶ [GetDigit(k, i)], keys)
      
    DEF Freq(digits : List[Digit]) : List[Nat] =
      Map(d ‚Ü¶ Count(Equals(d), digits), Unique(digits)) 

    DEF ToBuckets(keys : List[Key], i : Nat) : List[Bucket] =
      LET buckets = Map(d ‚Ü¶ [], Unique(CollectDigits(keys, i)))
      IN Foldl((acc, k) ‚Ü¶ Update(GetDigit(k, i), acc, Append(Get(GetDigit(k, i), acc), k)), 
               buckets, 
               keys)
  }
  
  PROOFS {
    TACTIC SortedAfterMaxLen(keys, i) -> ùîπ {
      LET maxLen = MaxLen(keys)
      IF i ‚â• maxLen THEN 
        SHOW Sorted(keys) BY Sorted
      ELSE 
        SHOW ‚àÉ (i' > i) . SortedAfterMaxLen(keys, i')
    }

    TACTIC PartitionedIntoSingletons(keys, i) -> ùîπ {
      LET buckets = ToBuckets(keys, i)
      SHOW ‚àÄ (b : Bucket) . b ‚àà buckets ‚áí |b| ‚â§ 1 {
        LET b : Bucket, b ‚àà buckets
        LET k1 k2 : Key, k1 ‚àà b, k2 ‚àà b  
        SHOW k1 = k2 BY {
          Take(k1, i) = Take(k2, i) BY Partitioned
          k1 = k2 BY MaxLen(b) ‚â§ i, Sorted
        }
        HENCE |b| ‚â§ 1
      }
    }
    
    THEOREM Correctness {
      STATEMENT:
        ‚àÄ (keys : List[Key]) . Sorted(Sort(keys))
      
      PROOF:
        LET keys : List[Key]
        
        DEFINE P(i) = 
          LET digits = CollectDigits(keys, i)
              freq = Freq(digits)
          IN IF Uniform(freq) THEN SortedAfterMaxLen(keys, i)
             ELSE PartitionedIntoSingletons(keys, i)
        
        SHOW P(0) BY {
          LET i = 0
          LET digits = CollectDigits(keys, i)
          CASE Uniform(Freq(digits)):
            SHOW SortedAfterMaxLen(keys, i) BY SortedAfterMaxLen
          CASE ¬¨Uniform(Freq(digits)): 
            LET buckets = ToBuckets(keys, i)
            SHOW ‚àÄ (b : Bucket) . b ‚àà buckets ‚áí Sorted(Sort(b)) {
              LET b : Bucket, b ‚àà buckets
              SHOW Sorted(Sort(b)) BY Correctness
            }
            SHOW Partitioned(buckets, i) BY PartitionedIntoSingletons
            SHOW ‚àÄ (b1 b2 : Bucket) . b1 ‚â† b2 ‚áí ‚àÄ (k1 ‚àà b1) (k2 ‚àà b2) . k1 ‚â§ k2 {
              LET b1 b2 : Bucket, b1 ‚â† b2, k1 ‚àà b1, k2 ‚àà b2
              GetDigit(k1, i) < GetDigit(k2, i) BY ToBuckets
              HENCE k1 ‚â§ k2  
            }
            HENCE Sorted(Flatten(Map(Sort, buckets)))
        }

        HENCE ‚àÄ (i : Nat) . P(i) ‚áí P(i+1)
        HENCE ‚àÄ (i : Nat) . P(i)  
        HENCE P(MaxLen(keys))
        HENCE Sorted(Sort(keys)) 
    }
  }
}