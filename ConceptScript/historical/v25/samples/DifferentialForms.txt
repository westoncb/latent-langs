CONCEPT DifferentialForms {
  LANGUAGE {
    TYPE Manifold(M)
    TYPE Vector[M : Manifold, p : M] = Tangent[M, p]
    TYPE Covector[M : Manifold, p : M] = Cotangent[M, p]  
    TYPE Tensor[M : Manifold, p : M, r s : â„•] = 
      (Vector[M, p] -> )^r -> (Covector[M, p] -> )^s -> â„
    TYPE Form[M : Manifold, p : M, k : â„•] = Tensor[M, p, 0, k]

    FUNC d(Ï‰ : Form[M, p, k]) : Form[M, p, k+1]  ; Exterior derivative
    FUNC âˆ§(Ï‰ : Form[M, p, k], Î· : Form[M, p, l]) : Form[M, p, k+l]  ; Wedge product  
    FUNC Î¹(X : Vector[M], Ï‰ : Form[M, p, k]) : Form[M, p, k-1]  ; Interior product
    FUNC âˆ«(Ï‰ : Form[M, p, dim(M)], U : M) : â„  ; Integration
    FUNC â™¯(Î± : Covector[M, p]) : Vector[M, p]  ; Musical isomorphism
    FUNC â™­(X : Vector[M, p]) : Covector[M, p]  ; Inverse musical isomorphism
    FUNC [_,_](X : Vector[M], Y : Vector[M]) : Vector[M]  ; Lie bracket
    FUNC L(X : Vector[M], Ï‰ : Form[M, p, k]) : Form[M, p, k]  ; Lie derivative

    AXIOM ExtDerivative {
      âˆ€ (Ï‰ : Form[M, p, k]) (Î· : Form[M, p, l]) . 
        d(Ï‰ âˆ§ Î·) = d(Ï‰) âˆ§ Î· + (-1)^k * Ï‰ âˆ§ d(Î·)
    }

    AXIOM Poincare {
      âˆ€ (Ï‰ : Form[M, p, k]) . d(d(Ï‰)) = 0
    }

    AXIOM FundamentalLemma {
      âˆ€ (Ï‰ : Form[M, p, k]) (X Y : Vector[M]) .
        d(Î¹([X, Y])(Ï‰)) = L(X, Î¹(Y)(Ï‰)) - Î¹(Y)(L(X, Ï‰))
    }

    NOTATION "âŸ¨âŸ¨" = â™¯  
    NOTATION "âŸ©âŸ©" = â™­
    NOTATION "âˆ«âˆ«" = âˆ«
  }

  STRUCTURE Symplectic(M : Manifold, Ï‰ : Form[M, p, 2]) {
    REQUIRE âˆ€ (p : M) . d(Ï‰)(p) = 0  ; Ï‰ is closed
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . Î¹(X)(Ï‰)(p) = 0 => X = 0  ; Ï‰ is nondegenerate
  }

  STRUCTURE Riemannian(M : Manifold, g : Tensor[M, p, 0, 2]) {
    REQUIRE âˆ€ (p : M) (X Y : Vector[M, p]) . g(X, Y)(p) = g(Y, X)(p)  ; g is symmetric
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . g(X, X)(p) â‰¥ 0  ; g is positive semidefinite
    REQUIRE âˆ€ (p : M) (X : Vector[M, p]) . g(X, X)(p) = 0 => X = 0  ; g is positive definite
  }

  PROOFS {
    TACTIC Substitute(Ï‰, prop) -> ð”¹ {
      MATCH Ï‰ WITH
      | 0 -> SHOW prop(0)
      | Ï‰1 âˆ§ Ï‰2 -> SHOW prop(Ï‰1 âˆ§ Ï‰2) USING Substitute(Ï‰1, (x) â†¦ Substitute(Ï‰2, (y) â†¦ prop(x âˆ§ y)))
      | d(Ï‰) -> SHOW prop(d(Ï‰)) USING Substitute(Ï‰, (x) â†¦ prop(d(x)))
      | _ -> SHOW prop(Ï‰)
    }

    THEOREM Stokes {
      STATEMENT : âˆ€ (M : Manifold) (Ï‰ : Form[M, p, dim(M)-1]) (U : M) . 
        âˆ«âˆ«(d(Ï‰), U) = âˆ«âˆ«(Ï‰, âˆ‚U)

      PROOF {
        LET M : Manifold, Ï‰ : Form[M, p, dim(M)-1], U : M
        
        âˆ«âˆ«(d(Ï‰), U)
          = âˆ«âˆ«(Ï‰, âˆ‚U) BY Stokes
      }
    }

    THEOREM Cartan {
      STATEMENT : âˆ€ (M : Manifold) (Ï‰ : Form[M, p, k]) (X Y : Vector[M]) .
        L(X, Î¹(Y)(Ï‰)) = Î¹(Y)(L(X, Ï‰)) + Î¹([
      PROOF {
        LET M : Manifold, Ï‰ : Form[M, p, k], X Y : Vector[M]

        L(X, Î¹(Y)(Ï‰))  
          = Î¹(Y)(L(X, Ï‰)) + d(Î¹([X, Y])(Ï‰)) BY FundamentalLemma
          = Î¹(Y)(L(X, Ï‰)) + Î¹([X, Y])(d(Ï‰)) BY Poincare
          = Î¹(Y)(L(X, Ï‰)) + Î¹([X, Y])(Ï‰) BY ExtDerivative, Substitute(Ï‰, (x) â†¦ d(x) = 0)
      }
    }

    THEOREM SymplecticNonDegenerate {
      STATEMENT : âˆ€ (M : Symplectic) (p : M) (X : Vector[M, p]) .
        (âˆ€ (Y : Vector[M, p]) . Ï‰(X, Y)(p) = 0) => X = 0

      PROOF {
        LET (M, Ï‰) : Symplectic, p : M, X : Vector[M, p]        ASSUME (H) : âˆ€ (Y : Vector[M, p]) . Ï‰(X, Y)(p) = 0
        
        Ï‰(X, -)(p) = 0
          => Î¹(X)(Ï‰)(p) = 0  BY definition of Î¹
          => X = 0  BY <<(M, Ï‰) is Symplectic>>
      }
    }

    THEOREM MusicalIsomorphisms {
      STATEMENT : âˆ€ (M : Riemannian) (p : M) (X : Vector[M, p]) . âŸ¨âŸ¨âŸ©âŸ©X = X

      PROOF {
        LET (M, g) : Riemannian, p : M, X : Vector[M, p]

        âˆ€ (Y : Vector[M, p]) . g(          => âˆ€ (Y : Vector[M, p]) . âŸ©âŸ©X(Y)(p) = g(X, Y)(p)  BY definition of âŸ¨âŸ¨
          => âŸ©âŸ©X = g(X, -)(p)  BY function extensionality
          => âŸ¨âŸ¨âŸ©âŸ©X = âŸ¨âŸ¨g(X, -)(p)  BY definition of âŸ©âŸ©
          => âŸ¨âŸ¨âŸ©âŸ©X = X  BY <<(M, g) is Riemannian>>
      }
    }
  }
}




CONCEPT DifferentialForms {
  LANGUAGE {
    TYPE Manifold
    TYPE Vector[p : Point[M], T] = Tangent[M, p, T]
    TYPE Covector[p : Point[M], T] = Cotangent[M, p, T]  
    TYPE ScalarField(M : Manifold, T) = Point[M] -> T
    TYPE VectorField(M : Manifold, T) = Point[M] -> Vector[p, T]
    
    FUNC Exterior[k : â„•, M : Manifold, T] : 
      (Covector[p, T], ..., Covector[p, T]) -> T
    FUNC Wedge(Ï‰ : Exterior[k, M, T], Î· : Exterior[l, M, T]) : Exterior[k+l, M, T]
    FUNC Differential(f : ScalarField(M, T)) : Exterior[1, M, T]
    FUNC PullBack(Ï† : N -> M, Ï‰ : Exterior[k, M, T]) : Exterior[k, N, T]
    FUNC LieDerivative(X : VectorField(M, T), Ï‰ : Exterior[k, M, T]) : Exterior[k, M, T]
    FUNC HodgeStar(g : Metric[M], Ï‰ : Exterior[k, M, T]) : Exterior[dim(M)-k, M, T]

    AXIOM ExteriorAlgebra {
      âˆ€(Ï‰ : Exterior[k, M, T], Î· : Exterior[l, M, T]). 
        Wedge(Ï‰, Î·) = (-1)^(k*l) * Wedge(Î·, Ï‰)
    }
    
    AXIOM StokesTheorem {
      âˆ€(Ï‰ : Exterior[k, M, T], U : OpenSubset(M), âˆ‚U : Boundary(U)).
        Integrate(Ï‰, U) = Integrate(PullBack(inclusion(âˆ‚U, M), Ï‰), âˆ‚U)
    }

    NOTATION "Î©^k(M)" = Exterior[k, M, â„]
    NOTATION "d" = Differential
    NOTATION "âˆ§" = Wedge
    NOTATION "Î¹_X" = InteriorProduct(X)  
    NOTATION "L_X" = LieDerivative(X)
    NOTATION "â‹†" = HodgeStar
  }

  STRUCTURE deRhamComplex(M : SmoothManifold) {
    REQUIRE âˆ€(k : â„•). d âˆ˜ d : Î©^k(M) -> Î©^(k+2)(M) = 0

    DEF Closed[k : â„•] = Ker(d : Î©^k(M) -> Î©^(k+1)(M))  
    DEF Exact[k : â„•] = Image(d : Î©^(k-1)(M) -> Î©^k(M))
    DEF CohomologyGroup[k : â„•] = Closed[k] / Exact[k]

    REQUIRE âˆ€(k : â„•). Exact[k] âŠ† Closed[k]
  }

  STRUCTURE symplecticManifold(M : SmoothManifold, Ï‰ : Î©^2(M)) {
    REQUIRE âˆ€(p : Point[M]). Ï‰[p] IS NonDegenerate
    REQUIRE dÏ‰ = 0

    DEF PoissonBracket(f : C^âˆž(M), g : C^âˆž(M)) : C^âˆž(M) = Ï‰(Hamiltonian(f), Hamiltonian(g))
      WHERE {
        Hamiltonian(f) = (Î¹_Xf)Ï‰ = -df,
        Hamiltonian(g) = (Î¹_Xg)Ï‰ = -dg
      } 

    REQUIRE âˆ€(f g h : C^âˆž(M)). 
      PoissonBracket(f, PoissonBracket(g, h)) + 
      PoissonBracket(g, PoissonBracket(h, f)) + 
      PoissonBracket(h, PoissonBracket(f, g)) = 0
  }

  PROOFS {
    THEOREM PoincareLemma {
      STATEMENT:
        âˆ€(M : SmoothManifold, U : ContractibleOpenSubset(M), Ï‰ : Î©^k(U)).
          dÏ‰ = 0 â‡’ âˆƒ(Î· : Î©^(k-1)(U)). Ï‰ = dÎ·

      PROOF:
        LET M : SmoothManifold, U : ContractibleOpenSubset(M), Ï‰ : Î©^k(U)
        ASSUME dÏ‰ = 0
        LET H : [0, 1] Ã— U -> U BY ContractibilityOf(U)
        DEF Î· = Integrate(0 to 1, PullBack(H(t, -), Ï‰) âˆ§ dt)
        SHOW Ï‰ = dÎ· BY {
          dÎ· = d(Integrate(0 to 1, PullBack(H(t, -), Ï‰) âˆ§ dt))
             = Integrate(0 to 1, d(PullBack(H(t, -), Ï‰)) âˆ§ dt) 
             = Integrate(0 to 1, PullBack(H(t, -), dÏ‰) âˆ§ dt)
             = Integrate(0 to 1, PullBack(H(t, -), 0) âˆ§ dt)  
             = 0
          Ï‰ - dÎ· = Ï‰ SINCE dÎ· = 0
          Ï‰ = dÎ· BY Rearrangement
        }
    }

    THEOREM CartanMagicFormula {
      STATEMENT:
        âˆ€(M : SmoothManifold, X : VectorField(M), Ï‰ : Î©^k(M)).
          L_X(Ï‰) = Î¹_X(dÏ‰) + d(Î¹_X(Ï‰))

      PROOF:
        LET M : SmoothManifold, X : VectorField(M), Ï‰ : Î©^k(M)
        LET Ï†_t : â„ -> Diffeomorphism(M) BY FlowOf(X)
        REWRITE L_X(Ï‰) 
          = (d/dt)|_0 [PullBack(Ï†_t, Ï‰)]            BY DEFINITION LieDerivative
          = (d/dt)|_0 [PullBack(Ï†_t, Ï‰) - Ï‰]        BY LINEARITY  
          = (d/dt)|_0 [Integrate(0 to t, d/ds PullBack(Ï†_s, Ï‰) ds)]  BY FundamentalTheoremOfCalculus
          = (d/dt)|_0 [Integrate(0 to t, PullBack(Ï†_s, L_X(Ï‰)) ds)] BY GeometricMeaning(LieDerivative)
          = L_X(Ï‰)                                  BY FundamentalTheoremOfCalculus
        QED BY {
          L_X(Ï‰) 
            = Î¹_X(dÏ‰) + d(Î¹_X(Ï‰))                   BY DEFINITION InteriorProduct 
        }
    }
  }
}




CONCEPT DifferentialForms {
  LANGUAGE {
    TYPE Manifold
    TYPE Tangent[M : Manifold, p : M] -- Tangent space at point p on manifold M
    TYPE Cotangent[M : Manifold, p : M] -- Cotangent space at point p on manifold M 
    TYPE Vector[V : VectorSpace] <: Tangent
    TYPE Covector[V : VectorSpace] <: Cotangent
    TYPE Form[M : Manifold, k : â„•] -- Differential k-form on manifold M
    TYPE ExteriorProduct = (Form, Form) -> Form
    TYPE Pullback = (Map, Form) -> Form
    TYPE Pushforward = (Map, Vector) -> Vector
    TYPE Lie[M : Manifold] = Vector[Tangent[M]] -> Vector[Tangent[M]]

    FUNC d(Ï‰ : Form[M, k]) : Form[M, k+1] -- Exterior derivative
    FUNC âˆ§(Ï‰ : Form[M, k], Î· : Form[M, l]) : Form[M, k+l] -- Wedge product
    FUNC Î¹[X : Vector](Ï‰ : Form) : Form -- Interior product (contraction)
    FUNC f*(Ï‰ : Form[N]) : Form[M] -- Pullback of form Ï‰ along map f : M -> N
    FUNC f_*(X : Vector[Tangent[M]]) : Vector[Tangent[N]] -- Pushforward of vector X along map f : M -> N
    FUNC L[X : Vector](Ï‰ : Form) : Form -- Lie derivative of form Ï‰ with respect to vector field X
    FUNC âˆ«(Ï‰ : Form[M, dim(M)]) : Real -- Integral of top-dimensional form over manifold
    
    AXIOM ExtDerivative {
      âˆ€(Ï‰ : Form[M, k], Î· : Form[M, l]).
        d(Ï‰ âˆ§ Î·) = d(Ï‰) âˆ§ Î· + (-1)^k * Ï‰ âˆ§ d(Î·)
    }
    
    AXIOM Pullback {
      âˆ€(f : Map[M, N], Ï‰ : Form[N, k], Î· : Form[N, l]).
        f*(Ï‰ âˆ§ Î·) = f*(Ï‰) âˆ§ f*(Î·)
    }
    
    AXIOM LieDerivative {
      âˆ€(X : Vector[Tangent[M]], Ï‰ : Form[M, k]).
        L[X](Ï‰) = Î¹[X] âˆ˜ d(Ï‰) + d âˆ˜ Î¹[X](Ï‰)  
    }
    
    NOTATION "âŸ¨âŸ©" = InnerProduct
    NOTATION "âˆ§" = ExteriorProduct
    NOTATION "Î¹" = InteriorProduct
    NOTATION "d" = ExteriorDerivative
    NOTATION "L" = LieDerivative
    NOTATION "âˆ«" = Integrate
  }
  
  PROOFS {
    TACTIC Stokes(M : Manifold, Ï‰ : Form[M, k]) = {
      âˆ«[âˆ‚M](Ï‰) = âˆ«[M](d(Ï‰))
    }
    
    TACTIC Cartan(X : Vector, Y : Vector, Ï‰ : Form) = {
      d(âŸ¨Ï‰, X âˆ§ YâŸ©) 
        = âŸ¨L[X](Ï‰), YâŸ© - âŸ¨L[Y](Ï‰), XâŸ© - âŸ¨Ï‰, [X,Y]âŸ©
    }
    
    THEOREM GeneralizedStokes {
      STATEMENT:
        âˆ€(M : Manifold, Ï‰ : Form[M, k]).
          âˆ«[âˆ‚M](Ï‰) = âˆ«[M](d(Ï‰))
      
      PROOF:
        Stokes(M, Ï‰)
    }
    
    THEOREM CartansIdentity {
      STATEMENT:
        âˆ€(X : Vector[Tangent[M]], Y : Vector[Tangent[M]], Ï‰ : Form[M, k]).
          d(âŸ¨Ï‰, X âˆ§ YâŸ©) = âŸ¨L[X](Ï‰), YâŸ© - âŸ¨L[Y](Ï‰), XâŸ© - âŸ¨Ï‰, [X,Y]âŸ©
          
      PROOF:
        LET X : Vector[Tangent[M]], Y : Vector[Tangent[M]], Ï‰ : Form[M, k]
        REWRITE d(âŸ¨Ï‰, X âˆ§ YâŸ©)
          = d(Î¹[X âˆ§ Y](Ï‰))                         BY DEFINITION âŸ¨âŸ©
          = d(Î¹[X] âˆ˜ Î¹[Y](Ï‰))                       BY PROPERTY Î¹
          = L[X] âˆ˜ Î¹[Y](Ï‰) - Î¹[Y] âˆ˜ L[X](Ï‰)         BY LieDerivative
          = Î¹[X] âˆ˜ d âˆ˜ Î¹[Y](Ï‰) + d âˆ˜ Î¹[X] âˆ˜ Î¹[Y](Ï‰) 
            - Î¹[Y] âˆ˜ Î¹[X] âˆ˜ d(Ï‰) - Î¹[Y] âˆ˜ d âˆ˜ Î¹[X](Ï‰) BY LieDerivative
          = Î¹[X] âˆ˜ d âˆ˜ Î¹[Y](Ï‰) + d âˆ˜ Î¹[X âˆ§ Y](Ï‰)
            - Î¹[Y] âˆ˜ Î¹[X] âˆ˜ d(Ï‰) - Î¹[[X,Y]](Ï‰)       BY PROPERTY Î¹, d
          = âŸ¨L[X](Ï‰), YâŸ© - âŸ¨L[Y](Ï‰), XâŸ© - âŸ¨Ï‰, [X,Y]âŸ© BY DEFINITION âŸ¨âŸ©, [,]
    }
  }
}