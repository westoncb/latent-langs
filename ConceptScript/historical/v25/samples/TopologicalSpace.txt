CONCEPT TopologicalSpace {
  LANGUAGE {
    TYPE Space
    TYPE Set(X : Space) <: Space
    TYPE Open(X : Space) <: Set(X)
    TYPE Continuous(X Y : Space) = X -> Y

    FUNC Basis(X : Space) : Set(Set(X))

    AXIOM OpenUnion {
      âˆ€ (X : Space) (O : Set(Open(X))). 
        â‹ƒ(O) : Open(X)
    }

    AXIOM OpenInter {
      âˆ€ (X : Space) (O1 O2 : Open(X)). 
        O1 âˆ© O2 : Open(X)
    }

    AXIOM OpenWhole {
      âˆ€ (X : Space). X : Open(X)  
    }

    AXIOM OpenEmpty {
      âˆ€ (X : Space). âˆ… : Open(X)
    }

    REWRITE BasisUnion {
      âˆ€ (X : Space) (B : Basis(X)) (O : Open(X)).
        O = â‹ƒ({ B' âˆˆ B | B' âŠ† O })
    }

    NOTATION "f : X âŸ¶ Y" = Continuous(X, Y)
  }

  STRUCTURE HausdorffSpace(X : Space) {
    REQUIRE âˆ€ (p q : X). p â‰  q =>
      âˆƒ (O1 O2 : Open(X)). p âˆˆ O1 âˆ§ q âˆˆ O2 âˆ§ O1 âˆ© O2 = âˆ…  
  }

  STRUCTURE CompactSpace(X : Space) {
    REQUIRE âˆ€ (O : Set(Open(X))). X âŠ† â‹ƒ(O) => 
      âˆƒ (F : Set(Open(X))). Finite(F) âˆ§ F âŠ† O âˆ§ X âŠ† â‹ƒ(F)
  }

  PROOFS {
    TACTIC Topology(X) -> ð”¹ = 
      SHOW X : Space,
      SHOW âˆ€ (O : Set(Open(X))). â‹ƒ(O) : Open(X),
      SHOW âˆ€ (O1 O2 : Open(X)). O1 âˆ© O2 : Open(X),  
      SHOW X : Open(X),
      SHOW âˆ… : Open(X)

    THEOREM SubspaceTopology {
      STATEMENT:
        âˆ€ (X : Space) (Y : Set(X)). 
          LET SubSpace = {
            Space := Y,
            Open := { O âˆ© Y | O : Open(X) },
            _ := INDUCED
          } IN Topology(SubSpace)
      
      PROOF:
        LET X : Space, Y : Set(X)
        DEFINE SubSpace = {
          Space := Y,   
          Open := { O âˆ© Y | O : Open(X) },
          _ := INDUCED  
        }

        SHOW SubSpace : Space
        SHOW âˆ€ (O : Set(Open(SubSpace))). â‹ƒ(O) : Open(SubSpace) BY {
          LET O : Set(Open(SubSpace))
          REWRITE â‹ƒ(O) 
            = â‹ƒ({ O' âˆˆ Open(X) | âˆƒ (V âˆˆ O). V = O' âˆ© Y}) âˆ© Y
              BY Substitution  
            : Open(SubSpace) 
              BY OpenUnion, Substitution
        }
        SHOW âˆ€ (O1 O2 : Open(SubSpace)). O1 âˆ© O2 : Open(SubSpace) BY {
          LET O1 O2 : Open(SubSpace)
          MATCH (O1, O2) WITH 
          | (U1 âˆ© Y, U2 âˆ© Y) -> 
            REWRITE O1 âˆ© O2
              = (U1 âˆ© Y) âˆ© (U2 âˆ© Y)  
              = (U1 âˆ© U2) âˆ© Y
                BY Associativity, Commutativity
              : Open(SubSpace)
                BY OpenInter, Substitution
        }     
        SHOW Y : Open(SubSpace) 
          BY REWRITE Y = X âˆ© Y : Open(SubSpace)
        SHOW âˆ… : Open(SubSpace)  
          BY REWRITE âˆ… = âˆ… âˆ© Y : Open(SubSpace) 

        HENCE Topology(SubSpace)
    }

    THEOREM CompactHausdorff {
      STATEMENT:  
        âˆ€ (X : CompactSpace) (Y : HausdorffSpace).
          LET Z = {
            Space := X Ã— Y,
            Basis := { U Ã— V | U âˆˆ Basis(X), V âˆˆ Basis(Y) },  
            _ := INDUCED
          } IN CompactSpace(Z) âˆ§ HausdorffSpace(Z)

      PROOF:
        LET X : CompactSpace, Y : HausdorffSpace
        DEFINE Z = {  
          Space := X Ã— Y,
          Basis := { U Ã— V | U âˆˆ Basis(X), V âˆˆ Basis(Y) },
          _ := INDUCED
        }
        
        SHOW CompactSpace(Z) BY {
          LET O : Set(Open(Z)), Z âŠ† â‹ƒ(O)
          HAVE âˆ€ (p : X) (q : Y). (p, q) âˆˆ â‹ƒ(O)  
          ...
        }

        SHOW HausdorffSpace(Z) BY {
          LET (p1, q1) (p2, q2) : Z, (p1, q1) â‰  (p2, q2)
          MATCH (p1 = p2, q1 = q2) WITH
          | (TRUE, FALSE) -> ... 
          | (FALSE, TRUE) -> ...
          | (FALSE, FALSE) -> ...
        }

        HENCE CompactSpace(Z) âˆ§ HausdorffSpace(Z) 
    }
  }
}








CONCEPT TopologicalSpace {
  LANGUAGE {
    TYPE Space
    TYPE Set <<: Space
    TYPE Open <<: Set
    TYPE Continuous(X : Space, Y : Space) = X -> Y

    AXIOM OpenUnion {
      âˆ€ (O : Set <<: Open). Union(O) : Open
    }

    AXIOM OpenInter {
      âˆ€ (O1 O2 : Open). Inter(O1, O2) : Open 
    }

    AXIOM OpenWhole {
      Space : Open
    }  

    AXIOM OpenEmpty {
      Empty : Open
    }

    NOTATION "X âŠ† Y" = Subset(X, Y)
    NOTATION "X âˆª Y" = Union(X, Y)
    NOTATION "X âˆ© Y" = Inter(X, Y)
    NOTATION "f : X â†’ Y" = Continuous(X, Y)
  }

  STRUCTURE BasisSpace(Space, Basis : Set <<: Open) {
    REQUIRE âˆ€ (p : Space). âˆƒ (B : Basis). p âˆˆ B
    REQUIRE âˆ€ (B1 B2 : Basis). âˆ€ (p : Space). p âˆˆ B1 âˆ© B2 => âˆƒ (B3 : Basis). p âˆˆ B3 âˆ§ B3 âŠ† B1 âˆ© B2
  }

  STRUCTURE T1Space {
    REQUIRE âˆ€ (p q : Space). p â‰  q => âˆƒ (O : Open). (p âˆˆ O âˆ§ q âˆ‰ O) âˆ¨ (p âˆ‰ O âˆ§ q âˆˆ O)
  } 

  STRUCTURE HausdorffSpace {
    REQUIRE âˆ€ (p q : Space). p â‰  q => âˆƒ (O1 O2 : Open). p âˆˆ O1 âˆ§ q âˆˆ O2 âˆ§ O1 âˆ© O2 = Empty
  }

  PROOFS {
    THEOREM ContinuousComposition {
      STATEMENT:
        âˆ€ (X Y Z : Space) (f : X â†’ Y) (g : Y â†’ Z). (g âˆ˜ f) : X â†’ Z

      PROOF:
        LET X Y Z : Space, f : X â†’ Y, g : Y â†’ Z
        DEFINE h : X â†’ Z = g âˆ˜ f
        LET O : Open <<: Z, p : X, q = f(p), r = g(q)  
        ASSUME r âˆˆ O
        HAVE g^(-1)[O] : Open <<: Y USING g : Y â†’ Z
        HAVE f^(-1)[g^(-1)[O]] : Open <<: X USING f : X â†’ Y
        SHOW p âˆˆ f^(-1)[g^(-1)[O]] USING q âˆˆ g^(-1)[O] âˆ§ p âˆˆ f^(-1)[q] 
        HENCE h^(-1)[O] = f^(-1)[g^(-1)[O]] : Open <<: X
        HENCE h : X â†’ Z
    }

    THEOREM HausdorffIsT1 {
      STATEMENT:
        âˆ€ (X : HausdorffSpace). X : T1Space

      PROOF:
        LET X : HausdorffSpace, p q : X, p â‰  q  
        HAVE O1 O2 : Open, p âˆˆ O1, q âˆˆ O2, O1 âˆ© O2 = Empty USING X : HausdorffSpace
        SHOW (p âˆˆ O1 âˆ§ q âˆ‰ O1) âˆ¨ (p âˆ‰ O2 âˆ§ q âˆˆ O2) BY {
          ASSUME p âˆˆ O2
          HAVE p âˆˆ O1 âˆ© O2 USING p âˆˆ O1 âˆ§ p âˆˆ O2
          CONTRA Empty = O1 âˆ© O2
          HENCE p âˆ‰ O2  
        }
        HENCE X : T1Space
    }

    THEOREM Subspace {
      STATEMENT:
        âˆ€ (X : Space) (Y : Set <<: X). 
          Y : Space âˆ§ âˆ€ (O : Open <<: X). O âˆ© Y : Open <<: Y

      PROOF: 
        LET X : Space, Y : Set <<: X
        DEFINE Open(Y) = { O âˆ© Y | O : Open <<: X } <<: Set
        
        SHOW Open(Y) satisfies topological axioms:
          LET C : Set <<: Open(Y)
          HAVE O = { O' : Open <<: X | âˆƒ (O'' âˆˆ C). O' âˆ© Y = O'' } : Set <<: Open <<: X
          THEN Union(C) = Union(O) âˆ© Y : Open(Y)  BY OpenUnion
                Inter(C1, C2) = Inter(O1, O2) âˆ© Y : Open(Y)  âˆ€ C1 C2 âˆˆ C, O1 âˆ© Y = C1, O2 âˆ© Y = C2, BY OpenInter
                Y = Space âˆ© Y : Open(Y)  BY OpenWhole
                Empty = Empty âˆ© Y : Open(Y)  BY OpenEmpty
        
        HENCE Y : Space âˆ§ Open(Y) = { O âˆ© Y | O : Open <<: X } <<: Open <<: Set <<: Y
    }        
  }
}