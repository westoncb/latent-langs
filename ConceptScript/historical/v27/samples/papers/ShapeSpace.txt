CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(X) = Constructible subsets of X wrt O
    Shv(X, ğ’Ÿ) = Category of ğ’Ÿ-valued sheaves on X
    D^b(ğ’œ) = Bounded derived category of abelian category ğ’œ
    ğ•œ_Z = Constant sheaf valued in field ğ•œ on space Z
    
    Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}
    f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    
    PHT(M) = R(f_M)_*ğ•œ_Z_M âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    PHT^i_M = R^i(f_M)_*ğ•œ_Z_M âˆˆ Shv(ğ•Š^(d-1) Ã— â„)
    
    ECT(M)(v,t) = Ï‡(fâ»Â¹_M(v,t)) 
    BCT(M)(v,t) = [Î²_i(fâ»Â¹_M(v,t))]
    
    d_I(â„±, ğ’¢) = inf{Îµâ‰¥0 | âˆƒ Îµ-interleaving â„±â‡„_Îµğ’¢}
  }

  LANGUAGE {
    TYPE Shape = Constructible subset of â„^d
    TYPE Direction = Unit vector in ğ•Š^(d-1)
    TYPE PHT = D^b(Shv(ğ•Š^(d-1) Ã— â„))
    TYPE Cover = Collection of inclusions {M_i â†ª M}
    
    FUNC Sublevel(M: Shape, v: Direction, t: â„): Shape =
      {x âˆˆ M | xÂ·v â‰¤ t}
    
    FUNC Dgm(i: Int, M: Shape, v: Direction) =
      Persistence diagram of PHT^i_M restricted to {v}Ã—â„
     
    PRED IsInterleaving(Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„±, Îµ: â„â‰¥0) =
      Ï•Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ ÏˆÏ•_Îµ âˆ¼ â„±_2Îµ
      
    PRED FiniteCover(ğ“’: Cover, M: Shape) = â‹ƒğ“’ = M âˆ§ ğ“’ is finite
      
    AXIOM Descent: âˆ€ M: Shape, ğ“’: Cover . FiniteCover(ğ“’,M) â‡’  
      PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
                         M_iâˆˆğ“’      |I|=2          
  }
  
  STRUCTURES {
    STRUCTURE PHTSheaf {
      FIELD Sections(M: Shape): PHT = PHT(M)
      FIELD Restriction(Î¹: M â†ª N): PHT(N) â†’ PHT(M)
    }
  }

  TRANSFORMERS {
    REWRITE ShiftPHT(Îµ: â„â‰¥0): 
      PHT(M) â†’ PHT_Îµ(M) := R(f_M_Îµ)_*ğ•œ_Z_M_Îµ
      WHERE Z_M_Îµ = {(x,v,t)âˆˆMÃ—ğ•Š^(d-1)Ã—â„ | xÂ·vâ‰¤t+Îµ}
      
    SIMPLIFY DecomposePHT: 
      PHT^n(M) â†’ H^n[ â¨ PHTâ°(M_I) â†’ â¨ PHTâ°(M_I) â†’ â‹¯ ]
                     |I|=1          |I|=2
      IF M triangulated by {Ïƒ_i}
      
    TACTIC SimplifyInterleaving:
      â„± =[Îµ]= ğ’¢ â‡” âˆƒ Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„± . 
        Ï•Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ ÏˆÏ•_Îµ âˆ¼ â„±_2Îµ 
  }  

  PROOFS {
    PROOF PHTDeterminesShape: PHT(M) â‰ƒ PHT(N) â‡’ M â‰ƒ N
    {
      PHT(M) â‰ƒ PHT(N)
      â‡’ âˆ€i. PHT^i_M â‰ƒ PHT^i_N                  BY def
      â‡’ BCT_M = BCT_N                          BY def
      â‡’ ECT_M = âˆ‘_i (-1)^i PHT^i_M              
             â‰ƒ âˆ‘_i (-1)^i PHT^i_N = ECT_N      BY Euler
      â‡’ M â‰ƒ N                                  BY Schapira 
    }
    
    PROOF PHTDescentTheorem:
      âˆ€ M: Shape, ğ“’: Cover . FiniteCover(ğ“’,M) â‡’ 
      PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
    {
      SUFFICES_TO_SHOW 
        PHT(M) â†’ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ] 
      is a quasi-isomorphism.
    
      DEFINE Godement resolution:
        k_Z_M â†’ [ â¨ k_Z_(M_i) â†’ â¨ k_Z_(M_I) â†’ â‹¯ ]
                   |I|=1          |I|=2
                
      APPLY R(f_M)_* to get quasi-isomorphism:              
        PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
        
      CHECK quasi-iso on stalks by:
        H^*(PHT(M)(v,t)) â‰ƒ H^*(f^(-1)_M(v,t))        
                         â‰ƒ H^*(holim[ âˆ f^(-1)_(M_i)(v,t) â‡’ â‹¯ ])
    }  

    PROOF PHTStability: 
      d_I(PHT(M), PHT(N)) â‰¤ Îµ if M â‰ƒ_Îµ N  
    {
      GIVEN Îµ-homotopy equivalence Ï•: M â†’ N, Ïˆ: N â†’ M:
        â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆM, â€–y-Ïˆ(y)â€– â‰¤ Îµ âˆ€yâˆˆN
        homotopies H_M: idx âˆ¼ ÏˆÏ•, H_N: idy âˆ¼ Ï•Ïˆ  
        moving points by â‰¤ 2Îµ
        
      DEFINE Ï•_*: PHT(M)_Îµ â†’ PHT(N), Ïˆ_*: PHT(N)_Îµ â†’ PHT(M):
        Ï•_*(x,v,t) := (Ï•(x),v,t+Îµ)
        Ïˆ_*(y,v,t) := (Ïˆ(y),v,t+Îµ)
        
      PROVE (Ï•_*, Ïˆ_*) is an Îµ-interleaving:
        Ïˆ_*Ï•_* âˆ¼ PHT(M)_2Îµ â†’ PHT(M) via ÏˆÏ• : Z_M â†’ Z_M on Z_M_2Îµ
        Ï•_*Ïˆ_* âˆ¼ PHT(N)_2Îµ â†’ PHT(N) via Ï•Ïˆ : Z_N â†’ Z_N on Z_N_2Îµ
        
      â‡’ d_I(PHT(M), PHT(N)) â‰¤ Îµ  BY SimplifyInterleaving 
    }  

    PROOF PHTApproximation:
      d_I(PHT(M),PHT(K)) â‰¤ CÎµ w.h.p. for C=O(1) 
    {
      GIVEN M: n-manifold, Ï„: condition number, Îµ<Ï„/2, {x_i}âŠ‚M: (Îµ/2)-dense
      DEFINE U := â‹ƒ_i B_Îµ(x_i), K := AlphaComplex(U)
      
      M â‰ƒ U w.p. â‰¥ 1-Î´   BY NiyogiSmaleWeinberger since Îµ < Ï„/2 
      U â‰ƒ K              BY NerveTheorem
      
      â‡’ âˆƒ Îµ-htpy equiv Ï•: K â†’ M, Ïˆ: M â†’ K with: 
           â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆK, â€–y-Ïˆ(y)â€– â‰¤ 2Îµ âˆ€yâˆˆM
           homotopies H_K: idx âˆ¼ Ï•Ïˆ, H_M: idy âˆ¼ ÏˆÏ•  
           moving points by â‰¤ 2Îµ
           
      â‡’ d_I(PHT(M),PHT(K)) â‰¤ CÎµ w.h.p. BY PHTStability
    }
  }

  EXAMPLES {
    EXAMPLE PHTofCircle: 
      PHT(S^1)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]

    EXAMPLE PHTofAnnulus:
      PHT(Ann)(v,t) â‰ƒ IF tâ‰¤r THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(r,R) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]  
      WHERE Ann = {x | râ‰¤â€–xâ€–â‰¤R}

    EXAMPLE PHTofTorus: 
      PHT(ğ•‹Â²)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE
                      IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1]âŠ•ğ•œ[1] ELSE 
                      IF tâ‰¥1 THEN ğ•œ[0]âŠ•ğ•œ[2] ELSE 0
  }
}


CONCEPT NeuroTopology EXTENDS ShapeSpace{
  NOTATION {
    Brain = (M, g) WHERE M âŠ† â„^3 âˆ§ g : M Ã— M â†’ â„â‰¥0
    Connectome = (V, E) WHERE V âŠ† Brain âˆ§ E âŠ† V Ã— V
    Tract = Î³: [0,1] â†’ Brain
    TractographyData = {(S_i, v_i) âˆˆ Brain Ã— â„^3}
    PointCloud(N,d) = {{x_i âˆˆ â„^d}}_i^N
    BrainRegion(A) = {U âŠ† M | A(U) = 1} WHERE A: ğ“Ÿ(M) â†’ {0,1}
    PHT = F âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    PHTBrain = PHT(Brain) := R(f_Brain)_*ğ•œ_Z_Brain
    Disease = {(Brain_i, y_i) âˆˆ Brain Ã— {0,1}}
    d_I(P,Q) = inf{Îµâ‰¥0 | âˆƒ Ï•: P_Îµâ†’Q, Ïˆ: Q_Îµâ†’P . Ï•Ïˆâˆ¼Q_2Îµ âˆ§ ÏˆÏ•âˆ¼P_2Îµ}
    Î¼_H(K) = inf{âˆ‘_i diam(U_i)^d | K âŠ† â‹ƒ_i U_i} WHERE K âŠ† â„^d compact
  }
  
  LANGUAGE {
    TYPE BrainModel = (M, g) WHERE M âˆˆ CS(â„^3)
    TYPE ConnectomeModel = (V, E) WHERE V = PointCloud(N,3)
    TYPE TractModel = PointCloud(N,3) | (M, g) WHERE M âˆˆ CS(â„^3)
    TYPE BrainAtlas = A: ğ“Ÿ(M) â†’ {0,1}
    TYPE BrainPHT = F âˆˆ D^b(Shv(ğ•Š^2 Ã— â„))

    FUNC ConstructTractModel(D: TractographyData, Î´: â„â‰¥0): TractModel =
      {(x,y) âˆˆ D | â€–vâ€– â‰¥ Î´} â†¦ x, Closure(â‹ƒ_{(x,v) âˆˆ D} Î³_((x,v),Î´))
      WHERE Î³_((x,v),Î´)(t) := x + tÂ·v/Î´
    
    FUNC PartitionBrain(M: BrainModel, A: BrainAtlas): Labeled<BrainModel> =
      {(a, (M âˆ© a, g|_(M âˆ© a))) for a âˆˆ BrainRegion(A)}
    
    FUNC PHTBrainModel(D: Disease): BrainPHT =
      R(f_M)_*ğ•œ_Z_M WHERE (M,_) := ConstructBrainModel(Ï€_1(D))

    FUNC PHTBrainSegmentation(B: BrainPHT, S: Labeled<BrainModel>):
         Labeled<BrainPHT> =
      {(s, R(f_M)_*ğ•œ_Z_M) for (s,(M,_)) âˆˆ S}  
      
    PRED IsSignal(P: BrainPHT, Q: BrainPHT, Îµ: â„â‰¥0) = d_I(P, Q) > Îµ   
  }

  STRUCTURES {
    STRUCTURE BrainPHT EXTENDS PHTSheaf {
      FIELD Connectome: ConnectomeModel
      FIELD TractModel: TractModel
      FIELD RegionPHTs: Labeled<BrainPHT>

      COMPUTE LocalPHT(r: BrainRegion): PHTSheaf = 
        R(f_(Mâˆ©r))_*ğ•œ_Z_(Mâˆ©r) WHERE (M,_) := this.GeometricModel
      
      COMPUTE ConnectomePHT: PHTSheaf =
        PHT(ShapeModel(this.Connectome))
        
      COMPUTE TractPHT: PHTSheaf = 
        PHT(this.TractModel)  
    }
  }
  
  TRANSFORMERS {
    REWRITE BrainSegmentation(B: BrainPHT, A: BrainAtlas):
      B -> PHTBrainSegmentation(B, PartitionBrain(B.GeometricModel, A))
      
    REWRITE ConnectivityShift(C: ConnectomeModel, Îµ: â„â‰¥0):
      (V,E) -> (V, E âˆª {(u,v) âˆˆ VÃ—V \ E with prob Îµ} \ {(u,v) âˆˆ E with prob Îµ})
      
    TACTIC DiseaseBiomarker(D: Disease, Îµ: â„â‰¥0):
      1. {B_i} := {PHTBrainModel(D_y=1) for i in SampleSize(D_y=1)}
      2. {C_i} := {PHTBrainModel(D_y=0) for i in SampleSize(D_y=0)}
      3. F := LearnClassifier({B_i}, {C_i}) minimizing TrainLoss
      4. RETURN F IF TestLoss(F) â‰¤ Îµ ELSE FAIL
  }
  
  PROOFS {
    THEOREM RegionStability: 
      âˆ€ r1, r2 âˆˆ BrainRegion(A) . d_H(r1, r2) â‰¤ Îµ â‡’ d_I(PHT(r1), PHT(r2)) â‰¤ CÎµ  
    {
      GIVEN r1, r2 âˆˆ BrainRegion(A) with d_H(r1, r2) â‰¤ Îµ
      
      âˆƒ {U_Î±},{V_Î²} âˆˆ ğ“Ÿ(â„^3) . r1 âŠ† â‹ƒ_Î± U_Î± âˆ§ r2 âŠ† â‹ƒ_Î² V_Î² âˆ§
                                  âˆ€(x,y) âˆˆ r1Ã—r2 âˆƒ(Î±,Î²) . x âˆˆ U_Î± âˆ§ y âˆˆ V_Î² âˆ§ 
                                                            diam(U_Î± âˆª V_Î²) â‰¤ Îµ
        
      âˆ‘_Î± Î¼_H(U_Î±)^3 â‰¤ Î¼_H(r1)^3 + Îµ^3 âˆ§ âˆ‘_Î² Î¼_H(V_Î²)^3 â‰¤ Î¼_H(r2)^3 + Îµ^3
                            BY def Î¼_H and compact r1,r2
        
      â‡’ âˆƒ f: r1â†’r2 s.t. â€–x - f(x)â€– â‰¤ Îµ âˆ€x âˆˆ r1  BY {U_Î±},{V_Î²} Îµ-cover 
        AND g: r2â†’r1 s.t. â€–f(g(y)) - yâ€– â‰¤ Îµ âˆ€y âˆˆ r2
        
      â‡’ d_I(PHT(r1), PHT(r2)) â‰¤ CÎµ     BY PHTStability (ShapeSpace) 
    }

    THEOREM RobustBiomarker:
      âˆ€ M1, M2 âˆˆ BrainModel . d_I(PHT(M1), PHT(M2)) â‰¤ Îµ â‡’ 
      |F(PHT(M1)) - F(PHT(M2))| â‰¤ LÂ·Îµ    
      WHERE F: BrainPHT â†’ â„ with Lipschitz const L
    {   
      GIVEN d_I(PHT(M1), PHT(M2)) â‰¤ Îµ
      
      |F(PHT(M1)) - F(PHT(M2))| 
        â‰¤ LÂ·d_I(PHT(M1), PHT(M2))     BY F L-Lipschitz
        â‰¤ LÂ·Îµ                         BY GIVEN
    }
    
    THEOREM SegmentationStability:
      âˆ€ A1, A2: BrainAtlas . d_H(BrainRegion(A1), BrainRegion(A2)) â‰¤ Îµ â‡’ 
      d_I(PHTBrainSegmentation(B,A1), PHTBrainSegmentation(B,A2)) â‰¤ C(B)Â·Îµ  
    {
      GIVEN d_H(BrainRegion(A1),BrainRegion(A2)) â‰¤ Îµ, 
        SHOW PHT segmentations C(B)Â·Îµ-close. 
      
      âˆ€ r1 âˆˆ BrainRegion(A1), âˆƒ r2 âˆˆ BrainRegion(A2) . d_H(r1, r2) â‰¤ Îµ   
        BY d_H(BrainRegion(A1),BrainRegion(A2)) â‰¤ Îµ
      â‡’ d_I(PHT(Mâˆ©r1),PHT(Mâˆ©r2)) â‰¤ C(M|_r1)Â·Îµ   BY RegionStability
      â‡’ d_I(PHT(Mâˆ©r1),PHT(Mâˆ©r2)) â‰¤ C(M)Â·C(r1)Â·Îµ BY Lipschitz(PHT)
      â‡’ MaxRegionDI â‰¤ C(B)Â·MaxRegionHD â‰¤ C(B)Â·Îµ 
        WHERE MaxRegionDI := max_(r1,r2) d_I(PHT(Mâˆ©r1),PHT(Mâˆ©r2)),
              MaxRegionHD := max_(r1,r2) d_H(r1,r2),
              C(B) := max_r C(B.GeometricModel|_r)
               
      â‡’ d_I(PHTBrainSegmentation(B,A1), PHTBrainSegmentation(B,A2))
        = max_r d_I(PHTSheaf(B.GeometricModelâˆ©r1), PHTSheaf(B.GeometricModelâˆ©r2)) 
        â‰¤ C(B)Â·Îµ   
    }
  }

  EXAMPLES {    
    EXAMPLE AlzheimersDisease:
      - D_AD := {(Brain_i, 1) | i âˆˆ PatientIDs(Alzheimers)}
      - D_HC := {(Brain_i, 0) | i âˆˆ PatientIDs(HealthyControl)}
      - B_AD := {PHTBrainModel((Brain_i,1)) | (Brain_i,1) âˆˆ D_AD}
      - B_HC := {PHTBrainModel((Brain_i,0)) | (Brain_i,0) âˆˆ D_HC}
      - F := DiseaseBiomarker(D_AD âˆª D_HC, Îµ)
      - EVAL TestLoss(F) â‰¤ Îµ ? "AD Biomarker FOUND" : "AD Biomarker NOT FOUND"
      
    EXAMPLE SchizophreniaSubtyping:
      - D_SZ := {(Brain_i, 1) | i âˆˆ PatientIDs(Schizophrenia)}
      - M := ConstructBrainModel âˆ˜ Ï€_1(D_SZ)  -- {M_i | Brain_i âˆˆ Ï€_1(D_SZ)}
      - B := PHTBrainModel âˆ˜ M  -- {PHTBrainModel(M_i) | M_i âˆˆ M}
      - A := ConstructBrainAtlas(Schizophrenia)
      - R := â‹ƒ_{B_i âˆˆ B} PHTBrainSegmentation(B_i, A)
      - {S_j | j âˆˆ [NumSubtypes]} := SpectralClustering(R, NumSubtypes)
      - {T_j | j âˆˆ [NumSubtypes]} := {TopologicalFeatures âˆ˜ S_j | j âˆˆ [NumSubtypes]}
      - RETURN ({S_j | j âˆˆ [NumSubtypes]}, VisualizePHTSpace âˆ˜ {T_j | j âˆˆ [NumSubtypes]})
      
    EXAMPLE NeurodevelopmentModel:
      - D := {(Brain_i, AgeInWeeks_i) | i âˆˆ SubjectIDs(InfantCohort)}
      - T := â‹ƒ_{AgeInWeeks_i âˆˆ Ï€_2(D)} AgeInWeeks_i  -- All timepoints
      - M := {ConstructBrainModel(Brain_i) | (Brain_i,_) âˆˆ D}  
      - B := {PHTBrainModel(M_i) | M_i âˆˆ M}
      - PHTBrainDevelopment := GeodesicInterpolation(B, T)
      - RETURN (B, PHTBrainDevelopment, AnimatePHTBrain âˆ˜ PHTBrainDevelopment)
  }
}


CONCEPT AlzheimersDisease EXTENDS NeuroTopology {
  NOTATION {
    AD = AlzheimersDisease
    HC = HealthyControl
    MCI = MildCognitiveImpairment
    MMSE = MiniMentalStateExamination
    APOE = ApolipoproteinE
    AÎ² = AmyloidBeta
    Ï„ = TauProtein
    D_AD = {(Brain_i, Diagnosis_i, MMSE_i, APOE_i) | i âˆˆ PatientIDs(AD)}
    D_HC = {(Brain_i, Diagnosis_i, MMSE_i, APOE_i) | i âˆˆ PatientIDs(HC)}
    D_MCI = {(Brain_i, Diagnosis_i, MMSE_i, APOE_i) | i âˆˆ PatientIDs(MCI)}
  }

  LANGUAGE {
    FUNC ConstructADModel(D: {(Brain, Diagnosis, MMSE, APOE)}): BrainModel =
      ConstructBrainModel âˆ˜ Ï€_1(D)

    FUNC ADStaging(D: {(Brain, Diagnosis, MMSE, APOE)}): [HC, MCI, AD] =
      MATCH Diagnosis WITH
      | HC => HC
      | MCI => MCI
      | AD => AD

    FUNC ADProgression(B_HC: BrainPHT, B_MCI: BrainPHT, B_AD: BrainPHT):
         (BrainPHT â†’ â„) =
      Î»B . âˆ‘_i w_i Â· d_I(B, B_i) WHERE 
        [w_HC, w_MCI, w_AD] = [1, 2, 3] AND
        [B_HC, B_MCI, B_AD] = [mean(B_HC), mean(B_MCI), mean(B_AD)]
        
    PRED IsADProgressing(B_t1: BrainPHT, B_t2: BrainPHT, Î´: â„â‰¥0) = 
      ADProgression(B_HC, B_MCI, B_AD)(B_t2) - 
      ADProgression(B_HC, B_MCI, B_AD)(B_t1) > Î´
  }

  STRUCTURES {
    STRUCTURE ADCohort EXTENDS {(Brain, Diagnosis, MMSE, APOE)} {
      FIELD D_AD: {(Brain, Diagnosis, MMSE, APOE)}
      FIELD D_HC: {(Brain, Diagnosis, MMSE, APOE)}
      FIELD D_MCI: {(Brain, Diagnosis, MMSE, APOE)}
      
      COMPUTE ADModels: [BrainModel] =
        MAP(ConstructADModel, [D_AD, D_HC, D_MCI])
        
      COMPUTE ADStages: [HC, MCI, AD] =
        MAP(ADStaging, [D_HC, D_MCI, D_AD])
        
      COMPUTE ADPHTs: [BrainPHT] = 
        MAP(PHTBrainModel, ADModels)
    }
  }

  THEOREMS {
    THEOREM ADProgressionMonotonic:
      âˆ€ B_HC, B_MCI, B_AD: BrainPHT .
      mean(d_I(B_HC, B_MCI)) < mean(d_I(B_HC, B_AD)) âˆ§
      mean(d_I(B_MCI, B_AD)) < mean(d_I(B_HC, B_AD))
    {
      GIVEN B_HC, B_MCI, B_AD as mean BrainPHTs for each AD stage
      
      mean(d_I(B_HC, B_AD))
        = mean_{i,j} d_I(B_HC_i, B_AD_j)
        = mean_i(mean_j d_I(B_HC_i, B_AD_j))          BY Fubini
       >= mean_i(d_I(B_HC_i, mean(B_AD)))             BY Jensen
        = mean_i(d_I(B_HC_i, B_AD))
        > mean_i(d_I(B_HC_i, B_MCI))                  BY GIVEN
        
      SIMILARLY FOR mean(d_I(B_MCI, B_AD)) < mean(d_I(B_HC, B_AD))
    }
    
    THEOREM ADProgressionRobust:
      âˆ€ C1, C2: ADCohort . d_I(C1.ADPHTs, C2.ADPHTs) â‰¤ Îµ â‡’
      âˆ€ B âˆˆ C1.D_AD âˆª C1.D_MCI . 
      |ADProgression(C1.ADPHTs)(B) - ADProgression(C2.ADPHTs)(B)| â‰¤ LÂ·Îµ
    {
      GIVEN d_I(C1.ADPHTs, C2.ADPHTs) â‰¤ Îµ
      
      |ADProgression(C1.ADPHTs)(B) - ADProgression(C2.ADPHTs)(B)|
        = |âˆ‘_i w_iÂ·(d_I(B,C1.B_i) - d_I(B,C2.B_i))|
       <= âˆ‘_i w_iÂ·|d_I(B,C1.B_i) - d_I(B,C2.B_i)|     BY triangle ineq
       <= âˆ‘_i w_iÂ·d_I(C1.B_i, C2.B_i)                 BY d_I triangle ineq
       <= (âˆ‘_i w_i)Â·max_i d_I(C1.B_i, C2.B_i)
        = LÂ·d_I(C1.ADPHTs, C2.ADPHTs)                 BY def of d_I on [BrainPHT]
       <= LÂ·Îµ                                         BY GIVEN
    }
  }
    
  EXAMPLES {
    EXAMPLE ADDetection:
      - C := ConstructADCohort(D_AD, D_HC, D_MCI)
      - B_AD, B_HC, B_MCI := C.ADPHTs
      - F := DiseaseBiomarker(C.D_AD âˆª C.D_HC, Îµ)
      - EVAL TestLoss(F) â‰¤ Îµ ? "AD Biomarker FOUND" : "AD Biomarker NOT FOUND"
    
    EXAMPLE ADStaging:
      - C := ConstructADCohort(D_AD, D_HC, D_MCI)
      - B_AD, B_HC, B_MCI := C.ADPHTs
      - S := Î»B . ArgMax([(d_I(B,B_HC), HC), 
                          (d_I(B,B_MCI), MCI), 
                          (d_I(B,B_AD), AD)])
      - EVAL MEAN(S(B) == Diagnosis for (B,Diagnosis,_,_) âˆˆ C.D_AD âˆª C.D_MCI)
      
    EXAMPLE ADProgression:
      - C := ConstructADCohort(D_AD, D_HC, D_MCI)
      - B_AD, B_HC, B_MCI := C.ADPHTs  
      - P := ADProgression(B_HC, B_MCI, B_AD)
      - t1, t2 := 0, 1  -- Timepoints
      - B_t1, B_t2 := PHTBrainModel(B_t1), PHTBrainModel(B_t2)
      - EVAL IsADProgressing(B_t1, B_t2, Î´) ? 
             "AD is progressing" : "AD is stable"
  }
}


CONCEPT ShapeSpaceParadigmShift {
  NOTATION {
    ShapeSpace = CS(â„^d)^op â†’ D^b(Shv(ğ•Š^(d-1)Ã—â„))
    PHT = Persistent Homology Transform
    ECT = Euler Characteristic Transform
    CS(â„^d) = Constructible subsets of â„^d
    OldShapeSpaces = {Kendall, LDDMM, ElasticShape, ...}
  }

  LANGUAGE {
    TYPE MemeticShift = Transformation of research landscape  
    TYPE ScientificParadigm = Coherent framework of concepts, methods, questions
    TYPE ShapeRepresentation = Encoding of shape information
    TYPE ShapeMatching = Technique for comparing shapes
    TYPE TopologicalInvariant = Algebraic structure capturing shape features
    
    FUNC ShapesToPHT: CS(â„^d) â†’ D^b(Shv(ğ•Š^(d-1)Ã—â„)) = 
      M â†¦ PHT(M) := R(f_M)_*ğ•œ_Z_M
      
    PRED IsMemetic(S: ScientificParadigm) = 
      S spreads rapidly via idea sharing and adoption
      
    PRED IsCoherent(S: ScientificParadigm) =
      Concepts, methods, questions of S are logically integrated
      
    AXIOM NewAnswersToOldProblems:  
      âˆ€ P: ShapeMatching, âˆƒ T: TopologicalInvariant . PHT enables T-based solution to P
      
    AXIOM NewQuestionsAndApplications: PHT motivates novel
      problems and use cases beyond scope of OldShapeSpaces
  }
  
  STRUCTURES {
    STRUCTURE PHTShapeSpace EXTENDS ScientificParadigm {
      FIELD Representation: ShapeRepresentation = PHT
      FIELD Comparison: ShapeMatching = Interleaving distance on PHT
      FIELD UnifyingConcept: TopologicalInvariant = Sheaf theory
      FIELD CanonicalConstruction: CS(â„^d) â†’ ShapeSpace = ShapesToPHT
      FIELD TheoreticalFoundation: PROOFS
      FIELD ComputationalTools: TRANSFORMERS
    }
  }
   
  TRANSFORMERS {    
    REWRITE OldToNew: 
      ShapeMatching<OldRep> â†’ ShapeMatching<PHT>
      
    TACTIC ApplicationPattern:
      1. Construct M: CS(â„^d) model of data
      2. Compute PHT(M) 
      3. Apply ShapeMatching, TRANSFORMERS to PHT(M) for analysis    
  }
   
  PROOFS {
    PROOF PHTAdvantage: PHTShapeSpace is a MemeticShift 
    {      
      PHTShapeSpace is a coherent paradigm shifting shape analysis:
        - Sheaf-theoretic language unifies local and global shape via PHT
        - PHT a complete invariant, generalizing ECT, with stability and approximation 
        - Interleaving a stable, discriminative shape comparison
        - Sheaf and derived category theory provide powerful computational tools
        - Enables topological approaches to a range of new and old shape problems
        
      â‡’ PHTShapeSpace answers open challenges in OldShapeSpaces
      â‡’ PHTShapeSpace opens up new problems and applications
      
      PHTShapeSpace spreads memetically: 
        - Requires only mild condition of constructibility on shapes
        - Categorical foundations enable integration with other mathematical theories
        - Computational tools facilitate applications and empirical studies
        - Stimulates research via new questions and cross-disciplinary connections
        
    }
  } 
   
  EXAMPLES {
    EXAMPLE NeuroTopology: 
      - Model M := Brain tractography network âˆˆ CS(â„^3)
      - Compute PHT(M) to get topological barcode of brain structure  
      - Apply k-means to {PHT(M_i)} for disease subtyping
      
    EXAMPLE ProteinTopology:
      - Model M := Protein structure âˆˆ CS(â„^3)  
      - Compute PHT(M) to get sheaf of topological features
      - Use PHT<->Geometry TRANSFORMERS to characterize folding dynamics
      
    EXAMPLE EvolutionaryTopology:
      - Model M := Bone surfaces âˆˆ CS(â„^3) across species 
      - Use PHTApproximation to estimate PHT(M) from CT scans
      - Apply PHTStability to compare evolutionary changes 
  }
}

CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(X) = Constructible subsets of X wrt O
    Shv(X, ğ’Ÿ) = Category of ğ’Ÿ-valued sheaves on X
    D^b(ğ’œ) = Bounded derived category of abelian category ğ’œ
    ğ•œ_Z = Constant sheaf valued in field ğ•œ on space Z
    
    Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}
    f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    
    PHT(M) = R(f_M)_*ğ•œ_Z_M âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    PHT^i_M = R^i(f_M)_*ğ•œ_Z_M âˆˆ Shv(ğ•Š^(d-1) Ã— â„)
    
    ECT(M)(v,t) = Ï‡(fâ»Â¹_M(v,t)) 
    BCT(M)(v,t) = [Î²_i(fâ»Â¹_M(v,t))]
    
    d_I(â„±, ğ’¢) = inf{Îµâ‰¥0 | âˆƒ Îµ-interleaving â„±â‡„_Îµğ’¢}
  }

  LANGUAGE {
    TYPE Shape = Constructible subset of â„^d
    TYPE Direction = Unit vector in ğ•Š^(d-1)
    TYPE PHT = D^b(Shv(ğ•Š^(d-1) Ã— â„))
    TYPE Cover = Collection of inclusions {M_i â†ª M}
    
    FUNC Sublevel(M: Shape, v: Direction, t: â„): Shape =
      {x âˆˆ M | xÂ·v â‰¤ t}
    
    FUNC Dgm(i: Int, M: Shape, v: Direction) =
      Persistence diagram of PHT^i_M restricted to {v}Ã—â„
     
    PRED IsInterleaving(Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„±, Îµ: â„â‰¥0) =
      Ï•Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ ÏˆÏ•_Îµ âˆ¼ â„±_2Îµ
      
    PRED FiniteCover(ğ“’: Cover, M: Shape) = â‹ƒğ“’ = M âˆ§ ğ“’ is finite
      
    AXIOM Descent: âˆ€ M: Shape, ğ“’: Cover . FiniteCover(ğ“’,M) â‡’  
      PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
                         M_iâˆˆğ“’      |I|=2          
  }
  
  STRUCTURES {
    STRUCTURE PHTSheaf {
      FIELD Sections(M: Shape): PHT = PHT(M)
      FIELD Restriction(Î¹: M â†ª N): PHT(N) â†’ PHT(M)
    }
  }

  TRANSFORMERS {
    REWRITE ShiftPHT(Îµ: â„â‰¥0): 
      PHT(M) â†’ PHT_Îµ(M) := R(f_M_Îµ)_*ğ•œ_Z_M_Îµ
      WHERE Z_M_Îµ = {(x,v,t)âˆˆMÃ—ğ•Š^(d-1)Ã—â„ | xÂ·vâ‰¤t+Îµ}
      
    SIMPLIFY DecomposePHT: 
      PHT^n(M) â†’ H^n[ â¨ PHTâ°(M_I) â†’ â¨ PHTâ°(M_I) â†’ â‹¯ ]
                     |I|=1          |I|=2
      IF M triangulated by {Ïƒ_i}
      
    TACTIC SimplifyInterleaving:
      â„± =[Îµ]= ğ’¢ â‡” âˆƒ Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„± . 
        Ï•Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ ÏˆÏ•_Îµ âˆ¼ â„±_2Îµ 
  }  

  PROOFS {
    PROOF PHTDeterminesShape: PHT(M) â‰ƒ PHT(N) â‡’ M â‰ƒ N
    {
      PHT(M) â‰ƒ PHT(N)
      â‡’ âˆ€i. PHT^i_M â‰ƒ PHT^i_N                  BY def
      â‡’ BCT_M = BCT_N                          BY def
      â‡’ ECT_M = âˆ‘_i (-1)^i PHT^i_M              
             â‰ƒ âˆ‘_i (-1)^i PHT^i_N = ECT_N      BY Euler
      â‡’ M â‰ƒ N                                  BY Schapira 
    }
    
    PROOF PHTDescentTheorem:
      âˆ€ M: Shape, ğ“’: Cover . FiniteCover(ğ“’,M) â‡’ 
      PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
    {
      SUFFICES_TO_SHOW 
        PHT(M) â†’ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ] 
      is a quasi-isomorphism.
    
      DEFINE Godement resolution:
        k_Z_M â†’ [ â¨ k_Z_(M_i) â†’ â¨ k_Z_(M_I) â†’ â‹¯ ]
                   |I|=1          |I|=2
                
      APPLY R(f_M)_* to get quasi-isomorphism:              
        PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
        
      CHECK quasi-iso on stalks by:
        H^*(PHT(M)(v,t)) â‰ƒ H^*(f^(-1)_M(v,t))        
                         â‰ƒ H^*(holim[ âˆ f^(-1)_(M_i)(v,t) â‡’ â‹¯ ])
    }  

    PROOF PHTStability: 
      d_I(PHT(M), PHT(N)) â‰¤ Îµ if M â‰ƒ_Îµ N  
    {
      GIVEN Îµ-homotopy equivalence Ï•: M â†’ N, Ïˆ: N â†’ M:
        â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆM, â€–y-Ïˆ(y)â€– â‰¤ Îµ âˆ€yâˆˆN
        homotopies H_M: idx âˆ¼ ÏˆÏ•, H_N: idy âˆ¼ Ï•Ïˆ  
        moving points by â‰¤ 2Îµ
        
      DEFINE Ï•_*: PHT(M)_Îµ â†’ PHT(N), Ïˆ_*: PHT(N)_Îµ â†’ PHT(M):
        Ï•_*(x,v,t) := (Ï•(x),v,t+Îµ)
        Ïˆ_*(y,v,t) := (Ïˆ(y),v,t+Îµ)
        
      PROVE (Ï•_*, Ïˆ_*) is an Îµ-interleaving:
        Ïˆ_*Ï•_* âˆ¼ PHT(M)_2Îµ â†’ PHT(M) via ÏˆÏ• : Z_M â†’ Z_M on Z_M_2Îµ
        Ï•_*Ïˆ_* âˆ¼ PHT(N)_2Îµ â†’ PHT(N) via Ï•Ïˆ : Z_N â†’ Z_N on Z_N_2Îµ
        
      â‡’ d_I(PHT(M), PHT(N)) â‰¤ Îµ  BY SimplifyInterleaving 
    }  

    PROOF PHTApproximation:
      d_I(PHT(M),PHT(K)) â‰¤ CÎµ w.h.p. for C=O(1) 
    {
      GIVEN M: n-manifold, Ï„: condition number, Îµ<Ï„/2, {x_i}âŠ‚M: (Îµ/2)-dense
      DEFINE U := â‹ƒ_i B_Îµ(x_i), K := AlphaComplex(U)
      
      M â‰ƒ U w.p. â‰¥ 1-Î´   BY NiyogiSmaleWeinberger since Îµ < Ï„/2 
      U â‰ƒ K              BY NerveTheorem
      
      â‡’ âˆƒ Îµ-htpy equiv Ï•: K â†’ M, Ïˆ: M â†’ K with: 
           â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆK, â€–y-Ïˆ(y)â€– â‰¤ 2Îµ âˆ€yâˆˆM
           homotopies H_K: idx âˆ¼ Ï•Ïˆ, H_M: idy âˆ¼ ÏˆÏ•  
           moving points by â‰¤ 2Îµ
           
      â‡’ d_I(PHT(M),PHT(K)) â‰¤ CÎµ w.h.p. BY PHTStability
    }
  }

  EXAMPLES {
    EXAMPLE PHTofCircle: 
      PHT(S^1)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]

    EXAMPLE PHTofAnnulus:
      PHT(Ann)(v,t) â‰ƒ IF tâ‰¤r THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(r,R) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]  
      WHERE Ann = {x | râ‰¤â€–xâ€–â‰¤R}

    EXAMPLE PHTofTorus: 
      PHT(ğ•‹Â²)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE
                      IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1]âŠ•ğ•œ[1] ELSE 
                      IF tâ‰¥1 THEN ğ•œ[0]âŠ•ğ•œ[2] ELSE 0
  }
}












CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(X) = Constructible subsets of X with respect to O
    Shv(X, ğ’Ÿ) = Category of ğ’Ÿ-valued sheaves on X  
    D^b(ğ’œ) = Bounded derived category of abelian category ğ’œ
    ğ•œ_Z = Constant sheaf valued in field ğ•œ on space Z
    
    Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}
    f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    
    PHT(M) = R(f_M)_*ğ•œ_Z_M âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    PHT^i_M(v,t) = H^i(fâ»Â¹_M(v,t))
    
    ECT(M)(v,t) = Ï‡(fâ»Â¹_M(v,t)) = âˆ‘_i (-1)^i dim PHT^i_M(v,t)
    BCT(M)(v,t) = [Î²_i(fâ»Â¹_M(v,t))] = [dim PHT^i_M(v,t)]
    
    ğ“’(M) = {M_i â†ª M} = Finite closed covers of M âˆˆ CS(â„^d)
    Nerve(ğ“’, â„±) = [[â„±(M_i)]â†’[â„±(M_I)|I|=2]â†’...] âˆˆ Ch(Vect_ğ•œ)
    
    d_I(â„±,ğ’¢) = inf {Îµâ‰¥0 | âˆƒ Îµ-interleaving â„±â‡„_Îµğ’¢}
    d^(PHT_i)_(p,q)(M,N) = â€–W_p(PHT^i_M, PHT^i_N)â€–_L^q(ğ•Š^(d-1))
  }

  LANGUAGE {
    TYPE Shape = Constructible subset of â„^d  
    TYPE Direction = Unit vector in ğ•Š^(d-1)
    TYPE Cover = Finite set of inclusions {M_i â†ª M}
    
    FUNC SubLevel(M: Shape, v: Direction, t: â„): Shape =
      {x âˆˆ M | xÂ·v â‰¤ t}
    
    FUNC DerivedPHT(M: Shape): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = 
      R(f_M)_*ğ•œ_Z_M
    
    FUNC SheafPHT(M: Shape): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ^(d+1)) =
      (v,t) â†¦ [H^i(fâ»Â¹_M(v,t)) for 0â‰¤iâ‰¤d]
      
    FUNC MapPHT(M: Shape): ğ•Š^(d-1) â†’ Dgm^d =
      v â†¦ (Dgm(PH^0_M(v)), ..., Dgm(PH^(d-1)_M(v))) 
      
    FUNC ECT(M: Shape): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ) = 
      (v,t) â†¦ âˆ‘_i (-1)^i dim PHT^i_M(v,t)
      
    FUNC BCT(M: Shape): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ^(d+1)) =
      (v,t) â†¦ [dim PHT^i_M(v,t) for 0â‰¤iâ‰¤d]
      
    PRED IsInterleaving(Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„±, Îµ: â„â‰¥0) =
      Ï•âˆ˜Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ Ïˆâˆ˜Ï•_Îµ âˆ¼ â„±_2Îµ  
  }
  
  STRUCTURES {
    STRUCTURE PHTSheaf {
      FIELD Sections(M: Shape): 
        D^b(Shv(ğ•Š^(d-1) Ã— â„)) = PHT(M)
      FIELD Restriction(M â†ª N): PHT(N) â†’ PHT(M) 
      AXIOM DescentCompatibility: 
        âˆ€ M: Shape, ğ“’: ğ“’(M),
        PHT(M) â‰ƒ holim Nerve(ğ“’, PHT|_ğ“’) 
    }
  }

  TRANSFORMERS {  
    REWRITE ShiftPHT(Îµ: â„â‰¥0)(M: Shape):
      PHT(M) â†’ PHT_Îµ(M) := R(f_M_Îµ)_*ğ•œ_Z_M_Îµ
      WHERE Z_M_Îµ = {(x,v,t)âˆˆMÃ—ğ•Š^(d-1)Ã—â„ | xÂ·vâ‰¤t+Îµ}
      
    REWRITE ShiftLeft(i: â„•):
      R^(i+1)(f_M)_*ğ•œ_Z_M â†’ [R^i(f_M)_*ğ•œ_Z_M â†’ R^i(f_M_Îµ)_*ğ•œ_Z_M]
      
    REWRITE ShiftRight(i: â„•):  
      R^i(f_M)_*ğ•œ_Z_M â†’ [R^i(f_M_Îµ)_*ğ•œ_Z_M â†’ R^(i+1)(f_M)_*ğ•œ_Z_M]
  }

  THEOREMS {
    THEOREM MapSheafDerivedEquivalence: 
      MapPHT(M) â‰ƒ SheafPHT(M) â‰ƒ DerivedPHT(M)
    {
      MapPHT(M) â‰ƒ SheafPHT(M):
        Follows from definition, Dgm(PH^i_M(v)) encodes PHT^i_M(v,t)
      SheafPHT(M) â‰ƒ DerivedPHT(M):  
        By H^i(DerivedPHT(M))_(v,t) â‰ƒ H^i(SheafPHT(M)(v,t))
    }
      
    THEOREM ECTBCTviaPHT:
      ECT(M) â‰ƒ âˆ‘_i (-1)^i PHT^i_M, BCT(M) â‰ƒ [PHT^i_M]_i
    {
      Immediate from definitions of ECT, BCT in terms of  
      dim PHT^i_M(v,t) = dim H^i(fâ»Â¹_M(v,t))
    }

    THEOREM PHTGluing: 
      PHTSheaf satisfies DescentCompatibility
    {
      GIVEN M: Shape, ğ“’: ğ“’(M)
      PROVE PHT(M) â‰ƒ holim Nerve(ğ“’, PHT|_ğ“’)
      USING 
        Godemont resolution k_Z_M â†’ [â¨k_Z_(M_i) â†’ â¨k_Z_(M_I) â†’ ...]
        â‡’ Rf_*k_Z_M â‰ƒ holim Nerve(ğ“’, Rf_*k_Z_(-)|_ğ“’)
        â‡’ Rf_*k_Z_M â‰ƒ holim[[Rf_*(M_i)k_Z]â†’[Rf_*(M_I)k_Z]â†’...] 
        AND by Verdier duality, proper base change:
        Rf_*k_Z_M â‰ƒ holim Nerve(ğ“’, PHT|_ğ“’)
        Lastly check PHT stalks satisfy sheaf axiom.
    }  

    THEOREM PHTStability:
      d_I(PHT(M), PHT(N)) â‰¤ Îµ  if
      âˆƒ Îµ-controlled homotopy equivalence Ï•: M â†’ N, Ïˆ: N â†’ M 
    {
      GIVEN Ï•: M â†’ N, Ïˆ: N â†’ M with
        â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆM, â€–y-Ïˆ(y)â€– â‰¤ Îµ âˆ€yâˆˆN
        homotopies H_M: idx âˆ¼ Ïˆâˆ˜Ï•, H_N: idy âˆ¼ Ï•âˆ˜Ïˆ  
        moving points by at most 2Îµ
      CONSTRUCT Îµ-interleaving PHT(M) â‡„_Îµ PHT(N):
        Ï•_* : PHT(M)_Îµ â†’ PHT(N), Ïˆ_*: PHT(N)_Îµ â†’ PHT(M) 
        WHERE Ï•_*(x,v,t) := (Ï•(x),v,t+Îµ), Ïˆ_* similar
      PROVE (Ï•_*, Ïˆ_*) is an Îµ-interleaving: 
        Ïˆ_*âˆ˜Ï•_*: PHT(M)_2Îµ â†’ PHT(M) via H_M on Z_M_2Îµ
        Ï•_*âˆ˜Ïˆ_*: PHT(N)_2Îµ â†’ PHT(N) via H_N on Z_N_2Îµ
    }
    
    THEOREM PHTBottleneckStability:
      d^(PHT_i)_(âˆ,âˆ)(M,N) â‰¤ d_I(PHT(M),PHT(N))
    {
      Let Îµ := d_I(PHT(M),PHT(N)), then âˆƒ Îµ-interleaving:
      Ï•: PHT(M) â‡„_Îµ PHT(N) : Ïˆ 
      â‡’ âˆ€v,i. Ï•^i_v: PHT^i_M(v) â‡„_Îµ PHT^i_N(v) : Ïˆ^i_v
         by restricting Ï•, Ïˆ to stalks over (v,t) 
      â‡’ d_B(PHT^i_M(v), PHT^i_N(v)) â‰¤ Îµ âˆ€v,i 
         by Isometry Thm: d_I = d_B for persistence mods
      â‡’ d^(PHT_i)_(âˆ,âˆ)(M,N) = max_v d_B(PHT^i_M(v),PHT^i_N(v)) â‰¤ Îµ
    }
 
    THEOREM PHTofPointCloud:  
      âˆ€ M: Submanifold, âˆ€Îµ>0, âˆƒÎ´>0 s.t.
      âˆ€{x_i}âŠ‚M Î´-dense, U=â‹ƒB_Îµ(x_i), K=AlphaComplex(U),
      d_I(PHT(M), PHT(K)) â‰¤ CÎµ w.h.p. for C=O(1) 
    {
      GIVEN Îµ, M, {x_i}, U, K as stated  
      HAVE K â‰ƒ M w.h.p. by:
        - NiyogiSmaleWeinberger: U â‰ƒ M if Î´â‰ªÎµ
        - Nerve thm: K = AlphaComplex(U) â‰ƒ U
      DEFINE interpolation maps Ï• := fâˆ˜j, Ïˆ := gâˆ˜Î¹:
        Î¹: Mâ†ªU, f: Uâ†’M retracts x to nearest pt on M 
        j: Kâ†ªU, g: Uâ†’K deformation retracts  
      PROVE Ï•, Ïˆ induce CÎµ-interleaving PHT(M)â‡„PHT(K):
        - â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆK, â€–y-Ïˆ(y)â€– â‰¤ 2Îµ âˆ€yâˆˆM
        - H_M: Ïˆâˆ˜Ï• âˆ¼ id_M, H_K: Ï•âˆ˜Ïˆ âˆ¼ id_K via H_U, G_U 
          are O(Îµ)-controlled htpys on U
        â‡’ d_I(PHT(M), PHT(K)) â‰¤ CÎµ by PHTStability
    }
  }
  
  EXAMPLES {
    EX PHTofCircle: 
      PHT(S^1)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]
        WHERE ğ•œ[n] = ğ•œ in deg n, 0 else

    EX PHTofAnnulus:
      PHT(Ann)(v,t) â‰ƒ IF tâ‰¤r THEN ğ•œ[0] ELSE 
                       IF tâˆˆ(r,R) THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE ğ•œ[1]  
        WHERE Ann = {x | râ‰¤â€–xâ€–â‰¤R}
      
    EX PHTofTorus:
      PHT(T)(v,t) â‰ƒ IF tâ‰¤-1 THEN ğ•œ[0] ELSE
                     IF tâˆˆ(-1,1) THEN ğ•œ[0]âŠ•ğ•œ[1]âŠ•ğ•œ[1] ELSE 
                     IF tâ‰¥1 THEN ğ•œ[0]âŠ•ğ•œ[2] ELSE 0
                     
    EX ECTofCircle:  
      ECT(S^1)(v,t) = IF tâˆˆ[-1,1] THEN 0 ELSE 1
      
    EX BCTofAnnulus:
      BCT(Ann)(v,t) = IF tâ‰¤r THEN [1,0,0] ELSE
                       IF tâˆˆ(r,R) THEN [1,1,0] ELSE [1,0,0]
  }
}




CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(X) = Constructible subsets of X wrt O
    Shv(X, ğ’Ÿ) = Category of ğ’Ÿ-valued sheaves on X  
    D^b(ğ’œ) = Bounded derived category of abelian category ğ’œ
    ğ•œ_Z = Constant sheaf valued in field ğ•œ on space Z
    
    Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}
    f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    
    PHT_M^i = R^if_(Mâˆ—)ğ•œ_Z_M âˆˆ Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ) 
    PHT(M) = [PHT_M^i] âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ))
    
    ECT(M)(v,t) = Ï‡(fâ»Â¹_M(v,t)) = âˆ‘_i (-1)^i dim H^i(fâ»Â¹_M(v,t)) 
    BCT(M)(v,t) = [Î²_i(fâ»Â¹_M(v,t))] = [dim H^i(fâ»Â¹_M(v,t))]
    
    ğ“’(M) = {M_i â†ª M} = Finite closed covers of M âˆˆ CS(â„^d)
    Nerve(ğ“’, â„±) = [[â„±(M_i)]â†’[â„±(M_I)|I|=2]â†’...] âˆˆ Ch(Vect_ğ•œ)
    
    d_I(â„±,ğ’¢) = inf {Îµâ‰¥0 | âˆƒ Îµ-interleaving â„±â‡„_Îµğ’¢}
    d^(PHT_i)_(p,q)(M,N) = â€–W_p(PHT_M^i, PHT_N^i)â€–_L^q(ğ•Š^(d-1))
  }

  LANGUAGE {
    TYPE Shape = Constructible subset of â„^d  
    TYPE Direction = Unit vector in ğ•Š^(d-1)
    TYPE Cover = Finite set of inclusions {M_i â†ª M}
    
    FUNC SubLevel(M: Shape, v: Direction, t: â„): Shape =
      {x âˆˆ M | xÂ·v â‰¤ t}
    
    FUNC DerivedPHT(M: Shape): D^b(Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ)) = 
      R(f_M)_*ğ•œ_Z_M
      
    FUNC ECT(M: Shape): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ) = 
      (v,t) â†¦ Hâ°(DerivedPHT(M))_(v,t)
      
    FUNC BCT(M: Shape): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ^(d+1)) =
      (v,t) â†¦ [H^i(DerivedPHT(M))_(v,t) for 0â‰¤iâ‰¤d]
      
    PRED IsInterleaving(Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„±, Îµ: â„â‰¥0) =
      Ï•âˆ˜Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ Ïˆâˆ˜Ï•_Îµ âˆ¼ â„±_2Îµ  
  }
  
  STRUCTURES {
    STRUCTURE PHTSheaf {
      FIELD Sections(M: Shape): 
        D^b(Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ)) = PHT(M)
      FIELD Restriction(M â†ª N): PHT(N) â†’ PHT(M) 
      AXIOM DescentCompatibility: 
        âˆ€ M: Shape, ğ“’: ğ“’(M),
        PHT(M) â‰ƒ holim Nerve(ğ“’, PHT|_ğ“’) 
    }
  }

  TRANSFORMERS {  
    REWRITE ShiftLeft(i: â„•):
      R^(i+1)f_*ğ•œ_Z_M â†’ [R^if_*ğ•œ_Z_M â†’ R^if_*ğ•œ_Z_M_Îµ]
    REWRITE ShiftRight(i: â„•):  
      R^if_*ğ•œ_Z_M â†’ [R^if_*ğ•œ_Z_M_Îµ â†’ R^(i+1)f_*ğ•œ_Z_M]
    REWRITE SheafInclusionMaps(â„±: Shv(X), Uâ†ªV: OpenInclusion):
      â„±(V) â†’ â„±(U) 
    SIMPLIFY ConstantSheafOnSet(YâŠ†X):
      ğ•œ_Y(U) = IF Yâˆ©U=âˆ… THEN 0 ELSE ğ•œ
  }

  THEOREMS {
    THEOREM SheafAxiom: 
      PHTSheaf satisfies DescentCompatibility
    {
      GIVEN M: Shape, ğ“’: ğ“’(M)
      PROVE PHT(M) â‰ƒ holim Nerve(ğ“’, PHT|_ğ“’)
      USING 
        RestrictionMaps(PHTSheaf, ğ“’) form SheafInclusionMaps
        Nerve(ğ“’, PHT|_ğ“’) = [[PHT(M_i)]â†’[PHT(M_I)|I|=2]â†’...]
        â‡’ holim Nerve(ğ“’, PHT|_ğ“’) â‰ƒ R lim Nerve(ğ“’, PHT|_ğ“’)
        BY Verdier duality, proper base change
    }  

    THEOREM NerveTheorem:
      âˆ€ M: Polyhedral, ğ“’={Ïƒ_i}: Triangulation of M,
      H^nPHT(M) â‰ƒ H^nNerve(ğ“’, Hâ°PHT)
    {
      GIVEN M, ğ“’ as above  
      NOTE Nerve(ğ“’, Hâ°PHT) = [â¨Hâ°PHT(Ïƒ_I)|I|=1]â†’[â¨Hâ°PHT(Ïƒ_I)|I|=2]â†’...
      PROVE âˆ€n, H^nPHT(M) â‰ƒ H^nNerve(ğ“’, Hâ°PHT)
      USING
        Nerve(ğ“’, ğ•œ) â‰ƒ M and Nerve(ğ“’,Hâ°PHT)=Nerve(ğ“’,ğ•œ)âŠ—ğ•œ Hâ°PHT(pt)
        â‡’ H^nNerve(ğ“’, Hâ°PHT) â‰ƒ H^n(M, Hâ°PHT(pt)_M)   
        AND by PoincarÃ© duality, H^nPHT(M) â‰ƒ H^n(M, Hâ°PHT(pt)_M)
    }

    THEOREM ECTDeterminesShape: 
      ECT(M) = ECT(N) â‡’ M â‰ƒ N
    {
      GIVEN M, N: Shape w/ ECT(M) = ECT(N)
      THUS âˆ€v,t. Ï‡(Mâˆ©{x|xÂ·vâ‰¤t}) = Ï‡(Nâˆ©{x|xÂ·vâ‰¤t})
      â‡’ âˆ€v. Schapira inversion(ECT(M))(v) = Schapira inversion(ECT(N))(v) 
      â‡’ M â‰ƒ N using microlocal Morse theory  
    }
    
    THEOREM PHT_DeterminesShape:
      PHT(M) â‰ƒ PHT(N) â‡’ M â‰ƒ N
    {
      GIVEN PHT(M) â‰ƒ PHT(N)
      HAVE BCT(M) = BCT(N)  BY PHT_M^i â‰ƒ PHT_N^i âˆ€i 
      AND ECT(M) = ECT(N)   BY ECT(M) = âˆ‘(-1)^i PHT_M^i 
                                     = âˆ‘(-1)^i PHT_N^i = ECT(N)
      THUS M â‰ƒ N            BY ECTDeterminesShape
    }
  }

  PROOFS {
    PROOF PHTStability: 
      d_I(PHT(M), PHT(N)) â‰¤ d_H(M, N)
    {
      DEFINE Îµ := d_H(M, N) 
      GIVEN Îµ-interleaving Î¹: Mâ†ªN_Îµ, Ïˆ: Nâ†ªM_Îµ
      DEFINE Ï•_i := R^if_Î¹, Ïˆ_i := R^ig_Ïˆ 
      PROVE (Ï•_i: PHT(M)_Îµâ†’PHT(N)), (Ïˆ_i: PHT(N)_Îµâ†’PHT(M))
            form an Îµ-interleaving  
      USING
        Z_M âŠ† Z_M_Îµ induces can: PHT(M)_Îµ â†’ PHT(M)
        âˆ€xâˆˆM. d(x,Ïˆ(Î¹(x))) â‰¤ 2Îµ â‡’ âˆƒ Homotopy 
          H_M: PHT(M)_2Îµ â†’ PHT(M)_Îµ realizing 
          Ïˆâˆ˜Ï•_2Îµ âˆ¼ can: PHT(M)_2Îµ â†’ PHT(M)_Îµ â†’ PHT(M)
        (Similarly homotopy H_N: PHT(N)_2Îµ â†’ PHT(N))
    }

    PROOF PHTBottleneckStability:
      d^(PHT_i)_(âˆ,âˆ)(M,N) â‰¤ d_I(PHT(M),PHT(N))  
    {
      DEFINE Îµ := d_I(PHT(M),PHT(N))
      GIVEN Îµ-interleaving PHT(M) â‡„_Îµ PHT(N)
      HAVE âˆ€v,i. Îµ-interleaving PHT_M^i(v) â‡„_Îµ PHT_N^i(v) 
           BY evaluating sheaf interleaving on stalks  
      THUS d_B(PHT_M^i(v), PHT_N^i(v)) â‰¤ Îµ âˆ€ v âˆˆ ğ•Š^(d-1), 0â‰¤iâ‰¤d
      BY Isometry Theorem: d_I = d_B on persistence modules
    }
 
    PROOF PHTofPointCloud:  
      âˆ€ M: Submanifold, âˆ€Îµ: Hausdorff-noise, âˆƒÎ´: sampling-density,
      âˆ€ {x_i}âŠ‚M, Î´-dense sample; U=â‹ƒB_Îµ(x_i); K=AlphaComplex(U), 
      d_I(PHT(M), PHT(K)) â‰¤ CÎµ w.h.p. for C=O(1)
    {
      GIVEN Îµ, M, {x_i}, U, K as stated  
      DEFINE interpolation map Ï• := fâˆ˜j, Ïˆ := gâˆ˜Î¹:
        Î¹: Mâ†ªU, f: Uâ†’M retracts x to closest pâˆˆM  (w/ homotopy H_U along seg px)
        j: Kâ†ªU, g: Uâ†’K deformation retracts       (w/ htpy G_U along Voronoi diagram)
      PROVE Ï•, Ïˆ induce CÎµ-interleaving PHT(M)â‡„_CÎµPHT(K): 
      - By NiyogiSmaleWeinberger, Î´â‰ªÎµ â‡’ Î¹: Mâ†ªU a homotopy-equivalence w.h.p.
      - By AlphaComplex(U) â‰ƒ DelaunayComplex(U) â‰ƒ U, get j: Kâ†ªU a htpy-equiv
      - f: Uâ†’M and g: Uâ†’K both Îµ-controlled by construction
      - H_U, G_U both O(Îµ)-controlled homotopies
      - â€–x-Ï•(x)â€– â‰¤ Îµ âˆ€xâˆˆK, â€–y-Ïˆ(y)â€– â‰¤ 2Îµ âˆ€yâˆˆM â‡’ Ï•,Ïˆ induce CÎµ-interleaving
    }
  }
    
  EXAMPLES {
    EX PHTofCircle: 
      PHT(S^1)(v,t) = IF tâ‰¤-1 THEN ğ•œ[0] ELSE IF tâ‰¥1 THEN 0 ELSE ğ•œ[0]âŠ•ğ•œ[1]
        WHERE [] denotes shift in homological degree

    EX PHTofAnnulus:
      PHT(Ann)(v,t) = IF tâ‰¤r THEN ğ•œ[0] ELSE 
                      IF tâˆˆ[r,R] THEN ğ•œ[0]âŠ•ğ•œ[1] ELSE 0
        WHERE Ann = {x | râ‰¤â€–xâ€–â‰¤R}

    EX PHTofTorus: 
      PHT(T^2)(v,t) = IF tâ‰¤-1 THEN ğ•œ[0] ELSE 
                      IF tâˆˆ[-1,1] THEN ğ•œ[0]âŠ•ğ•œ[1]âŠ•ğ•œ[1] ELSE
                      IF tâ‰¥1 THEN ğ•œ[0]âŠ•ğ•œ[2] ELSE 0
                      
    EX ECTofCircle:  
      ECT(S^1)(v,t) = IF tâˆˆ[-1,1] THEN 0 ELSE 1
      
    EX BCTofAnnulus: 
      BCT(Ann)(v,t) = IF tâ‰¤r THEN [1,0,0] ELSE
                      IF tâˆˆ[r,R] THEN [1,1,0] ELSE [0,0,0]
  }
}







CONCEPT ShapeSpace {
  NOTATION {
    CS(â„^d) = Constructible subsets of â„^d
    Shv(X) = Category of sheaves on X
    D^b(Shv(X)) = Bounded derived category of sheaves on X
    PHT(M) = R(f_M)_*ğ•œ_Z_M = Persistent Homology Transform of M âˆˆ CS(â„^d)
      where Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t} 
      and f_M : Z_M â†’ ğ•Š^(d-1) Ã— â„
    ğ“’ = covers of M âˆˆ CS(â„^d)
  }

  LANGUAGE {
    TYPE Shape = Constructible subset of â„^d
    TYPE Direction = Unit vector in â„^d 
    TYPE Filtration = Function: Shape â†’ [0,âˆ)

    FUNC SubLevelSet(s: Shape, v: Direction, t: â„) -> Shape =
      {x âˆˆ s | xÂ·v â‰¤ t}

    FUNC DerivedPHT(s: Shape): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = PHT(s)
  }

  STRUCTURES {
    STRUCTURE ShapeSpaceSheaf {
      FIELD Base: Category = (CS(â„^d))^op
      FIELD Stalks(s: Shape): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = PHT(s)
      FIELD Restrictions(i: ğ“’): 
        [PHT(M)] â‡’ [PHT(M_i) for M_i âˆˆ ğ“’] â†’ [PHT(M_I) for |I|=2] â†’ ...
    }
  }

  THEOREMS {
    THEOREM SheafAxiom: 
      ShapeSpaceSheaf satisfies ÄŒechDescent 
    {
      GIVEN M: Shape, ğ“’: Cover of M
      PROVE: 
        PHT(M) â‰ƒ holim[[PHT(M_i)] â‡’ [PHT(M_I) for |I|=2] â†’ ...]
      BY: Spectral sequence argument
    }

    THEOREM NerveTheorem: 
      PHT^n(M) â‰ƒ H^n(NerveComplex(M))   
    {  
      GIVEN M: PolyhedralShape w/ Triangulation M = â‹ƒ Ïƒ_i
      WHERE NerveComplex(M) := 
        [â¨PHT^0(M_I) for |I|=1] â†’ [â¨PHT^0(M_I) for |I|=2] â†’ ...
      PROVE: 
        PHT^n(M) â‰ƒ H^n(NerveComplex(M)) for all n
      BY: 
        E_1 page is NerveComplex(M)
        Spectral sequence collapses
        â‡’ Cohomology of nerve complex computes cohomology of PHT    
    }
  }

  PROOFS {
    PROOF Stability: 
      d_I(PHT(M), PHT(N)) â‰¤ Îµ 
      if M â‰ƒ_Îµ N by Îµ-controlled homotopy 
    {
      GIVEN M, N : Shape, Ï† : M â†’ N, Ïˆ : N â†’ M with Îµ-controlled homotopies
      CONSTRUCT: Îµ-interleaving morphisms between PHT(M) and PHT(N)
      USING:
        Functoriality of PHT 
        Homotopies between inclusion and Ï†âˆ˜Ïˆ, Ïˆâˆ˜Ï†
    } 
  }

  EXAMPLES {
    EXAMPLE PointCloudApproximation:
      GIVEN M: Submanifold, {x_i} âŠ‚ M sampled Îµ/2-densely
      LET U = â‹ƒB_Îµ(x_i)
      LET K = AlphaComplex(U)
      THEN d_I(PHT(M), PHT(K)) â‰¤ Îµ/2 w.h.p.
      BY:
        Nerve Lemma: U â‰ƒ K 
        Interleaving: M â†ª U, K â†’ U Îµ/2-controlled  
  }
}


CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(â„^d) = Constructible subsets of â„^d wrt O 
    Shv(X, ğ’Ÿ) = Category of ğ’Ÿ-valued sheaves on X
    D^b(ğ’œ) = Bounded derived category of abelian category ğ’œ
    ğ•œ_Z = Constant sheaf valued in field ğ•œ on space Z
    PHT_M^i = i-th Persistent Homology Transform of M:
      R^if_(Mâˆ—)ğ•œ_Z_M âˆˆ Shv(ğ•Š^(d-1) Ã— â„) where
        Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}
        f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    PHT(M) = [PHT_M^i] âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„)) 
    ECT(M)(v,t) = Ï‡(fâ»Â¹_M(v,t))
    BCT(M)(v,t) = [Î²_i(fâ»Â¹_M(v,t))]
    ğ“’(M) = {M_i â†ª M} = Finite closed covers of M
    d_I(â„±, ğ’¢) = inf{Îµâ‰¥0 | âˆƒ Îµ-interleaving â„± â‡„_Îµ ğ’¢}
    d^(PHT_i)_(p,q)(M,N) = â€–W_p(PHT_M^i, PHT_N^i)â€–_L^q(ğ•Š^(d-1))
  }

  LANGUAGE {  
    FUNC SubLevel(M: CS(â„^d), v: ğ•Š^(d-1), t: â„): CS(â„^d) =
      {x âˆˆ M | xÂ·v â‰¤ t}
    
    FUNC DerivedPHT(M: CS(â„^d)): D^b(Shv(ğ•Š^(d-1) Ã— â„)) =
      R(f_M)_*ğ•œ_Z_M

    FUNC ECT(M: CS(â„^d)): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ) =
      (v,t) â†¦ Hâ°(DerivedPHT(M))_(v,t)
      
    FUNC BCT(M: CS(â„^d)): Shv(ğ•Š^(d-1) Ã— â„, Vect_ğ•œ^(d+1)) =
      (v,t) â†¦ [H^i(DerivedPHT(M))_(v,t) for 0â‰¤iâ‰¤d]
      
    PRED IsInterleaving(Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„±, Îµ: â„â‰¥0) = 
      Ï•âˆ˜Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ AND Ïˆâˆ˜Ï•_Îµ âˆ¼ â„±_2Îµ
  }

  STRUCTURES {
    STRUCTURE PHTSheaf {
      FIELD Sections(M: CS(â„^d)): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = PHT(M)
      FIELD Restriction(M â†ª N): PHT(N) â†’ PHT(M)
      AXIOM CechDescent: âˆ€ M âˆˆ CS(â„^d), ğ“’ âˆˆ ğ“’(M), 
        PHT(M) â‰ƒ holim[[PHT(M_i)] â‡’ [PHT(M_I)|I|=2] â†’...]
    }
  }

  TRANSFORMERS {
    REWRITE ShiftLeft(i: Int) : 
      R^(i+1)f_*ğ•œ_Z_M â†’ [R^if_*ğ•œ_Z_M â†’ R^if_*ğ•œ_Z_M_Îµ]
    REWRITE ShiftRight(i: Int) :  
      R^if_*ğ•œ_Z_M â†’ [R^if_*ğ•œ_Z_M_Îµ â†’ R^(i+1)f_*ğ•œ_Z_M]
  }

  THEOREMS {
    THEOREM SheafAxiom: 
      PHTSheaf satisfies CechDescent
    {
      GIVEN M âˆˆ CS(â„^d), ğ“’ âˆˆ ğ“’(M) 
      PROVE PHT(M) â‰ƒ holim[[PHT(M_i)] â‡’ [PHT(M_I)|I|=2] â†’...]
      USING: ShiftLeft/Right(i), Verdier duality, Proper base change
    }

    THEOREM NerveTheorem:
      H^nPHT_M â‰ƒ H^nNerve(ğ“’, Hâ°PHT) 
    {
      GIVEN M: PolyhedralShape, ğ“’ = {Ïƒ_i}: Triangulation
      WHERE Nerve(ğ“’, Hâ°PHT) := [â¨Hâ°PHT(Ïƒ_I)|I|=1] â†’ [â¨Hâ°PHT(Ïƒ_I)|I|=2] â†’...
      PROVE H^nPHT_M â‰ƒ H^nNerve(ğ“’, Hâ°PHT) âˆ€n
    }

    THEOREM ECTDeterminesShape:  
      ECT(M) = ECT(N) â‡’ M = N
    {
      USING Schapira inversion formula for Radon transform R_S
    }

    THEOREM PHT_DeterminesShape:
      PHT_M = PHT_N â‡’ M = N
    { 
      GIVEN PHT_M = PHT_N
      HAVE BCT_M = BCT_N  BY PHT_M^i = PHT_N^i âˆ€i 
      HAVE ECT_M = ECT_N  BY ECT_M = âˆ‘(-1)^i PHT_M^i = âˆ‘(-1)^i PHT_N^i = ECT_N
      THUS M = N          BY ECTDeterminesShape
    }
  }
   
  PROOFS {
    PROOF Stability:
      d_I(PHT(M), PHT(N)) â‰¤ Îµ if d_H(M,N) â‰¤ Îµ 
    {
      DEFINE Îµ-interleaving: 
        Ï•_i: R^if_(Mâˆ—)ğ•œ_Z_M_Îµ â†’ R^if_(Nâˆ—)ğ•œ_Z_N,  
        Ïˆ_i: R^if_(Nâˆ—)ğ•œ_Z_N_Îµ â†’ R^if_(Mâˆ—)ğ•œ_Z_M
      PROVE IsInterleaving(Ï•, Ïˆ, Îµ) using:
        (1) Z_M âŠ† Z_M_Îµ induces R^if_(Mâˆ—)ğ•œ_Z_M_Îµ â†’ R^if_(Mâˆ—)ğ•œ_Z_M
        (2) Homotopies H_M: idx âˆ¼ Ïˆâˆ˜Ï•, H_N: idy âˆ¼ Ï•âˆ˜Ïˆ 
            from d_H(M,N) â‰¤ Îµ 
    }

    PROOF PHT_BottleneckStability: 
      d^(PHT_i)_(âˆ,âˆ)(M,N) â‰¤ d_I(PHT(M), PHT(N))
    {
      DEFINE Îµ := d_I(PHT(M),PHT(N))
      GIVEN Îµ-interleaving PHT(M) â‡„_Îµ PHT(N)
      HAVE Îµ-interleaving PHT_M^i â‡„_Îµ PHT_N^i âˆ€v,i  
           BY evaluating PHT^i sheaf interleaving on stalks
      THUS d_B(PHT_M^i(v), PHT_N^i(v)) â‰¤ Îµ âˆ€v,i  
           BY Isometry Thm for interleavings & Bottleneck dist 
    }
  
    PROOF PointCloudPHTApproximation:
      d_I(PHT(M), PHT(K)) â‰¤ Îµ/2 w.h.p.
    {  
      GIVEN {x_i}âŠ‚M, Îµ/2-dense sample; U=â‹ƒB_Îµ(x_i); K=AlphaComplex(U) 
      DEFINE Ï• := fâˆ˜j, Ïˆ := gâˆ˜Î¹:
        Î¹: Mâ†ªU, f: Uâ†’M: x â†¦ argmin_{pâˆˆM} d(p,x)  (homotopy via: H_U(x,t) = tx + (1-t)f(x))
        j: Kâ†ªU, g: Uâ†’K: deformation retract       (homotopy via: G_U along Voronoi diagram) 
      PROVE Ï•, Ïˆ induce Îµ/2-interleaving of PHT(M), PHT(K) 
      USING: 
        NiyogiSmaleWeinberger: U â‰ƒ M w.h.p.
        AlphaComplex(U) â‰ƒ U
        H_U, G_U are Îµ, Îµ/2 controlled
        â€–x - Ï•(x)â€– â‰¤ Îµ/2 âˆ€xâˆˆK, â€–y - Ïˆ(y)â€– â‰¤ Îµ âˆ€yâˆˆM
    }
  }
}


CONCEPT ShapeSpace {
  NOTATION {
    O = {O_d} = o-minimal structure on â„^d
    CS(â„^d) = Constructible subsets of â„^d wrt O 
    Shv(X, ğ’Ÿ) = ğ’Ÿ-sheaves on X
    D^b(ğ’œ) = Bounded derived category of ğ’œ
    ğ•œ_Z = Constant sheaf on Z with stalk field ğ•œ
    Dgm = Persistence diagrams
    PHT_M^i = R^if_(Mâˆ—)ğ•œ_Z_M âˆˆ Shv(ğ•Š^(d-1) Ã— â„), 
      Z_M = {(x,v,t) âˆˆ M Ã— ğ•Š^(d-1) Ã— â„ | xÂ·v â‰¤ t}, f_M: Z_M â†’ ğ•Š^(d-1) Ã— â„
    PHT(M) = [PHT_M^i] âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    ECT(M) = Ï‡(f^(-1)_M(-)) : ğ•Š^(d-1) Ã— â„ â†’ â„¤  
    BCT(M) = [Î²_i(f^(-1)_M(-))] : ğ•Š^(d-1) Ã— â„ â†’ â„¤^(d+1)
    d_I(â„±, ğ’¢) = inf{Îµ | âˆƒ Îµ-interleaving â„± â‡„_Îµ ğ’¢}
    d^(PHT_i)_(p,q)(M,N) = â€–W_p(PHT_M^i, PHT_N^i)â€–_q
    ğ“’(M) = {M_i â†ª M} = Finite closed covers of M âˆˆ CS(â„^d)
    â„±_Îµ = Îµ-shift of â„± âˆˆ D^b(Shv(ğ•Š^(d-1) Ã— â„))
    â„± =[Îµ]= ğ’¢ â‡” d_I(â„±, ğ’¢) â‰¤ Îµ  
    I_M = Index set of cover ğ“’(M)
    M_I = â‹‚_{iâˆˆI} M_i for I âŠ† I_M
  }

  LANGUAGE {
    FUNC Sublevel(M: CS(â„^d), v: ğ•Š^(d-1), t: â„): CS(â„^d) = {x âˆˆ M | xÂ·v â‰¤ t}
    FUNC DerivedPHT(M: CS(â„^d)): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = PHT(M) 
    FUNC InterleavingDistance(â„±, ğ’¢: D^b(Shv(ğ•Š^(d-1) Ã— â„))): â„â‰¥0 = d_I(â„±, ğ’¢)
    FUNC ShiftFunctor(â„±: D^b(Shv(ğ•Š^(d-1) Ã— â„)), Îµ: â„â‰¥0): D^b(Shv(ğ•Š^(d-1) Ã— â„)) = â„±_Îµ
    FUNC WassersteinDistance(F, G: ğ•Š^(d-1) â†’ Dgm, p: â„â‰¥1, q: â„â‰¥1 âˆª {âˆ}): â„â‰¥0 = d^F_(p,q)(M,N)
    PRED CechDescent(â„±: D^b(Shv(ğ•Š^(d-1) Ã— â„)), ğ“’: ğ“’(M)) = 
      â„±(M) â‰ƒ holim[ âˆ_{iâˆˆI_M} â„±(M_i) â‡’ âˆ_{IâŠ†I_M, |I|=2} â„±(M_I) â†’ â‹¯ ]
    PRED FiniteCover(ğ“’: ğ“’(M), M: CS(â„^d)) = â‹ƒğ“’ = M âˆ§ ğ“’ is finite
    AXIOM SheafAxiom: 
      âˆ€ M: CS(â„^d), ğ“’: ğ“’(M) . FiniteCover(ğ“’, M) â‡’ CechDescent(PHT(M), ğ“’) 
  }

  TRANSFORMERS {
    TACTIC SimplifyInterleaving: 
      â„± =[Îµ]= ğ’¢ â‡” âˆƒ Ï•: â„±_Îµ â†’ ğ’¢, Ïˆ: ğ’¢_Îµ â†’ â„± . Ï•Ïˆ_Îµ âˆ¼ ğ’¢_2Îµ âˆ§ ÏˆÏ•_Îµ âˆ¼ â„±_2Îµ
    TACTIC DecomposePHT:
      PHT^n(M) â‰ƒ H^n[ 0 â†’ â¨_{|I|=1} PHT^0(M_I) â†’ â¨_{|I|=2} PHT^0(M_I) â†’ â‹¯ ]
        IF M triangulated by {Ïƒ_i}
  }

  THEOREMS {    
    THEOREM PHTDeterminesShape: PHT(M) = PHT(N) â‡’ M = N
    { 
      PHT_M = PHT_N                   
      â‡’ âˆ€i. PHT_M^i = PHT_N^i           BY def
      â‡’ BCT_M = BCT_N                   BY def
      â‡’ âˆ‘_i (-1)^i PHT_M^i = ECT_M 
        = ECT_N = âˆ‘_i (-1)^i PHT_N^i    BY Euler
      â‡’ M = N                           BY Schapira 
    }

    THEOREM StabilityPHT: d_I(PHT(M), PHT(N)) â‰¤ Îµ if d_H(M, N) â‰¤ Îµ
    {
      d_H(M,N) â‰¤ Îµ                       
      â‡’ âˆƒ Ï†: M â†’ N, Ïˆ: N â†’ M,
          â€–x - Ï†(x)â€– â‰¤ Îµ âˆ€xâˆˆM,           
          â€–y - Ïˆ(y)â€– â‰¤ Îµ âˆ€yâˆˆN,
          H_M: idx âˆ¼ ÏˆÏ†, H_N: idy âˆ¼ Ï†Ïˆ    BY def
      â‡’ Ï•_i: PHT_M^i_Îµ â†’ PHT_N^i, 
        Ïˆ_i: PHT_N^i_Îµ â†’ PHT_M^i
        are Îµ-interleaving               BY functoriality + homotopies
      â‡’ d_I(PHT(M), PHT(N)) â‰¤ Îµ          BY SimplifyInterleaving
    }

    THEOREM ApproximationPHT: d_I(PHT(M), PHT(K)) â‰¤ Îµ/2 whp
    {
      GIVEN M: n-manifold, Ï„: condition number, Îµ: radius, Î´: prob  
      LET {x_i} âŠ‚ M be Îµ/2-dense sample w.p. â‰¥ 1-Î´, 
          U = â‹ƒ_i B_Îµ(x_i), K = AlphaComplex(U)

      SHOW d_I(PHT(M), PHT(K)) â‰¤ Îµ/2 w.p. â‰¥ 1-Î´ IF Îµ < Ï„/2 
      
        M â‰ƒ U w.p. â‰¥ 1-Î´ IF Îµ < Ï„/2           BY NiyogiSmaleWeinberger
        U â‰ƒ K                                  BY NerveTheorem
      â‡’ âˆƒ Ï†: M â†’ K, Ïˆ: K â†’ M
          â€–x - Ï†(x)â€– â‰¤ Îµ/2 âˆ€xâˆˆM,              BY sample density + K âŠ† U
          â€–u - Ïˆ(u)â€– â‰¤ Îµ   âˆ€uâˆˆU,              BY def AlphaComplex 
          H_M: idx âˆ¼ ÏˆÏ†, H_K: idu âˆ¼ Ï†Ïˆ         BY Homotopy along Voronoi
      â‡’ d_I(PHT(M), PHT(K)) â‰¤ Îµ/2 w.p. â‰¥ 1-Î´ BY StabilityPHT  
    }
  }
  
  PROOFS {
    PROOF SheafAxiomProof:
      âˆ€ M: CS(â„^d), ğ“’: ğ“’(M) . FiniteCover(ğ“’, M) â‡’ CechDescent(PHT(M), ğ“’) 
    {
      SUFFICES_TO_SHOW  
        PHT(M) â†’ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]
          âˆ¥         âˆ¥                    |I|=2
        PHT(Mâˆ©ğ•Šâ„) â†’ holim[ âˆ PHT(M_iâˆ©ğ•Šâ„) â‡’ âˆ PHT(M_Iâˆ©ğ•Šâ„) â†’ â‹¯ ]
      is homotopy pullback, ğ•Šâ„ = ğ•Š^(d-1) Ã— â„
      
      LET E^r = PHT(M) wrt ğ“’ spectral sequence, r â‰¥ 1

      E^1_pq = â¨_{IâŠ†I_M, |I|=p+1} H^q(PHT(M_I))   BY def Cech complex
      E^2_p0 = H^p(Câ€¢(ğ“’, Hâ°PHT))                  BY E^1 collapse 
      E^r_p0 = E^2_p0, r â‰¥ 2                     BY CechCohomology  
     
    â‡’ H^nPHT(M) â‰ƒ H^n(Câ€¢(ğ“’, Hâ°PHT))        
    â‡’ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ] â‰ƒ HolimCone(ğ“’, PHT)  
                                   |I|=2            BY MayerVietoris
    â‡’ PHT(M) â‰ƒ holim[ âˆ PHT(M_i) â‡’ âˆ PHT(M_I) â†’ â‹¯ ]              
                                     |I|=2
       SIMILARLY FOR PHT(Mâˆ©ğ•Šâ„)
    }
     
    PROOF DecomposePHTProof: 
      IF M triangulated by {Ïƒ_i} THEN
        PHT^n(M) â‰ƒ H^n[ 0 â†’ â¨_{|I|=1} PHT^0(M_I) â†’ â¨_{|I|=2} PHT^0(M_I) â†’ â‹¯ ] 
    {              
      LET E^r = PHT(M) wrt {Ïƒ_i} spectral sequence
    
      E^1_pq = â¨_{IâŠ†I_M, |I|=p+1} H^q(PHT(M_I))     BY def Cech complex
             = 0 for q>0                            BY contractibility
      
    â‡’ E^1 collapse â‡’ E^âˆ = E^2
    â‡’ H^nPHT(M) â‰ƒ H^n(Câ€¢({Ïƒ_i}, Hâ°PHT))        
    }
  }
}