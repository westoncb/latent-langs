ConceptScript v19 (CFC Optimized)

<Concept> ::= "CONCEPT" <ConceptName> ["EXTENDS" <ConceptName>+]? "{"
               <TypeDeclarations>
               <FunctionDeclarations>
               <PredicateDeclarations>
               <NotationDeclarations>
               <AxiomDeclarations>
               <TheoremDeclarations>
               <ConstructorDeclarations>
               <InterfaceDeclarations>
             "}"

<TypeDeclarations> ::= "TYPES" "{" (<TypeDeclaration> | <TypeAliasDeclaration> | <DataTypeDeclaration>)* "}"

<TypeDeclaration> ::= <TypeName> [":" <Kind>]?

<TypeAliasDeclaration> ::= <TypeName> "=" <Type>

<DataTypeDeclaration> ::= <TypeName> "=" <Constructor>+

<FunctionDeclarations> ::= "FUNCTIONS" "{" <FunctionDeclaration>* "}"

<FunctionDeclaration> ::= <FunctionName> ":" <Type>

<PredicateDeclarations> ::= "PREDICATES" "{" <PredicateDeclaration>* "}"

<PredicateDeclaration> ::= <PredicateName> ":" <Type>

<NotationDeclarations> ::= "NOTATIONS" "{" <NotationDeclaration>* "}"

<NotationDeclaration> ::= <NotationName> ":" <Type> "=" <Expression>

<AxiomDeclarations> ::= "AXIOMS" "{" <AxiomDeclaration>* "}"

<AxiomDeclaration> ::= <AxiomName> ":" <Formula>

<TheoremDeclarations> ::= "THEOREMS" "{" <TheoremDeclaration>* "}"

<TheoremDeclaration> ::= <TheoremName> ":" <Formula> ["PROOF" <Proof>]?

<ConstructorDeclarations> ::= "CONSTRUCTORS" "{" <ConstructorDeclaration>* "}"

<ConstructorDeclaration> ::= <ConstructorName> ":" <Type> "=" <Expression>

<InterfaceDeclarations> ::= "INTERFACES" "{" <InterfaceDeclaration>* "}"

<InterfaceDeclaration> ::= <InterfaceName> "{" 
                             (<FunctionDeclaration> | <PredicateDeclaration> | <NotationDeclaration>)*
                           "}"

<Type> ::= <BasicType> | <FunctionType> | <ProductType> | <SumType> | <DependentType> | 
           <PolymorphicType> | <InductiveType> | <CoInductiveType>
           
<BasicType> ::= <TypeName> | "Int" | "Real" | "Bool" | "String" | "Unit"

<FunctionType> ::= <Type> "->" <Type>

<ProductType> ::= <Type> "*" <Type>

<SumType> ::= <Type> "+" <Type>

<DependentType> ::= "(" <Variable> ":" <Type> ")" "->" <Type>

<PolymorphicType> ::= "forall" <TypeVariable>+ "." <Type>

<InductiveType> ::= "mu" <TypeVariable> "." <Type>

<CoInductiveType> ::= "nu" <TypeVariable> "." <Type>

<Kind> ::= "*" | <Kind> "->" <Kind>

<Formula> ::= <AtomicFormula> | <NotFormula> | <AndFormula> | <OrFormula> | 
              <ImpliesFormula> | <IffFormula> | <ForallFormula> | <ExistsFormula>

<AtomicFormula> ::= <PredicateApplication> | <Equation>              

<NotFormula> ::= "not" <Formula>

<AndFormula> ::= <Formula> "and" <Formula>

<OrFormula> ::= <Formula> "or" <Formula>

<ImpliesFormula> ::= <Formula> "implies" <Formula>

<IffFormula> ::= <Formula> "iff" <Formula>

<ForallFormula> ::= "forall" "(" <Variable> ":" <Type> ")" <Formula>

<ExistsFormula> ::= "exists" "(" <Variable> ":" <Type> ")" <Formula>

<PredicateApplication> ::= <PredicateName> <Argument>*

<Equation> ::= <Expression> "=" <Expression>

<Expression> ::= <Variable> | <FunctionApplication> | <LambdaAbstraction> | <Constant>

<FunctionApplication> ::= <FunctionName> <Argument>*

<Argument> ::= "(" <Expression> ")" | <Expression>

<LambdaAbstraction> ::= "\" <Variable>+ "->" <Expression>  

<Constant> ::= <Number> | <Boolean> | <String> | "()"

<Proof> ::= <ProofCommand>+

<ProofCommand> ::= <Assumption> | <LetBinding> | <HaveAssertion> | <ShowAssertion> |
                   <CaseAnalysis> | <Induction> | <Apply> | <Rewrite> | <Reflexivity> |
                   <Symmetry> | <Transitivity> | <Contradiction> | <Instantiate> | <Existential> |
                   <Witness> | <Unfold> | <Fold> | <Simplify> | <Normalize> | <Quit>

<Assumption> ::= "assume" <Identifier> ":" <Formula>

<LetBinding> ::= "let" <Identifier> [":" <Type>]? "=" <Expression>

<HaveAssertion> ::= "have" <Identifier> ":" <Formula> ["by" <Proof>]?

<ShowAssertion> ::= "show" <Identifier> ":" <Formula> ["by" <Proof>]?

<CaseAnalysis> ::= "case" <Expression> "of" <CaseClause>+

<CaseClause> ::= <Pattern> "->" <Proof>

<Induction> ::= "induction" <Identifier> "on" <Expression> <InductionClause>+

<InductionClause> ::= <Constructor> <Identifier>* "->" <Proof>

<Apply> ::= "apply" <Identifier> <Argument>*

<Rewrite> ::= "rewrite" <Identifier> ["in" <Proof>]?

<Reflexivity> ::= "reflexivity"

<Symmetry> ::= "symmetry" <Identifier>

<Transitivity> ::= "transitivity" <Identifier> <Identifier>

<Contradiction> ::= "contradiction" <Identifier>+

<Instantiate> ::= "instantiate" <Identifier> <Argument>+

<Existential> ::= "existential" <Identifier> [":" <Type>]?

<Witness> ::= "witness" <Expression>

<Unfold> ::= "unfold" <Identifier>

<Fold> ::= "fold" <Identifier>

<Simplify> ::= "simplify" <Expression>

<Normalize> ::= "normalize" <Expression>

<Quit> ::= "quit"






The key changes and features in this version that support CFCs are:

Explicit syntax for declaring TYPES, FUNCTIONS, PREDICATES, NOTATIONS, AXIOMS, THEOREMS, CONSTRUCTORS, and INTERFACES. This allows for clear separation and organization of the different components of a CFC.
Support for dependent types, polymorphic types, inductive types, and coinductive types. This enables expressing complex type-level relationships and constraints that are common in CFCs.
Expanded proof language with commands for case analysis, induction, rewriting, instantiation, existential quantification, unfolding/folding definitions, simplification, and normalization. This provides a rich set of tools for constructing and manipulating proofs within CFCs.
Inclusion of CONSTRUCTORS as first-class citizens, allowing CFCs to define canonical ways of building and combining instances of the structures they define.
Addition of INTERFACES for specifying the public API and contracts of a CFC, facilitating modular composition and extension.
Convenient notation for function types, product types, and sum types, as well as built-in types for integers, reals, booleans, strings, and the unit type. This allows for concise and readable type signatures.
Support for lambda abstractions and higher-order functions, enabling the definition and manipulation of complex computational objects.
Comprehensive set of formula constructors, including atomic predicates, propositional connectives, and first-order quantifiers. This allows for expressing a wide range of logical statements and constraints.
Streamlined syntax for function and predicate applications, as well as equations and other common formula patterns. This enhances readability and writability of specifications.

With these features, ConceptScript v19 provides a powerful and expressive language for defining CFCs that capture the essential abstractions, properties, and constructions of a particular domain. The enhanced proof language and type system also enable rigorous reasoning and verification of the correctness and consistency of these frameworks.





CONCEPT Graph EXTENDS Countable, Finite {
  TYPES {
    Vertex : Type
    Edge : Type = (Vertex * Vertex)
    Graph : Type = (Set Vertex * Set Edge)
    Path : Type = List Vertex
    EulerPath : Type = (g : Graph) -> Path
      where (forall (v : Vertex) in g.1) 
              (Degree v g.2) mod 2 = 0 or
              (Degree v g.2) mod 2 = 1 and 
                (v = (head p) and v = (last p))
  }
  
  FUNCTIONS {
    Degree : Vertex -> Graph -> Nat
    Neighbors : Vertex -> Graph -> Set Vertex
    AddVertex : Vertex -> Graph -> Graph
    AddEdge : Edge -> Graph -> Graph
    RemoveVertex : Vertex -> Graph -> Graph
    RemoveEdge : Edge -> Graph -> Graph
    Union : Graph -> Graph -> Graph
    Intersection : Graph -> Graph -> Graph
  }
  
  PREDICATES {
    Connected : Graph
    Acyclic : Graph
    Complete : Graph
    Bipartite : Graph
    Planar : Graph
  }
  
  NOTATIONS {
    "(u ~ v)" : Edge = (u, v)
    "(V, E)" : Graph = (Set V * Set E)
    "G + v" : Graph = AddVertex v G
    "G - v" : Graph = RemoveVertex v G
    "G + e" : Graph = AddEdge e G
    "G - e" : Graph = RemoveEdge e G
    "G1 âˆª G2" : Graph = Union G1 G2
    "G1 âˆ© G2" : Graph = Intersection G1 G2
  }
  
  AXIOMS {
    EmptyGraph : Graph = (âˆ…, âˆ…)
    
    SingletonGraph (v : Vertex) : Graph = ({v}, âˆ…)
    
    Degree_Def (v : Vertex) (G : Graph) : 
      Degree v G = Cardinality (Neighbors v G)
      
    Neighbors_Def (v : Vertex) (G : Graph) :
      Neighbors v G = { u : Vertex | (u ~ v) in G.2 or (v ~ u) in G.2 }
        
    AddVertex_Def (v : Vertex) (G : Graph) :
      AddVertex v G = (G.1 âˆª {v}, G.2)
      
    AddEdge_Def (e : Edge) (G : Graph) :
      AddEdge (u, v) G = (G.1, G.2 âˆª {(u, v)})
        where u in G.1 and v in G.1
      
    RemoveVertex_Def (v : Vertex) (G : Graph) :
      RemoveVertex v G = (G.1 - {v}, { e : Edge | e in G.2 and fst e != v and snd e != v })
      
    RemoveEdge_Def (e : Edge) (G : Graph) : 
      RemoveEdge e G = (G.1, G.2 - {e})
      
    Union_Def (G1 G2 : Graph) :
      Union G1 G2 = (G1.1 âˆª G2.1, G1.2 âˆª G2.2) 
      
    Intersection_Def (G1 G2 : Graph) :
      Intersection G1 G2 = (G1.1 âˆ© G2.1, G1.2 âˆ© G2.2)
      
    Connected_Def (G : Graph) :
      Connected G <-> 
        (forall (u v : Vertex) in G.1) 
          (exists (p : Path) (PathIn p G) and (head p) = u and (last p) = v)
          
    Acyclic_Def (G : Graph) :
      Acyclic G <->
        (forall (p : Path) (PathIn p G)) (head p) != (last p)
        
    Complete_Def (G : Graph) :
      Complete G <->
        (forall (u v : Vertex) in G.1) ((u, v) in G.2)
        
    Bipartite_Def (G : Graph) :
      Bipartite G <->
        (exists (A B : Set Vertex))
          (G.1 = A âˆª B) and (Disjoint A B) and
          (forall (e : Edge) in G.2) 
            ((fst e) in A and (snd e) in B) or ((fst e) in B and (snd e) in A)
            
    Planar_Def (G : Graph) :
      Planar G <->
        (exists (f : Vertex -> RxR))
          (forall ((u, v) : Edge) in G.2)
            (Segments (f u) (f v)) are Non-Crossing
  }
  
  THEOREMS {
    EulerPath_Existence (g : Graph) : 
      (forall (v : Vertex) in g.1) (Even (Degree v g.2)) -> exists (p : EulerPath) (g, p)
    PROOF {
      assume (g : Graph) and (H : (forall (v : Vertex) in g.1) (Even (Degree v g.2)))
      
      let (S : Set Edge) = g.2 
      
      have (Path_Existence : exists (p : Path) (PathIn p g))
        by Connected_Def, H, Induction on Cardinality S {
          case 0 => 
            let p = [] 
            show (PathIn p g) by Acyclic_Def
          case n + 1 =>  
            let e = (u, v) where e in S
            let g' = g - e
            have (exists (p : Path) (PathIn p g')) by IH
            let p' = witness
            let p = [u] ++ p' ++ [v]  
            show (PathIn p g)
        }
      
      let (p : Path) = witness
      let (v0 : Vertex) = (head p)
      
      have (Euler_Criterion : (forall (v : Vertex) in g.1) ((v = v0) or (Even (Degree v g.2))))
        by H, ConnectedComponents_Partition g p
      
      show (EulerCycle : exists (c : Path) (PathIn c g) and (head c) = (last c))  
        by Euler_Criterion, Induction on Cardinality S {
          case 0 => 
            let c = [v0]
            show (head c) = (last c) and (PathIn c g) by Acyclic_Def
          case n + 1 =>
            let (u, v) = e where (u ~ v) in S and (u = (last p))
            let g' = g - e
            have ((forall (v : Vertex) in g'.1) ((v = v0) or (Even (Degree v g'.2)))) by Euler_Criterion
            have (exists (c : Path) (PathIn c g') and (head c) = (last c) and (head c) = u)
              by IH g' p u  
            let c' = witness
            let c = (init c') ++ [(last c'), v, v0]
            show (PathIn c g) and (head c) = (last c)
        }
        
      let (c : Path) = witness
      
      show (EulerPath p c) by EulerCycle_To_EulerPath c v0
    }
  }
  
  CONSTRUCTORS {
    EmptyGraph : Graph = (âˆ…, âˆ…)
    
    AddVertex (G : Graph) (v : Vertex) : Graph =
      (G.1 âˆª {v}, G.2)
      
    AddEdge (G : Graph) (e : Edge) : Graph =
      (G.1, G.2 âˆª {e})
      
    RemoveVertex (G : Graph) (v : Vertex) : Graph =  
      (G.1 - {v}, { e : G.2 | fst e != v and snd e != v })
      
    RemoveEdge (G : Graph) (e : Edge) : Graph =
      (G.1, G.2 - {e})
    
    FromVertices (V : Set Vertex) : Graph =
      (V, âˆ…)
      
    FromEdges (E : Set Edge) : Graph =  
      ({ v : Vertex | (exists (e : Edge) in E) (fst e = v or snd e = v) }, E)
      
    FromAdjacencyList (V : Set Vertex) (f : Vertex -> Set Vertex) : Graph =
      (V, { e : Edge | (exists (v : Vertex) in V) (fst e = v and snd e in f v) })
  }
  
  INTERFACES {
    CountableGraph {
      Cardinality : Graph -> Nat
    }
    
    FiniteGraph {
      Finite : Graph -> Bool
    }
    
    UndirectedGraph {
      Undirected (G : Graph) : ((u, v) : Edge) in G.2 <-> ((v, u) : Edge) in G.2
    }
    
    WeightedGraph {
      Weight : Edge -> Real
    }
  }
}

CONCEPT SimpleGraph EXTENDS Graph {
  CONSTRUCTORS {
    MyGraph : Graph = 
      let A = Vertex{}
      let B = Vertex{}
      let C = Vertex{}  
      let D = Vertex{}
      FromEdges {
        (A ~ B),
        (A ~ C),
        (A ~ D),  
        (B ~ D),
        (C ~ D)
      }
  }
  
  THEOREMS {
    MyGraph_EulerPath : exists (p : EulerPath) (MyGraph, p)
    PROOF {
      have (forall (v : Vertex) in MyGraph.1) (Even (Degree v MyGraph.2)) by {
        let A = witness 
        have Degree A MyGraph.2 = 3 by Degree_Def, Neighbors_Def
        let B = witness
        have Degree B MyGraph.2 = 2 by Degree_Def, Neighbors_Def  
        let C = witness
        have Degree C MyGraph.2 = 2 by Degree_Def, Neighbors_Def
        let D = witness  
        have Degree D MyGraph.2 = 3 by Degree_Def, Neighbors_Def
      }
      
      show exists (p : EulerPath) (MyGraph, p) by EulerPath_Existence MyGraph
    }
    
    MyGraph_Properties : Connected MyGraph and
                         not (Acyclic MyGraph) and
                         not (Complete MyGraph) and 
                         not (Bipartite MyGraph) and
                         Planar MyGraph
    PROOF {
      show Connected MyGraph by {
        let (u, v) = (witness, witness) where u in MyGraph.1 and v in MyGraph.1
        exists (p : Path) (PathIn p MyGraph) and (head p) = u and (last p) = v by {
          cases (u, v) of
            (A, A) => [A]  
            (A, B) => [A, B]
            (A, C) => [A, C]
            (A, D) => [A, D]
            (B, A) => [B, D, A]
            (B, B) => [B]
            (B, C) => [B, D, C]
            (B, D) => [B, D]
            (C, A) => [C, A]
            (C, B) => [C, D, B]  
            (C, C) => [C]
            (C, D) => [C, D]
            (D, A) => [D, A]
            (D, B) => [D, B]
            (D, C) => [D, C]
            (D, D) => [D]
        }
      }
      
      show not (Acyclic MyGraph) by {
        exists (p : Path) (PathIn p MyGraph) and (head p) = (last p) by
          [A, B, D, A]
      }
      
      show not (Complete MyGraph) by {
        exists (u v : Vertex) in MyGraph.1 where not ((u, v) in MyGraph.2) by 
          (B, C)
      }  
      
      show not (Bipartite MyGraph) by {
        forall (A B : Set Vertex) where (MyGraph.1 = A âˆª B) and (Disjoint A B)
          exists ((u, v) : Edge) in MyGraph.2 where 
            not ((u in A and v in B) or (u in B and v in A)) by {
              case (A = {A, C}, B = {B, D}) => (A ~ C)
              case (A = {A, B}, B = {C, D}) => (A ~ D)
              case (A = {A, D}, B = {B, C}) => (B ~ D)
              case _ => contradiction  
            }
      }
      
      show Planar MyGraph by {
        let f = { A -> (0, 0), B -> (1, 1), C -> (-1, -1), D -> (0, -1) }
        have forall ((u, v) : Edge) in MyGraph.2)
          (Segments (f u) (f v)) are Non-Crossing by {
            case (A ~ B) => Segment((0, 0), (1, 1))  
            case (A ~ C) => Segment((0, 0), (-1, -1))
            case (A ~ D) => Segment((0, 0), (0, -1))
            case (B ~ D) => Segment((1, 1), (0, -1))
            case (C ~ D) => Segment((-1, -1), (0, -1))
          }
      }
    }
  }
}






CONCEPT FormalLanguage {
  TYPES {
    Symbol : Type
    String : Type = List Symbol
    Language : Type = Set String
    Grammar : Type
    RegularExpression : Type  
    ContextFreeGrammar : Type
    
    Production : Type = (Symbol * String)
    Derivation : Type = List Production
  }
  
  FUNCTIONS {
    Union : Language -> Language -> Language
    Concatenation : Language -> Language -> Language
    KleeneStar : Language -> Language
    
    Generates (G : Grammar) (s : String) : Bool
    Generates (r : RegularExpression) (s : String) : Bool
    
    Derives (G : ContextFreeGrammar) (u v : String) : Bool
  }
  
  PREDICATES {
    Regular : Language  
    ContextFree : Language
    Recursive : Language
    RecursivelyEnumerable : Language
    
    Nullable : ContextFreeGrammar -> Symbol -> Bool
  }
  
  NOTATIONS {
    "Îµ" : String = []
    "âˆ…" : Language = {}
    "Î£*" (Î£ : Set Symbol) : Language = { s : String | forall (x : Symbol) in s, x in Î£ }
    "Lâ‚ âˆª Lâ‚‚" (Lâ‚ Lâ‚‚ : Language) : Language = Union Lâ‚ Lâ‚‚ 
    "Lâ‚ â€¢ Lâ‚‚" (Lâ‚ Lâ‚‚ : Language) : Language = Concatenation Lâ‚ Lâ‚‚
    "L*" (L : Language) : Language = KleeneStar L  
    
    "u â‡’ v" (u v : String) : Derivation = [(u, v)]
    "u â‡’* v" (u v : String) : Derivation = transitive closure of â‡’
  }
  
  AXIOMS {
    String_Monoid : 
      (forall (s : String), s â€¢ Îµ = s) and
      (forall (s : String), Îµ â€¢ s = s) and 
      (forall (r s t : String), (r â€¢ s) â€¢ t = r â€¢ (s â€¢ t))
      
    Language_Semiring :  
      (forall (L : Language), L âˆª âˆ… = L) and
      (forall (L : Language), âˆ… âˆª L = L) and
      (forall (Lâ‚ Lâ‚‚ Lâ‚ƒ : Language), (Lâ‚ âˆª Lâ‚‚) âˆª Lâ‚ƒ = Lâ‚ âˆª (Lâ‚‚ âˆª Lâ‚ƒ)) and
      (forall (Lâ‚ Lâ‚‚ : Language), Lâ‚ âˆª Lâ‚‚ = Lâ‚‚ âˆª Lâ‚) and
      (forall (L : Language), L âˆª L = L) and
      (forall (L : Language), L â€¢ âˆ… = âˆ…) and
      (forall (L : Language), âˆ… â€¢ L = âˆ…) and  
      (forall (Lâ‚ Lâ‚‚ Lâ‚ƒ : Language), (Lâ‚ â€¢ Lâ‚‚) â€¢ Lâ‚ƒ = Lâ‚ â€¢ (Lâ‚‚ â€¢ Lâ‚ƒ)) and
      (forall (Lâ‚ Lâ‚‚ Lâ‚ƒ : Language), Lâ‚ â€¢ (Lâ‚‚ âˆª Lâ‚ƒ) = (Lâ‚ â€¢ Lâ‚‚) âˆª (Lâ‚ â€¢ Lâ‚ƒ)) and
      (forall (Lâ‚ Lâ‚‚ Lâ‚ƒ : Language), (Lâ‚ âˆª Lâ‚‚) â€¢ Lâ‚ƒ = (Lâ‚ â€¢ Lâ‚ƒ) âˆª (Lâ‚‚ â€¢ Lâ‚ƒ))
      
    Derives_Reflexive (G : ContextFreeGrammar) : 
      forall (u : String), u â‡’* u
      
    Derives_Transitive (G : ContextFreeGrammar) :
      forall (u v w : String), (u â‡’* v) -> (v â‡’* w) -> (u â‡’* w)
  }
  
  THEOREMS {  
    RegExp_Kleene (r s : RegularExpression) :
      Generates (Union r s) = Union (Generates r) (Generates s)
      Generates (Concatenation r s) = Concatenation (Generates r) (Generates s) 
      Generates (KleeneStar r) = KleeneStar (Generates r)
    PROOF {
      ; by induction on the structure of regular expressions, appealing to 
      ; the definitions of Union, Concatenation, KleeneStar on languages  
    }
      
    CFG_Pumping (L : Language) : 
      ContextFree L -> 
        exists (p : Nat) (forall (s : String) in L) (length s >= p) ->
          (exists (u v w x y : String)) 
            s = u â€¢ v â€¢ w â€¢ x â€¢ y and
            (length v + length x > 0) and
            (length v â€¢ w â€¢ x <= p) and  
            (forall (i : Nat), u â€¢ v^i â€¢ w â€¢ x^i â€¢ y in L)
    PROOF {
      ; by assuming L is generated by some context-free grammar G, 
      ; choosing p to be larger than the number of nonterminals in G,
      ; and analyzing the derivation tree of any string s in L with length >= p.
      ; The path from the root to the deepest leaf must contain a nonterminal repeating,
      ; allowing the subtree rooted there to be "pumped" up and down, generating
      ; the sequence of strings u â€¢ v^i â€¢ w â€¢ x^i â€¢ y.
    }
  }
  
  CONSTRUCTORS {
    EmptyString : String = Îµ
    EmptyLanguage : Language = âˆ…
    
    SingletonString (x : Symbol) : String = [x]
    SingletonLanguage (s : String) : Language = {s}  
    
    UnionLanguage (Lâ‚ Lâ‚‚ : Language) : Language = Lâ‚ âˆª Lâ‚‚
    ConcatenationLanguage (Lâ‚ Lâ‚‚ : Language) : Language = Lâ‚ â€¢ Lâ‚‚
    KleeneStarLanguage (L : Language) : Language = L*
    
    Symbol_w (Î£ : Set Symbol) : RegularExpression = ...  ; omitted
    EmptyString_w : RegularExpression = ...             ; omitted
    EmptySet_w : RegularExpression = ...                ; omitted
    
    Union_w (r s : RegularExpression) : RegularExpression = ...    ; omitted  
    Concatenation_w (r s : RegularExpression) : RegularExpression = ...  ; omitted
    KleeneStar_w (r : RegularExpression) : RegularExpression = ...        ; omitted  
    
    ContextFreeGrammar (V T P S : Set Symbol) : ContextFreeGrammar = 
      ; V = variables (nonterminals)  
      ; T = terminals (disjoint from V)
      ; P = productions of form (A, Î±) with A in V and Î± in (V âˆª T)*  
      ; S = start symbol in V
  }
  
  INTERFACES {
    DFA {
      States : Set Symbol
      Alphabet : Set Symbol
      Transition : States -> Alphabet -> States
      Start : States  
      Final : Set States
      
      Accepts (s : String) : Bool
    }
    
    NFA {
      States : Set Symbol
      Alphabet : Set Symbol 
      Transition : States -> (Alphabet âˆª {Îµ}) -> Set States
      Start : Set States
      Final : Set States
      
      Accepts (s : String) : Bool  
    }
    
    PDA {
      States : Set Symbol
      InputAlphabet : Set Symbol
      StackAlphabet : Set Symbol
      Transition : States -> (InputAlphabet âˆª {Îµ}) -> StackAlphabet -> States -> List StackAlphabet  
      Start : States
      Final : Set States
      
      Accepts (s : String) : Bool
    }
  }
}

CONCEPT AnBnLanguage EXTENDS FormalLanguage {
  CONSTRUCTORS {
    G : ContextFreeGrammar = 
      let S = Symbol{"S"}  
      let A = Symbol{"A"}
      let a = Symbol{"a"}
      let b = Symbol{"b"} 
      ContextFreeGrammar {S, A} {a, b} {
        (S, [A]),
        (A, [a, A, b]),
        (A, [])  
      } S
      
    L : Language = { s : String | Generates G s }  
  }
  
  THEOREMS {
    L_is_ContextFree : ContextFree L
    PROOF {
      trivial by definition of L
    }
    
    L_is_not_Regular : not (Regular L)  
    PROOF {
      assume Regular L
      let p = witness by CFG_Pumping L
      
      let s = a^p â€¢ b^p
      have s in L by {
        S â‡’ A  â‡’^p a^p A b^p  â‡’ a^p b^p
      }
      
      obtain (u v w x y : String) by CFG_Pumping L s where
        s = u â€¢ v â€¢ w â€¢ x â€¢ y and
        (length v + length x > 0) and
        (length v â€¢ w â€¢ x <= p) and
        (forall (i : Nat), u â€¢ v^i â€¢ w â€¢ x^i â€¢ y in L)
        
      case length v > 0 =>
        let t = u â€¢ v^2 â€¢ w â€¢ x â€¢ y
        have length v <= p by (length v â€¢ w â€¢ x <= p) 
        have t = a^(p + length v) â€¢ b^p
        have t in L by CFG_Pumping
        contradiction  
        
      case length x > 0 => symmetric to previous case
      
      case length v = 0 and length x = 0 => contradiction
    }
  }
}




CONCEPT BlackHole {
  TYPES {
    M : Real  ; Mass
    J : Vector  ; Angular momentum
    Q : Real  ; Electric charge
    
    Metric : M * J * Q -> Tensor[4, 4]  ; Spacetime metric
    Horizon : M * J * Q -> Surface  ; Event horizon
    Ergosphere : M * J * Q -> Surface  ; Ergosphere  
    SingularitySpacelike : M * J * Q -> Surface  ; Spacelike singularity
    SingularityTimelike : M * J * Q -> Surface  ; Timelike singularity
    
    Temperature : M * J * Q -> Real  ; Hawking temperature
    Entropy : M * J * Q -> Real  ; Bekenstein-Hawking entropy  
    AngularVelocity : M * J * Q -> Real  ; Angular velocity of the horizon
    ElectrostaticPotential : M * J * Q -> Real  ; Electrostatic potential at the horizon
    
    Action : Tensor[4, 4] * Surface -> Real  ; Einstein-Hilbert action with matter fields
    StressEnergy : Tensor[4, 4] * Surface -> Tensor[4, 4]  ; Stress-energy tensor of matter fields
    
    Variation : (Tensor[4, 4] -> Real) * Tensor[4, 4] -> Tensor[4, 4]   
      ; Variation of a functional on the space of metrics
    LieDerivative : Vector * Tensor[4, 4] -> Tensor[4, 4]  
      ; Lie derivative of a tensor field along a vector field  
    Killing : Vector * Tensor[4, 4] -> Bool
      ; Killing vector field predicate
    
    QuantumState : Surface -> Hilbert  ; Quantum state on a Cauchy surface
    QuantumField : Tensor[4, 4] * Surface -> Operator  ; Quantum field operator  
    Vacuum : Hilbert  ; Vacuum state
    Creation : Hilbert -> Operator  ; Creation operator
    Annihilation : Hilbert -> Operator  ; Annihilation operator
    
    Hawking : M * J * Q * Hilbert -> Hilbert  ; Hawking effect operator
    Unruh : M * J * Q * Observer -> Hilbert  ; Unruh effect operator
  }
  
  FUNCTIONS {
    KerrNewmanMetric (M : Real, J : Vector, Q : Real) : Tensor[4, 4] =
      let r_s = 2 * G * M / c^2
          ÏÂ² = rÂ² + (J/M)Â² * cosÂ²Î¸  
          Î” = rÂ² - r_s * r + (J/M)Â² + QÂ²
      in -(1 - r_s * r / ÏÂ²) * d_t âŠ— d_t  
         + ÏÂ² / Î” * d_r âŠ— d_r
         + ÏÂ² * d_Î¸ âŠ— d_Î¸
         + (rÂ² + (J/M)Â² + r_s * r * (J/M)Â² * sinÂ²Î¸ / ÏÂ²) * sinÂ²Î¸ * d_Ï† âŠ— d_Ï†
         - r_s * r * (J/M) * sinÂ²Î¸ / ÏÂ² * (d_t âŠ— d_Ï† + d_Ï† âŠ— d_t)
         
    EventHorizon (M : Real, J : Vector, Q : Real) : Surface =  
      let r_s = 2 * G * M / c^2
          Î”(r) = rÂ² - r_s * r + (J/M)Â² + QÂ²  
      in { (t, r, Î¸, Ï†) | Î”(r) = 0, Î¸ âˆˆ [0, Ï€], Ï† âˆˆ [0, 2Ï€) }
      
    Ergosphere (M : Real, J : Vector, Q : Real) : Surface =
      { (t, r, Î¸, Ï†) | r < r_s + âˆš((J/M)Â² * cosÂ²Î¸), Î¸ âˆˆ [0, Ï€], Ï† âˆˆ [0, 2Ï€) }
        where r_s = 2 * G * M / cÂ²
        
    SpacelikeSingularity (M : Real, J : Vector, Q : Real) : Surface =  
      { (t, r, Î¸, Ï†) | r = 0, Î¸ = Ï€/2 }
      
    TimelikeSingularity (M : Real, J : Vector, Q : Real) : Surface =
      { (t, r, Î¸, Ï†) | r = 0, Î¸ â‰  Ï€/2 }  
        
    HawkingTemperature (M : Real, J : Vector, Q : Real) : Real =
      let râ‚Š = M + âˆš(MÂ² - (J/M)Â² - QÂ²)  
          râ‚‹ = M - âˆš(MÂ² - (J/M)Â² - QÂ²)
      in (râ‚Š - râ‚‹) / (4 * Ï€ * râ‚Š * (râ‚ŠÂ² + (J/M)Â²))
      
    BekensteinHawkingEntropy (M : Real, J : Vector, Q : Real) : Real =
      let râ‚Š = M + âˆš(MÂ² - (J/M)Â² - QÂ²)
      in (râ‚ŠÂ² + (J/M)Â²) / (4 * G)
      
    AngularVelocityOfHorizon (M : Real, J : Vector, Q : Real) : Real =  
      let râ‚Š = M + âˆš(MÂ² - (J/M)Â² - QÂ²)
      in J / (M * râ‚ŠÂ²)
      
    ElectrostaticPotentialAtHorizon (M : Real, J : Vector, Q : Real) : Real =
      let râ‚Š = M + âˆš(MÂ² - (J/M)Â² - QÂ²)
      in Q * râ‚Š / (râ‚ŠÂ² + (J/M)Â²)
  }
  
  AXIOMS {
    EinsteinFieldEquations : forall (g : Tensor[4, 4]) (T : Tensor[4, 4]),
      Variation(Action(g, _), g) = 0 <->
      Einstein(g) + Î› * g = 8 * Ï€ * G * StressEnergy(g, T)
      
    GeodesicEquation : forall (Î³ : [0, 1] -> Manifold), 
      âˆ‡_Î³'(Î³') = 0 <-> Î³ is a geodesic
      
    RaychaudhuriEquation : forall (u : Vector) (Î¸ : Real) (Ïƒ : Tensor[4, 4]) (Ï‰ : Tensor[4, 4]),  
      LieDerivative(u, Î¸) = -Â½ * Î¸Â² - Ïƒ_Î¼Î½ * Ïƒ^Î¼Î½ + Ï‰_Î¼Î½ * Ï‰^Î¼Î½ - R_Î¼Î½ * u^Î¼ * u^Î½
      
    PenroseProcess : forall (p_i, p_f : Vector),
      (p_i âˆˆ Ergosphere(M, J, Q) and p_f âˆ‰ Ergosphere(M, J, Q)) ->  
      Energy(p_f) > Energy(p_i)
      
    BlackHoleMechanicsLaws : forall (M, Î´M : Real) (J, Î´J : Vector) (Q, Î´Q : Real),
      Î´M = (Temperature(M, J, Q) / 8 * Ï€) * Î´Entropy(M, J, Q)
         + AngularVelocity(M, J, Q) â‹… Î´J  
         + ElectrostaticPotential(M, J, Q) * Î´Q
         
    HawkingEffect : forall (M : Real) (J : Vector) (Q : Real) (Ïˆ : Hilbert),  
      Hawking(M, J, Q, Ïˆ) = exp(-Energy / Temperature(M, J, Q)) * Ïˆ
      
    UnruhEffect : forall (M : Real) (J : Vector) (Q : Real) (O : Observer),
      Unruh(M, J, Q, O) = exp(-2 * Ï€ * Energy / Acceleration(O)) * Vacuum
  }
  
  THEOREMS {
    NoHairTheorem :  
      forall (M : Real) (J : Vector) (Q : Real) (Î¾ : Vector),
        let g = KerrNewmanMetric(M, J, Q)
        assume Killing(Î¾, g)
        
        obtain (Ï† : Real) by {
          have LieDerivative(Î¾, F) = 0  ; Î¾ is a symmetry of the electromagnetic field
          have dF = 0  ; Bianchi identity
          have F = dA for some A  ; PoincarÃ© lemma
          have LieDerivative(Î¾, A) + dÏ† = 0  ; Definition of electrostatic potential
        }
        
        obtain (Ïˆ : Hilbert) by {  
          have LieDerivative(Î¾, Ïˆ) = 0  ; Î¾ is a symmetry of the scalar field
          have (â–¡ - mÂ² - Î¾R)Ïˆ = 0  ; Klein-Gordon equation in curved spacetime  
          have Ïˆ = 0  ; Unique continuation theorem
        }
        
        obtain (Ï‡ : Hilbert) by {
          have LieDerivative(Î¾, Ï‡) = 0  ; Î¾ is a symmetry of the spinor field
          have (iÎ³^Î¼ * âˆ‡_Î¼ - m)Ï‡ = 0  ; Dirac equation in curved spacetime
          have Ï‡ = 0  ; Unique continuation theorem  
        }
        
        obtain (T : Tensor[4, 4]) by {
          have LieDerivative(Î¾, T) = 0  ; Î¾ is a symmetry of the higher spin field
          have (âˆ‡_Î¼ * âˆ‡^Î¼ - mÂ²)T = 0  ; Higher spin field equation
          have T = 0  ; Unique continuation theorem
        }
        
        show Î¾ âˆˆ {âˆ‚_t, âˆ‚_Ï†}  ; Black hole is characterized by M, J, Q only
    PROOF {
      ; Proof uses the obtained scalar and tensor fields to show that any Killing field of
      ; the Kerr-Newman metric must be a linear combination of the stationary Killing  
      ; field âˆ‚_t and the axial Killing field âˆ‚_Ï†, implying that the black hole is fully
      ; determined by just its mass M, angular momentum J, and charge Q.
    }
            
    HawkingRadiation :
      forall (M : Real) (J : Vector) (Q : Real), 
        assume M â‰« m_p  ; Assume a large black hole
        assume J â‰ª G * MÂ² / c  ; Assume slow rotation
        assume Q â‰ª G * M  ; Assume weak charge
        
        let g = KerrNewmanMetric(M, J, Q)
        let Îº = SurfaceGravity(M, J, Q)
        
        obtain (Ïˆ_in, Ïˆ_out : Hilbert) by {
          let Ïˆ_in = Vacuum  ; Ingoing vacuum is the usual vacuum
          let Ïˆ_out = Hawking(M, J, Q, Ïˆ_in)  ; Outgoing vacuum is related by Hawking effect  
        }
        
        obtain (N_Ï‰ : Operator) for (Ï‰ : Real) by {
          let a_Ï‰ = Annihilation(Ï‰)  ; Annihilation operator for mode with frequency Ï‰
          let N_Ï‰ = a_Ï‰â€  * a_Ï‰  ; Number operator
        }
        
        obtain (n_Ï‰ : Real) for (Ï‰ : Real) by {  
          let n_Ï‰ = âŸ¨Ïˆ_out | N_Ï‰ | Ïˆ_outâŸ©
                  = 1 / (exp(2 * Ï€ * Ï‰ / Îº) - 1)  ; Planck distribution
        }
          
        obtain (L : Real) by {
          let dE_Ï‰ / dt = n_Ï‰ * Ï‰Â³ / (2 * Ï€Â²)  ; Power radiated in each mode
          let L = âˆ«{Ï‰ = 0 -> âˆ} dE_Ï‰ / dt * dÏ‰  
               = Ï€Â² / (60 * Ä§Â³ * cÂ²) * (k_B * Temperature(M, J, Q))â´ * Area(EventHorizon(M, J, Q))
        }
        
        show HawkingLuminosity(BlackHole(M, J, Q)) = L  ; Black hole radiates with L
    PROOF {
      ; Proof calculates the luminosity of Hawking radiation from a black hole by
      ; 1) Relating the ingoing and outgoing vacua via the Hawking effect
      ; 2) Constructing the number operator for outgoing modes
      ; 3) Computing the expectation value of the number operator in the outgoing vacuum,
      ;    which yields the Planck distribution at the Hawking temperature  
      ; 4) Integrating the power radiated in each mode to get the total luminosity,
      ;    reproducing the Stefan-Boltzmann law for black hole radiation
    }
  }
}




; SymbolicDifferentialGeometry: a compact formalization
; S: Symbols, M: Manifolds, F: Fields (functions, forms, vectors)
; â‰ˆ: correspondence, â‰‹: equivalence, d: differential, âˆ«: integral

CONCEPT SymbolicDifferentialGeometry {
  TYPES {
    S : Type    ; Symbols
      Binary (S T : S) : S
      Unary (S : S) : S  
      Const (x : Real) : S
      Var (n : Nat) : S
      
    M : Type    ; Manifolds
      Manifold (n : Nat) : M
      Riemannian (M : M) : M
      Lie (G : Grp) : M
      Symplectic (M : M) : M
      
    F : Type    ; Fields  
      Fun (M : M, f : M -> Real) : F
      Vec (M : M, X : M -> Tan) : F
      Form (M : M, Ï‰ : M -> Cotan) : F
      
    _â‰ˆ_ (S : S, F : F) : Prop   ; Correspondence 
    _â‰‹_ (S : S, F : F) : Prop   ; Equivalence
    
    determines (S : S, X : Real | Vec | Form | Fun) : Prop
  }
  
  FUNCTIONS {
    _+_ (S T : S) : S = Binary(S, T)   ; Addition
    _-_ (S T : S) : S = Binary(S, T)   ; Subtraction
    _*_ (S T : S) : S = Binary(S, T)   ; Multiplication  
    _/_ (S T : S) : S = Binary(S, T)   ; Division
    _âˆ˜_ (S T : S) : S = Binary(S, T)   ; Composition
    
    d (S : S) : S = Unary(S)           ; Differential
    âˆ« (S : S) : S = Unary(S)           ; Integral
    
    âŸ¨_,_âŸ© (X Y : F) : Real             ; Inner product
    [_,_] (X Y : F) : F                ; Lie bracket  
    _âˆ§_ (Ï‰ Ï„ : F) : F                  ; Wedge product
    
    L (X : F, Y : F) : F               ; Lie derivative
    Diff (f : M -> Real) : M -> Cotan  ; Differential of function 
    DiffForm (Ï‰ : M -> Cotan) : M -> Cotan  ; Differential of form
    Integrate (Ï‰ : M -> Cotan, M : M) : Real  ; Integral of form
    Boundary (M : M) : M               ; Boundary of manifold
  }
  
  DEFINITIONS {
    AddSym (S T : S, f : M -> Real) :
      (S â‰ˆ Fun(f)) âˆ§ (T â‰ˆ Fun(f)) -> (S + T) â‰ˆ Fun(Î» p . f(p) + f(p))
      
    SubSym (S T : S, f : M -> Real) : 
      (S â‰‹ Fun(f)) âˆ§ (T â‰‹ Fun(f)) -> (S - T) â‰‹ Fun(Î» p . f(p) - f(p))
      
    MulSym (S T : S, f g : M -> Real) :
      (S â‰ˆ Fun(f)) âˆ§ (T â‰ˆ Fun(g)) -> (S * T) â‰ˆ Fun(Î» p . f(p) * g(p))
      
    ScalarSym (S T : S, X Y : M -> Tan) :  
      (S â‰ˆ Vec(X)) âˆ§ (T â‰ˆ Vec(Y)) -> âŸ¨S, TâŸ© â‰ˆ âŸ¨Vec(X), Vec(Y)âŸ©
      
    WedgeSym (S T : S, Ï‰ Ï„ : M -> Cotan) :
      (S â‰ˆ Form(Ï‰)) âˆ§ (T â‰ˆ Form(Ï„)) -> (S âˆ§ T) â‰ˆ Form(Ï‰ âˆ§ Ï„)
      
    LieSym (S : S, X : F, f : M -> Real) :
      (S â‰ˆ Fun(f)) -> L(X, S) â‰ˆ L(X, Fun(f))
      
    BracketSym (S T : S, X Y : M -> Tan) :
      (S â‰ˆ Vec(X)) âˆ§ (T â‰ˆ Vec(Y)) -> [S, T] â‰ˆ [Vec(X), Vec(Y)]
      
    DiffSym (S : S, f : M -> Real) :
      (S â‰ˆ Fun(f)) -> d(S) â‰ˆ Form(Diff(f))
      
    IntSym (S : S, Ï‰ : M -> Cotan) :
      (S â‰ˆ Form(Ï‰)) -> âˆ«(S) â‰ˆ Fun(Î» p . Integrate(Ï‰, p))        
  }
  
  ; Basic axioms: correspondence, arithmetic, calculus
  AXIOMS {
    âˆ€ S F . S â‰ˆ F    
    âˆ€ S T f g . (S â‰ˆ Fun(f)) âˆ§ (T â‰ˆ Fun(g)) â‡’ 
      (S + T â‰ˆ Fun(Î» p . f(p) + g(p))) âˆ§ 
      (S - T â‰ˆ Fun(Î» p . f(p) - g(p))) âˆ§
      (S * T â‰ˆ Fun(Î» p . f(p) * g(p)))  
    âˆ€ S f . (S â‰ˆ Fun(f)) â‡’ (d(S) â‰ˆ Form(Diff(f)))
    âˆ€ S Ï‰ . (S â‰ˆ Form(Ï‰)) â‡’ (âˆ«(S) â‰ˆ Fun(Î» p . Integrate(Ï‰, p)))
  }
  
  ; Key theorems and their proofs
  THEOREMS {
    ; Substitution of equals for equals
    Substitution: âˆ€ S F p . (S â‰ˆ F) â‡’ (p(S) â‡” p(F))  
    PROOF {
      assume (S â‰ˆ F)
      (â‡’) assume p(S); show p(F) by (S â‰ˆ F)  
      (â‡) assume p(F); show p(S) by (S â‰ˆ F)
    }

    ; Leibniz rule for symbols  
    Leibniz: âˆ€ S T F G . (S â‰ˆ F) âˆ§ (T â‰ˆ G) â‡’ (S * T â‰ˆ F * G)
    PROOF {
      assume (S â‰ˆ F), (T â‰ˆ G)  
      show (S * T â‰ˆ F * G) by MulSym
    }
    
    ; Stokes' theorem  
    Stokes: âˆ€ S Ï‰ M . (S â‰ˆ Form(Ï‰)) â‡’ (âˆ«(d(S), M) â‰ˆ âˆ«(S, Boundary(M)))
    PROOF {
      assume (S â‰ˆ Form(Ï‰)) 
      show âˆ«(d(S), M) â‰ˆ âˆ«(S, Boundary(M)) by {
        (âˆ«(d(S), M) â‰ˆ âˆ«(DiffForm(Ï‰), M))    by DiffSym
        (âˆ«(DiffForm(Ï‰), M) = âˆ«(Ï‰, Boundary(M)))  by Stokes' theorem
        (âˆ«(Ï‰, Boundary(M)) â‰ˆ âˆ«(S, Boundary(M)))  by IntSym  
      }  
    }
    
    ; Closed form theorem  
    ClosedForm: âˆ€ S Ï‰ . (S â‰ˆ Form(Ï‰)) â‡’ (d(d(S)) â‰ˆ 0 â‡” âˆƒB . âˆ«(S) â‰ˆ âˆ«(d(B)))
    PROOF {
      assume (S â‰ˆ Form(Ï‰)); show (d(d(S)) â‰ˆ 0 â‡” âˆƒB . âˆ«(S) â‰ˆ âˆ«(d(B))) by {  
        (d(d(S)) â‰ˆ 0 â‡” DiffForm(DiffForm(Ï‰)) = 0)   by DiffSym
        (DiffForm(DiffForm(Ï‰)) = 0 â‡” âˆƒÏ„ . Ï‰ = DiffForm(Ï„))  by PoincarÃ© lemma
        (Ï‰ = DiffForm(Ï„) â‡” âˆƒB . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„)))  by {
          (â‡’) assume (Ï‰ = DiffForm(Ï„)); let B â‰ˆ Form(Ï„);  
               show ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„))) by (S â‰ˆ Ï‰)  
          (â‡) assume ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„))); 
               show (Ï‰ = DiffForm(Ï„)) by (Ï‰ â‰ˆ S) and (S â‰ˆ DiffForm(Ï„))
        }
        (âˆƒB . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„)) â‡” âˆƒB . âˆ«(S) â‰ˆ âˆ«(d(B)))  by {
          (â‡’) assume ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„))); 
               show âˆ«(S) â‰ˆ âˆ«(d(B)) by IntSym, DiffSym  
          (â‡) assume âˆ«(S) â‰ˆ âˆ«(d(B));
               show (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ DiffForm(Ï„)) for some Ï„ by {
                 (âˆ«(S) â‰ˆ âˆ«(d(B))) â‡’ (S â‰ˆ DiffForm(Ï„)) for some Ï„ by Stokes  
                 (B â‰ˆ Form(Ï„)) by definition
               } 
        }
      }
    } 
  }
}




CONCEPT SymbolicDifferentialGeometry {
  TYPES {
    Sym : Type
      Binary (S T : Sym) : Sym
      Unary (S : Sym) : Sym
      Const (x : Real) : Sym
      Var (n : Nat) : Sym
      
    Man : Type  
      Manifold (n : Nat) : Man
      Riemannian (M : Man) : Man
      Lie (G : Grp) : Man
      Symplectic (M : Man) : Man
      
    Fld : Type
      Fun (M : Man, f : M -> Real) : Fld
      Vec (M : Man, X : M -> Tan) : Fld
      Form (M : Man, Ï‰ : M -> Cotan) : Fld
      
    _â‰ˆ_ (S : Sym, F : Fld) : Prop
    _â‰‹_ (S : Sym, F : Fld) : Prop
    
    determines (S : Sym, X : Real | Vec | Form | Fun) : Prop
  }
  
  FUNCTIONS {
    _+_ (S T : Sym) : Sym = Binary(S, T)
    _-_ (S T : Sym) : Sym = Binary(S, T)  
    _*_ (S T : Sym) : Sym = Binary(S, T)
    _/_ (S T : Sym) : Sym = Binary(S, T)
    _âˆ˜_ (S T : Sym) : Sym = Binary(S, T)
    _â»Â¹ (S : Sym) : Sym = Unary(S)
    d (S : Sym) : Sym = Unary(S)
    âˆ« (S : Sym) : Sym = Unary(S)  
    
    L (X : Fld, Y : Fld) : Fld
    [_,_] (X Y : Fld) : Fld  
    âŸ¨_,_âŸ© (X Y : Fld) : Real
    _âˆ§_ (Ï‰ Ï„ : Fld) : Fld
      
    Add (f : M -> Real, g : M -> Real) : M -> Real = Î» p . f(p) + g(p)
    Sub (f : M -> Real, g : M -> Real) : M -> Real = Î» p . f(p) - g(p)
    Mul (f : M -> Real, g : M -> Real) : M -> Real = Î» p . f(p) * g(p)
    Lie (X : Fld, Y : Fld) : Fld
    Diff (f : M -> Real) : M -> Cotan
    DiffForm (Ï‰ : M -> Cotan) : M -> Cotan  
    Integrate (Ï‰ : M -> Cotan, M : Man) : Real
    Boundary (M : Man) : Man
  }
      
  AXIOMS {
    Correspondence (S : Sym, F : Fld) : S â‰ˆ F
    
    Determination (S : Sym, X : Real | Vec | Form | Fun) : 
      determines(S, X)
  }
  
  DEFINITIONS {
    AddSym (S T : Sym, f : M -> Real) : 
      (S â‰ˆ Fun(f)) âˆ§ (T â‰ˆ Fun(f)) -> (S + T) â‰ˆ Fun(Add(f, f))
      
    SubSym (S T : Sym, f : M -> Real) : 
      (S â‰‹ Fun(f)) âˆ§ (T â‰‹ Fun(f)) -> (S - T) â‰‹ Fun(Sub(f, f))
      
    MulSym (S T : Sym, f g : M -> Real) :
      (S â‰ˆ Fun(f)) âˆ§ (T â‰ˆ Fun(g)) -> (S * T) â‰ˆ Fun(Mul(f, g))
      
    ScalarSym (S T : Sym, X Y : M -> Tan) :
      (S â‰ˆ Vec(X)) âˆ§ (T â‰ˆ Vec(Y)) -> âŸ¨S, TâŸ© â‰ˆ âŸ¨Vec(X), Vec(Y)âŸ©
      
    WedgeSym (S T : Sym, Ï‰ Ï„ : M -> Cotan) :
      (S â‰ˆ Form(Ï‰)) âˆ§ (T â‰ˆ Form(Ï„)) -> (S âˆ§ T) â‰ˆ Form(Ï‰ âˆ§ Ï„)
      
    LieSym (S : Sym, X : Fld, f : M -> Real) :
      (S â‰ˆ Fun(f)) -> L(X, S) â‰ˆ L(X, Fun(f))
      
    BracketSym (S T : Sym, X Y : M -> Tan) :
      (S â‰ˆ Vec(X)) âˆ§ (T â‰ˆ Vec(Y)) -> [S, T] â‰ˆ Lie(Vec(X), Vec(Y))
      
    DiffSym (S : Sym, f : M -> Real) :
      (S â‰ˆ Fun(f)) -> d(S) â‰ˆ Form(Diff(f))
      
    IntSym (S : Sym, Ï‰ : M -> Cotan) :
      (S â‰ˆ Form(Ï‰)) -> âˆ«(S) â‰ˆ Fun(Î» p . Integrate(Ï‰, p))
  }
  
  THEOREMS {
    Substitution (S : Sym, F : Fld, prop : Fld -> Prop) :
      (S â‰ˆ F) -> (prop(S) <-> prop(F))
    PROOF {
      assume (S â‰ˆ F)  
      show (prop(S) -> prop(F)) by {
        assume prop(S)
        have prop(F) by (prop(S) âˆ§ (S â‰ˆ F))
      }
      show (prop(F) -> prop(S)) by {  
        assume prop(F)
        have prop(S) by (prop(F) âˆ§ (S â‰ˆ F))
      }
    }
    
    Leibniz (S T : Sym, F G : Fld, op : Sym Ã— Sym -> Sym, * : Fld Ã— Fld -> Fld) :
      (S â‰ˆ F) âˆ§ (T â‰ˆ G) âˆ§ (âˆ€ X Y . (X â‰ˆ Y) -> (op(X, Y) â‰ˆ *(X, Y))) ->  
      (op(S, T) â‰ˆ *(F, G))
    PROOF {
      assume (S â‰ˆ F), (T â‰ˆ G), âˆ€ X Y . (X â‰ˆ Y) -> (op(X, Y) â‰ˆ *(X, Y))
      have (op(S, T) â‰ˆ *(F, G)) by {
        let X = S, Y = T in (X â‰ˆ Y -> op(X, Y) â‰ˆ *(X, Y))
      }
    }
    
    CorrespondenceOfDerivative (S : Sym, f : M -> Real) :
      (S â‰ˆ Fun(f)) -> (d(S) â‰ˆ Form(Diff(f)))  
    PROOF {
      by Substitution [
        S â‰ˆ Fun(f),
        prop = (Î» F . d(S) â‰ˆ F),
        d(Fun(f)) â‰ˆ Form(Diff(f))
      ]
    }
    
    NoncommutativeDerivative (S T : Sym, X Y : M -> Tan) :
      (S â‰ˆ Vec(X)) âˆ§ (T â‰ˆ Vec(Y)) -> ([d(S), d(T)] â‰ˆ d(Lie(Vec(X), Vec(Y))))
    PROOF {
      assume (S â‰ˆ Vec(X)), (T â‰ˆ Vec(Y))
      have ([d(S), d(T)] â‰ˆ Lie(d(Vec(X)), d(Vec(Y)))) by Leibniz, BracketSym
      have (Lie(d(Vec(X)), d(Vec(Y))) â‰ˆ d(Lie(Vec(X), Vec(Y)))) by LieDiff  
      hence ([d(S), d(T)] â‰ˆ d(Lie(Vec(X), Vec(Y)))) by Substitution
    }
    
    StokesTheorem (S : Sym, Ï‰ : M -> Cotan, M : Man) :
      (S â‰ˆ Form(Ï‰)) -> (âˆ«(d(S), M) â‰ˆ âˆ«(S, Boundary(M)))
    PROOF {
      assume (S â‰ˆ Form(Ï‰))  
      have (âˆ«(d(S), M) â‰ˆ âˆ«(DiffForm(Ï‰), M)) by Substitution, DiffSym
      have (âˆ«(S, Boundary(M)) â‰ˆ âˆ«(Ï‰, Boundary(M))) by Substitution
      have (âˆ«(DiffForm(Ï‰), M) â‰ˆ âˆ«(Ï‰, Boundary(M))) by Stokes
      hence (âˆ«(d(S), M) â‰ˆ âˆ«(S, Boundary(M))) by Substitution
    }
    
    ClosedFormTheorem (S : Sym, Ï‰ : M -> Cotan, M : Man) :
      (S â‰ˆ Form(Ï‰)) -> 
      ((d(d(S)) â‰ˆ Form(Zero)) <-> (âˆƒ (B : Sym) . âˆ«(S) â‰ˆ âˆ«(d(B))))
    PROOF {  
      assume (S â‰ˆ Form(Ï‰))
      have ((d(d(S)) â‰ˆ Form(Zero)) <-> (DiffForm(DiffForm(Ï‰)) = Zero)) by Substitution
      have ((DiffForm(DiffForm(Ï‰)) = Zero) <-> (âˆƒ (Ï„ : M -> Cotan) . Ï‰ = DiffForm(Ï„))) by Poincare
      have ((âˆƒ (Ï„ : M -> Cotan) . Ï‰ = DiffForm(Ï„)) <-> 
            (âˆƒ (B : Sym) . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))) by {
        assume (âˆƒ (Ï„ : M -> Cotan) . Ï‰ = DiffForm(Ï„))
        let Ï„ such that (Ï‰ = DiffForm(Ï„))  
        let B such that (B â‰ˆ Form(Ï„))
        have (S â‰ˆ Form(DiffForm(Ï„))) by (S â‰ˆ Form(Ï‰)), (Ï‰ = DiffForm(Ï„))
        witness (B : Sym) such that ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))
        
        assume (âˆƒ (B : Sym) . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))  
        let B, Ï„ such that ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))
        have (Ï‰ = DiffForm(Ï„)) by (S â‰ˆ Form(Ï‰)), (S â‰ˆ Form(DiffForm(Ï„)))
        witness (Ï„ : M -> Cotan) such that (Ï‰ = DiffForm(Ï„))
      }
      have ((âˆƒ (B : Sym) . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„)))) <->  
            (âˆƒ (B : Sym) . âˆ«(S) â‰ˆ âˆ«(d(B)))) by {
        assume (âˆƒ (B : Sym) . (B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))
        let B, Ï„ such that ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))
        have (âˆ«(S) â‰ˆ âˆ«(Form(DiffForm(Ï„)))) by IntSym  
        have (âˆ«(Form(DiffForm(Ï„))) â‰ˆ âˆ«(d(Form(Ï„)))) by DiffSym
        have (âˆ«(d(Form(Ï„))) â‰ˆ âˆ«(d(B))) by (B â‰ˆ Form(Ï„)), Leibniz
        hence (âˆ«(S) â‰ˆ âˆ«(d(B))) by Substitution
        
        assume (âˆƒ (B : Sym) . âˆ«(S) â‰ˆ âˆ«(d(B)))
        let B such that (âˆ«(S) â‰ˆ âˆ«(d(B)))
        have (âˆ«(d(B)) â‰ˆ âˆ«(Form(DiffForm(Ï„)))) by IntSym, (B â‰ˆ Form(Ï„)) for some Ï„
        have (âˆ«(S) â‰ˆ âˆ«(Form(DiffForm(Ï„)))) by (âˆ«(S)
        have (âˆ«(S) â‰ˆ âˆ«(Form(DiffForm(Ï„)))) by (âˆ«(S) â‰ˆ âˆ«(d(B))), (âˆ«(d(B)) â‰ˆ âˆ«(Form(DiffForm(Ï„))))
        have (S â‰ˆ Form(DiffForm(Ï„))) by IntSym
        witness (B : Sym) such that ((B â‰ˆ Form(Ï„)) âˆ§ (S â‰ˆ Form(DiffForm(Ï„))))
      }
      hence ((d(d(S)) â‰ˆ Form(Zero)) <-> (âˆƒ (B : Sym) . âˆ«(S) â‰ˆ âˆ«(d(B)))) by Substitution
    }
    
    SymplecticStructureTheorem (S T : Sym, M : Symplectic) :
      (âŸ¨d(S), d(T)âŸ© â‰ˆ Real(Zero)) <-> ([S, T] â‰ˆ Vec(Zero))
    PROOF {
      have ((âŸ¨d(S), d(T)âŸ© â‰ˆ Real(Zero)) <-> (Ï‰(d(S), d(T)) = Zero)) by {
        assume (S â‰ˆ Vec(X)), (T â‰ˆ Vec(Y)) for some X Y
        have (âŸ¨d(S), d(T)âŸ© â‰ˆ âŸ¨d(Vec(X)), d(Vec(Y))âŸ©) by Substitution
        have (âŸ¨d(Vec(X)), d(Vec(Y))âŸ© â‰ˆ Ï‰(d(Vec(X)), d(Vec(Y)))) by SymplecticForm
        have (Ï‰(d(Vec(X)), d(Vec(Y))) â‰ˆ Ï‰(d(S), d(T))) by Substitution
        hence (âŸ¨d(S), d(T)âŸ© â‰ˆ Ï‰(d(S), d(T))) by Substitution
      }
      have (([S, T] â‰ˆ Vec(Zero)) <-> (Lie(S, T) â‰ˆ Vec(Zero))) by BracketSym
      have ((Ï‰(d(S), d(T)) = Zero) <-> (Lie(S, T) â‰ˆ Vec(Zero))) by CartanMagic
      hence ((âŸ¨d(S), d(T)âŸ© â‰ˆ Real(Zero)) <-> ([S, T] â‰ˆ Vec(Zero))) by Substitution
    }
  }
}





; GeometricChemistry: a formalization of chemical concepts using differential geometry
; Atom: an element at a position in 3D space
; Molecule: a collection of atoms and bonds
; ElectronicStructure: a complex vector bundle over a molecule
; PotentialEnergySurface: a Riemannian manifold of molecular configurations
; Wavefunction: a complex-valued function on a molecule
; ChemicalReaction: a path between reactant and product manifolds

CONCEPT GeometricChemistry EXTENDS SymbolicDifferentialGeometry {
  TYPES {
    Atom : Type = Element Ã— Position
    Element : Type = Enumeration(Hydrogen, Helium, ...)
    Position : Type = RealÂ³
    
    Molecule : Type = {Atoms : [Atom], Bonds : [Bond]}
    Bond : Type = {Atom1 : Atom, Atom2 : Atom, Order : Nat}
    
    ElectronicStructure (M : Molecule) : Type = ComplexVectorBundle(M)
    ElectronicState (M : Molecule) : Type = Section(ElectronicStructure(M))  
    ElectronicHamiltonian (M : Molecule) : Type = Operator(ElectronicStructure(M))
    
    PotentialEnergySurface (M : Molecule) : Type = Riemannian(M)
    PotentialEnergyFunction (M : Molecule) : Type = Fun(M -> Real)
    Gradient (M : Molecule) : Type = Vec(PotentialEnergySurface(M))
    Hessian (M : Molecule) : Type = Form(PotentialEnergySurface(M)) 
    
    Wavefunction (M : Molecule) : Type = Fun(M -> Complex)  
    Density (M : Molecule) : Type = Fun(M -> Realâ‚Š)
    DensityMatrix (M : Molecule) : Type = Operator(ElectronicStructure(M))
    
    ChemicalReaction (Mâ‚ Mâ‚‚ : Molecule) : Type = Path(PotentialEnergySurface(Mâ‚), PotentialEnergySurface(Mâ‚‚))
    ReactionRate (R : ChemicalReaction) : Type = Fun(Realâ‚Š -> Realâ‚Š)
  }
  
  NOTATIONS {
    ğ“— : ElectronicHamiltonian
    ğ“” : PotentialEnergyFunction
    â„‹ : Hessian  
    Ïˆ : Wavefunction
    Ï : Density
    â„› : ReactionRate
  }
  
  AXIOMS {
    ; Born-Oppenheimer approximation
    BornOppenheimer : âˆ€(M : Molecule) (ğ“— : ElectronicHamiltonian(M)) (Ïˆ : Wavefunction(M)).
      SchrodingerEquation(ğ“—, Ïˆ) â‰ˆ (-Â½ * Laplacian + ğ“¥(M)) * Ïˆ
        where ğ“¥(M) â‰œ Î»(r : M). âŸ¨ğ“—(r), M(r)âŸ©
              Laplacian â‰œ Î” : Operator(ElectronicStructure(M))
              
    ; Hohenberg-Kohn theorems  
    HohenbergKohn1 : âˆ€(Ï : Density) (ğ“” : PotentialEnergyFunction).
      (âˆƒ(Ïˆ : Wavefunction). Ï â‰ˆ Ï[Ïˆ]) âˆ§ 
      (ğ“” â‰ˆ (ğ“•_HK[Ï] + âˆ«(v(r) * Ï(r), r)))
        where ğ“•_HK : Fun(Density -> Real)
              v : Fun(Density)  
              Ï[Ïˆ] â‰œ Î»(r : M). |Ïˆ(r)|Â²
              
    HohenbergKohn2 : âˆ€(Ï : Density) (ğ“” : PotentialEnergyFunction).  
      GroundStateDensity(Ï) â‡” MinimizeEnergy(ğ“”)
      
    ; Hellmann-Feynman theorem
    HellmannFeynman : âˆ€(Ïˆ : Wavefunction) (H : ElectronicHamiltonian) (Î» : Real).
      âˆ‚âŸ¨Ïˆ, H, ÏˆâŸ©/âˆ‚Î» â‰ˆ âŸ¨Ïˆ, âˆ‚H/âˆ‚Î», ÏˆâŸ©
      
    ; Variational principle  
    VariationalPrinciple : âˆ€(Ïˆ : Wavefunction) (ğ“— : ElectronicHamiltonian).
      âŸ¨Ïˆ, ğ“—, ÏˆâŸ© â‰¥ Eâ‚€(ğ“—)  
        where Eâ‚€(ğ“—) â‰œ inf{âŸ¨Ï•, ğ“—, Ï•âŸ© | Ï• : Wavefunction}
        
    ; Woodward-Hoffmann rules  
    WoodwardHoffmann : âˆ€(R : ChemicalReaction) (S : Symmetry).
      Allowed(R) â‡” Matches(S(ReactantOrbitals(R)), S(ProductOrbitals(R)))
      
    ; Eyring equation  
    EyringEquation : âˆ€(R : ChemicalReaction) (Î”G : Real) (T : Realâ‚Š).
      â„›(R)(T) â‰ˆ (kâ‚š * T / h) * exp(-Î”G / (kâ‚š * T))
        where kâ‚š â‰œ 1.380649e-23  ; Boltzmann constant
              h â‰œ 6.62607015e-34  ; Planck constant
  }
  
  THEOREMS {
    ; Quantum chemistry
    QuantumChemistry (M : Molecule, ğ“— : ElectronicHamiltonian(M)) :
      BornOppenheimer(M, ğ“—) ->  
      ElectronicStructure(M) â‰ˆ Spectrum(ğ“—)
    PROOF {
      define ğ“¥ â‰œ Î»(r : M). âŸ¨ğ“—(r), M(r)âŸ©
      define Laplacian â‰œ Î” : Operator(ElectronicStructure(M))
      
      assume BornOppenheimer(M, ğ“—)
      hence SchrodingerEquation(ğ“—, Ïˆ) â‰ˆ (-Â½ * Laplacian + ğ“¥) * Ïˆ
      
      obtain {Eáµ¢ : Real, Ïˆáµ¢ : Wavefunction(M)}áµ¢ â‰œ Spectrum(ğ“—) by SpectralTheorem(ğ“—)
      hence ğ“— * Ïˆáµ¢ â‰ˆ Eáµ¢ * Ïˆáµ¢
      
      have ElectronicStructure(M) â‰œ â‹ƒáµ¢ ComplexScalarField * Ïˆáµ¢
      hence ElectronicStructure(M) â‰ˆ Spectrum(ğ“—)  
    }
    
    ; Density functional theory
    DensityFunctionalTheory (Ï : Density, ğ“” : PotentialEnergyFunction) :  
      HohenbergKohn1(Ï, ğ“”) ->
      GroundStateDensity(Ï) â‡” MinimizeEnergy(ğ“”)  
    PROOF {
      obtain ğ“•_HK, v by HohenbergKohn1(Ï, ğ“”)  
      hence ğ“” â‰ˆ ğ“•_HK[Ï] + âˆ«(v(r) * Ï(r), r)
      
      obtain Ïˆ where Ï â‰ˆ Ï[Ïˆ] by HohenbergKohn1(Ï, ğ“”)
      
      have âŸ¨Ïˆ, ğ“—, ÏˆâŸ© â‰ˆ MinEnergy(ğ“—) by VariationalPrinciple(Ïˆ, ğ“—)
      hence Ïˆ â‰ˆ argmin{âŸ¨Ï•, ğ“—, Ï•âŸ© | Ï• : Wavefunction}
      
      therefore GroundStateDensity(Ï) â‡” Ï[Ïˆ] â‡” MinimizeEnergy(ğ“”)
    }
    
    ; Structure optimization
    StructureOptimization (M : Molecule, ğ“” : PotentialEnergyFunction(M), âˆ‡ğ“” : Gradient(M)) :
      StationaryPoints(ğ“”) â‰ˆ {m âˆˆ M | âˆ‡ğ“”(m) â‰ˆ 0}  
    PROOF {
      let M â‰œ Real^(3 * |M.Atoms|)
      
      have âˆ‡ğ“” â‰œ Î»(m : M). (âˆ‚ğ“”(m)/âˆ‚xâ‚, ..., âˆ‚ğ“”(m)/âˆ‚xâ‚™)
      
      have âˆ€(m âˆˆ M).
        m âˆˆ StationaryPoints(ğ“”) â‡”  
        (âˆ€i. âˆ‚ğ“”(m)/âˆ‚xáµ¢ â‰ˆ 0) â‡”    ; Definition of stationary point
        âˆ‡ğ“”(m) â‰ˆ 0                ; Definition of gradient
      
      hence StationaryPoints(ğ“”) â‰ˆ {m âˆˆ M | âˆ‡ğ“”(m) â‰ˆ 0} 
    }
    
    ; Transition state theory 
    TransitionStateTheory (R : ChemicalReaction, Î”G : Real, T : Realâ‚Š) :
      EyringEquation(R, Î”G, T) ->
      â„›(R)(T) â‰ˆ (kâ‚š * T / h) * exp(-(ğ“”(Mâ‚œ) - ğ“”(Máµ£)) / (kâ‚š * T))
        where Máµ£ â‰œ Reactants(R) 
              Mâ‚š â‰œ Products(R)
              Mâ‚œ â‰œ TransitionState(R)
    PROOF {
      let Máµ£ â‰œ Reactants(R), Mâ‚š â‰œ Products(R), Mâ‚œ â‰œ TransitionState(R)
      assume EyringEquation(R, Î”G, T)
      
      have â„›(R)(T) â‰ˆ (kâ‚š * T / h) * exp(-Î”G / (kâ‚š * T))
      
      define Î”G â‰œ G(Mâ‚œ) - G(Máµ£)  ; Free energy of activation
      have âˆ€(M : Molecule). G(M) â‰œ ğ“”(M) - T * S(M)  ; Gibbs free energy
      assume S(Mâ‚œ) â‰ˆ S(Máµ£)  ; Small entropy of activation
      hence Î”G â‰ˆ ğ“”(Mâ‚œ) - ğ“”(Máµ£)
      
      therefore â„›(R)(T) â‰ˆ (kâ‚š * T / h) * exp(-(ğ“”(Mâ‚œ) - ğ“”(Máµ£)) / (kâ‚š * T))
    }
  }
}



; MolecularSymmetry: a formalization of molecular symmetry using geometric chemistry
; Symmetry: a transformation that preserves the structure of a molecule
; IrreducibleRepresentation: a minimal invariant subspace of a symmetry group action
; CharacterTable: a table of characters (traces) of irreducible representations
; SymmetryAdapted: a basis of wavefunctions adapted to the symmetry of a molecule

CONCEPT MolecularSymmetry EXTENDS GeometricChemistry {
  TYPES {
    Symmetry : Type = Bijection(Molecule, Molecule)
    SymmetryGroup (M : Molecule) : Type = Group(Symmetry, Composition)
    
    Representation (G : SymmetryGroup) : Type = Homomorphism(G, LinearOperator)
    IrreducibleRepresentation (G : SymmetryGroup) : Type = 
      Representation(G) & Irreducible
    
    CharacterTable (G : SymmetryGroup) : Type = 
      Table(G.Conjugacy, IrreducibleRepresentation(G), Character)
    Character (Ï : IrreducibleRepresentation) : Type = Trace âˆ˜ Ï
    
    SymmetryAdapted (M : Molecule) (Ï : IrreducibleRepresentation(SymmetryGroup(M))) : Type =
      {Ïˆ : Wavefunction(M) | âˆ€(g : SymmetryGroup(M)). Ï(g)(Ïˆ) â‰ˆ Ïˆ}  
  }
  
  AXIOMS {
    ; Symmetry operations preserve the Hamiltonian
    SymmetryInvariance : âˆ€(M : Molecule) (ğ“— : ElectronicHamiltonian(M)) (g : SymmetryGroup(M)).
      ğ“— âˆ˜ g â‰ˆ g âˆ˜ ğ“—
      
    ; Schur's lemmas for irreducible representations  
    SchurOrthogonality : âˆ€(G : SymmetryGroup) (Ï Ïƒ : IrreducibleRepresentation(G)).
      (âˆ€(g : G). âŸ¨Ï(g), Ïƒ(g)âŸ© â‰ˆ 0) â‡” (Ï â‰  Ïƒ)
      
    SchurIrreducibility : âˆ€(G : SymmetryGroup) (Ï : IrreducibleRepresentation(G)) (A : LinearOperator).
      (âˆ€(g : G). Ï(g) âˆ˜ A â‰ˆ A âˆ˜ Ï(g)) â‡’ (A â‰ˆ Î» * I)
      
    ; Character orthogonality relations
    CharacterOrthogonality1 : âˆ€(G : SymmetryGroup) (Ï Ïƒ : IrreducibleRepresentation(G)).
      âˆ‘{g : G} Character(Ï)(g) * Character(Ïƒ)(g)^* â‰ˆ |G| * Î´(Ï, Ïƒ)
      
    CharacterOrthogonality2 : âˆ€(G : SymmetryGroup) (g h : G).  
      âˆ‘{Ï : IrreducibleRepresentation(G)} Character(Ï)(g) * Character(Ï)(h)^* â‰ˆ |G| * Î´(g, h)
  }
  
  THEOREMS {
    ; Symmetry-adapted wavefunctions are eigenfunctions of the Hamiltonian
    SymmetryAdaptedEigenfunctions (M : Molecule, ğ“— : ElectronicHamiltonian(M)) :
      âˆ€(Ï : IrreducibleRepresentation(SymmetryGroup(M))) (Ïˆ : SymmetryAdapted(M, Ï)).
        âˆƒ(E : Real). ğ“— * Ïˆ â‰ˆ E * Ïˆ
    PROOF {
      assume SymmetryInvariance(M, ğ“—) 
      let G â‰œ SymmetryGroup(M)
      
      take (Ï : IrreducibleRepresentation(G)) (Ïˆ : SymmetryAdapted(M, Ï))
      have âˆ€(g : G). Ï(g)(Ïˆ) â‰ˆ Ïˆ  ; Ïˆ is symmetry-adapted
      
      have âˆ€(g : G). ğ“— âˆ˜ Ï(g)(Ïˆ) â‰ˆ Ï(g) âˆ˜ ğ“—(Ïˆ)  by SymmetryInvariance(M, ğ“—)
      hence âˆ€(g : G). Ï(g) âˆ˜ ğ“—(Ïˆ) â‰ˆ ğ“—(Ïˆ)
      hence ğ“—(Ïˆ) â‰ˆ E * Ïˆ  for some E : Real by SchurIrreducibility(G, Ï, ğ“—)
    }
    
    ; Symmetry-adapted wavefunctions form a complete basis  
    SymmetryAdaptedCompleteness (M : Molecule) :
      ElectronicStructure(M) â‰ˆ âŠ•{Ï, Ïˆ} ComplexScalarField * SymmetryAdapted(M, Ï)(Ïˆ)
    PROOF {
      let G â‰œ SymmetryGroup(M)
      
      have ElectronicStructure(M) â‰ˆ âŠ•{E, Ïˆ} ComplexScalarField * Eigenspace(ğ“—, E)(Ïˆ)
        by SpectralDecomposition(ğ“—)
      
      have âˆ€(E : Real) (Ïˆ : Eigenspace(ğ“—, E)). 
        âˆƒ(Ï : IrreducibleRepresentation(G)). Ïˆ âˆˆ SymmetryAdapted(M, Ï)
        by SymmetryAdaptedEigenfunctions(M, ğ“—)
        
      hence ElectronicStructure(M) â‰ˆ âŠ•{Ï, Ïˆ} ComplexScalarField * SymmetryAdapted(M, Ï)(Ïˆ)
    }
      
    ; Selection rules for electronic transitions
    SelectionRule (M : Molecule) (Ï Ïƒ : IrreducibleRepresentation(SymmetryGroup(M))) :  
      TransitionAllowed(Ï, Ïƒ) â‡” 
        âˆƒ(i : Component). âŸ¨SymmetryAdapted(M, Ï), Dipole(i), SymmetryAdapted(M, Ïƒ)âŸ© â‰‰ 0
    PROOF {
      let G â‰œ SymmetryGroup(M)
      let Î“ â‰œ IrreducibleRepresentation(G)
      
      have TransitionAllowed(Ï, Ïƒ) â‡” âŸ¨Ï, Dipole, ÏƒâŸ© â‰‰ 0  ; By Fermi's golden rule
      
      have Dipole â‰ˆ âˆ‘{i} Î“(Dipole(i)) * Dipole(i)  ; Decompose into irreducible components
        where Î“(Dipole(i)) â‰œ argmax{Î³ : Î“} |âŸ¨Î³, Dipole(i)âŸ©|  ; Dominant irreducible component
        
      have âˆ€(i : Component) (Î³ Î´ : Î“).
        âŸ¨SymmetryAdapted(M, Î³), Dipole(i), SymmetryAdapted(M, Î´)âŸ© â‰ˆ 0 â‡” (Î³ âŠ— Î“(Dipole(i)) âŠ— Î´ â†› Trivial)
        by Wigner-Eckart theorem
        
      hence âŸ¨Ï, Dipole, ÏƒâŸ© â‰ˆ âˆ‘{i} âŸ¨Ï, Î“(Dipole(i)), ÏƒâŸ© * âŸ¨SymmetryAdapted(M, Ï), Dipole(i), SymmetryAdapted(M, Ïƒ)âŸ©
      
      hence TransitionAllowed(Ï, Ïƒ) â‡” 
        âˆƒ(i : Component). âŸ¨SymmetryAdapted(M, Ï), Dipole(i), SymmetryAdapted(M, Ïƒ)âŸ© â‰‰ 0
    }
  }
}