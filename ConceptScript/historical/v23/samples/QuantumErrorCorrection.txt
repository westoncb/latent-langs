CONCEPT QuantumErrorCorrection {

  LANGUAGE {
    TYPE Qubit
    TYPE Operator = Qubit -> Qubit
    TYPE Code[n k : â„•] = Qubit^n
    TYPE LogicalQubit[n k : â„•] = Qubit^k

    FUNC Encode[n k : â„•] : LogicalQubit[n k] -> Code[n k]
    FUNC Decode[n k : â„•] : Code[n k] -> LogicalQubit[n k]
    FUNC Correct[n k : â„•] : Code[n k] -> Code[n k]

    PRED Satisfies[n k : â„•] : Code[n k] -> ğ”¹
    PRED Protects[n k : â„•] : Code[n k] -> ğ’«(Operator) -> ğ”¹
  }

  STRUCTURE {
    DEF Satisfies[n k](C) <-> 
      âˆ€ Ïˆ Ï† : LogicalQubit[n k] . âŸ¨Ïˆ|Ï†âŸ© = âŸ¨Encode(Ïˆ)|Encode(Ï†)âŸ©

    DEF Protects[n k](C, ğ“”) <->
      âˆ€ E âˆˆ ğ“” . âˆ€ Ïˆ : LogicalQubit[n k] . 
        Decode(Correct(E(Encode(Ïˆ)))) = Ïˆ

    DEF Distance(C) = 
      min {|E| : E âˆˆ Operators, âˆƒ Ïˆ Ï† . Decode(E(Encode(Ïˆ))) â‰  Decode(E(Encode(Ï†)))}

    DEF Rate(C) = log dim(LogicalQubit) / log dim(C)

    DEF Stabilizers(C) = {S : Operator | âˆ€ c âˆˆ C . S(c) = c}
  }

  PROOFS {
    THEOREM KnillLaflamme[n k : â„•] {
      STATEMENT : 
        âˆ€ C : Code[n k] . Satisfies[n k](C) âˆ§ Protects[n k](C, ğ“”) <->
          âˆ€ Eâ‚ Eâ‚‚ âˆˆ ğ“” . âˆ€ i j . âŸ¨i|Eâ‚â€ Eâ‚‚|jâŸ© = Î´_ij âŸ¨i|Eâ‚â€ Eâ‚‚|iâŸ©  
            WHERE {|iâŸ©} = Encode(LogicalQubit.Basis)
      
      PROOF {
        ASSUME [C : Code[n k]] : Satisfies[n k](C) âˆ§ Protects[n k](C, ğ“”)
        
        LET {|iâŸ©} = Encode(LogicalQubit.Basis)

        ASSUME [Eâ‚ Eâ‚‚ âˆˆ ğ“”] [i j]

        CASE i = j:
          âŸ¨i|Eâ‚â€ Eâ‚‚|iâŸ© 
            = âŸ¨Encode(i)|Eâ‚â€ Eâ‚‚|Encode(i)âŸ©    BY DefinitionOfEncode
            = âŸ¨Decode(Correct(Eâ‚(Encode(i))))|Decode(Correct(Eâ‚‚(Encode(i))))âŸ©
                BY Protects, Satisfies  
            = âŸ¨i|iâŸ© = 1

        CASE i â‰  j:
          âŸ¨i|Eâ‚â€ Eâ‚‚|jâŸ©
            = âŸ¨Encode(i)|Eâ‚â€ Eâ‚‚|Encode(j)âŸ©    BY DefinitionOfEncode
            = âŸ¨Decode(Correct(Eâ‚(Encode(i))))|Decode(Correct(Eâ‚‚(Encode(j))))âŸ© 
                BY Protects, Satisfies
            = âŸ¨i|jâŸ© = 0

        SHOW âŸ¨i|Eâ‚â€ Eâ‚‚|jâŸ© = Î´_ij âŸ¨i|Eâ‚â€ Eâ‚‚|iâŸ©

        CONVERSELY, ASSUME âˆ€ Eâ‚ Eâ‚‚ âˆˆ ğ“” . âˆ€ i j . âŸ¨i|Eâ‚â€ Eâ‚‚|jâŸ© = Î´_ij âŸ¨i|Eâ‚â€ Eâ‚‚|iâŸ©

        TAKE Ïˆ = âˆ‘ Î±áµ¢|iâŸ©, Ï† = âˆ‘ Î²â±¼|jâŸ©

        âŸ¨Encode(Ïˆ)|Encode(Ï†)âŸ© 
          = âˆ‘ Î±áµ¢ Î²â±¼* âŸ¨i|jâŸ©                 BY Linearity
          = âˆ‘ Î±áµ¢ Î²áµ¢* = âŸ¨Ïˆ|Ï†âŸ©               BY Orthonormality

        HENCE Satisfies[n k](C)

        TAKE E âˆˆ ğ“”, Ïˆ = âˆ‘ Î±áµ¢|iâŸ©

        Decode(Correct(E(Encode(Ïˆ))))
          = Decode(Correct(âˆ‘ Î±áµ¢ E|iâŸ©))    BY Linearity
          = Decode(âˆ‘ Î±áµ¢ Correct(E|iâŸ©))     BY Linearity
          = Decode(âˆ‘ Î±áµ¢ |iâŸ©)               BY Eâ‚ = E, Eâ‚‚ = I in condition
          = Ïˆ                              BY DefinitionOfDecode

        HENCE Protects[n k](C, ğ“”)
      }
    }

    THEOREM DistanceProtection[n k : â„•] {
      STATEMENT : âˆ€ C : Code[n k] . 
        Protects[n k](C, ğ“”) <-> Distance(C) > max {|E| : E âˆˆ ğ“”}

      PROOF {
        ASSUME [C : Code[n k]]

        SHOW Protects[n k](C, ğ“”) -> Distance(C) > max {|E| : E âˆˆ ğ“”} BY {
          ASSUME Protects[n k](C, ğ“”)
          ASSUME âˆƒ E âˆˆ ğ“” . |E| â‰¥ Distance(C)

          LET E âˆˆ ğ“”, Ïˆ Ï† SUCH THAT 
            |E| â‰¥ Distance(C),
            Decode(E(Encode(Ïˆ))) â‰  Decode(E(Encode(Ï†)))

          HAVE Decode(Correct(E(Encode(Ïˆ)))) = Ïˆ â‰  Ï† = Decode(Correct(E(Encode(Ï†))))
            BY Protects 
          
          CONTRADICTION  
        }

        SHOW Distance(C) > max {|E| : E âˆˆ ğ“”} -> Protects[n k](C, ğ“”) BY {
          ASSUME Distance(C) > max {|E| : E âˆˆ ğ“”}
          TAKE E âˆˆ ğ“”, Ïˆ : LogicalQubit[n k]

          HAVE |E| < Distance(C) BY ASSUMPTION

          HENCE âˆ€ Ï† . Decode(E(Encode(Ïˆ))) = Decode(E(Encode(Ï†))) -> Ïˆ = Ï†
            BY DefinitionOfDistance

          HENCE Decode(Correct(E(Encode(Ïˆ)))) = Ïˆ  
        }
      }
    }

    THEOREM RateBound[n k : â„•] {
      STATEMENT : âˆ€ C : Code[n k] . Rate(C) â‰¤ 1 - H(ğœ)/n
        WHERE ğœ = (dim(C) - 1)/3

      PROOF {
        ASSUME [C : Code[n k]]

        LET t = (dim(C) - 1) / 2
        LET {Máµ¢} = Stabilizers(C)

        HAVE |{Máµ¢}| â‰¤ dim(C) BY StabilizerBound

        HAVE log dim(LogicalQubit) â‰¤ n - log |{Máµ¢}| BY {
          log dim(LogicalQubit) 
            = log (dim(C) / |{Máµ¢}|)
            = log dim(C) - log |{Máµ¢}|
            â‰¤ n - log |{Máµ¢}|
        }

        HAVE log |{Máµ¢}| â‰¥ nÂ·H(t/n) BY QSingleton

        HENCE Rate(C) 
          = log dim(LogicalQubit) / n
          â‰¤ (n - log |{Máµ¢}|) / n
          â‰¤ 1 - H(t/n)
          = 1 - H(ğœ)
      }
    }
  }
}