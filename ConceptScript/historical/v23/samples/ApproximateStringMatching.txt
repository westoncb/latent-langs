CONCEPT ApproximateStringMatching {

  LANGUAGE {
    TYPE String = [â„•]â„•
    TYPE Regex = String -> ğ”¹
    TYPE EditDistance = â„•
    TYPE TrieNode[M : â„•] = âŸ¨children: Vector[M](TrieNode[M]) | isEnd: ğ”¹âŸ© 

    FUNC LevenshteinDistance : String -> String -> EditDistance
    FUNC HammingDistance : String -> String -> EditDistance
    FUNC BuildTrie[M : â„•] : ğ’«(String) -> TrieNode[M]
    FUNC ApproxTrie[M k : â„•] : String -> TrieNode[M] -> EditDistance -> ğ’«(String)

    PRED Match : Regex -> String -> ğ”¹
    NOTATION "d(x, y)" = LevenshteinDistance(x, y)
    NOTATION "(x)áµ£" = ExactStrings(x, r)
    NOTATION "(x)áµ£â‚–" = ApproxStrings(x, r, k)
  }

  STRUCTURE {
    DEF LevenshteinDistance(sâ‚, sâ‚‚) = MEMOIZE ğœ†(i, j).
        IF i = 0 THEN j
        ELSE IF j = 0 THEN i
        ELSE IF sâ‚[i] = sâ‚‚[j] THEN RECUR(i-1, j-1)
        ELSE 1 + min(RECUR(i-1, j), RECUR(i, j-1), RECUR(i-1, j-1))
      APPLIED AT (|sâ‚|, |sâ‚‚|)

    DEF HammingDistance(sâ‚, sâ‚‚) = âˆ‘ (i : 1..|sâ‚|) IF sâ‚[i] â‰  sâ‚‚[i] THEN 1 ELSE 0
      PRE |sâ‚| = |sâ‚‚|

    DEF BuildTrie[M] (ğ’Ÿ : ğ’«(String)) -> TrieNode[M] =
      âŸ¨children â†¦ (c : 0..M-1) â†¦ BuildTrie[M](Drop1(Select(ğ’Ÿ, (s : String) â†¦ s[0] = c)))
       isEnd â†¦ "" âˆˆ ğ’ŸâŸ©
         
    DEF ApproxTrie[M k] (s : String, node : TrieNode[M], dist : EditDistance) -> ğ’«(String) =
      IF dist < 0 THEN âˆ… 
      ELSE IF s = "" THEN IF node.isEnd âˆ§ dist = 0 THEN {""} ELSE âˆ…
      ELSE LET c = s[0], s' = s[1..] IN
             (node.children[c] |> ApproxTrie[M k](s', Â·, dist)) --Exact match
        âˆª (â‹ƒ (i : 0..M-1) node.children[i] |> ApproxTrie[M k](s', Â·, dist-1)) --Insertion
        âˆª ApproxTrie[M k](s', node, dist-1) --Deletion
        âˆª (â‹ƒ (i : 0..M-1) IF i â‰  c THEN node.children[i] |> ApproxTrie[M k](s', Â·, dist-1) ELSE âˆ…) --Substitution
        
    DEF Match(r : Regex, s : String) <-> s âˆˆ ExactStrings(r) 
    DEF ExactStrings(r : Regex) = {s : String | r(s)}    
    DEF ApproxStrings(r : Regex, k : EditDistance) = {t : String | âˆƒ s âˆˆ (r)áµ£. d(s, t) â‰¤ k}    
  }

  PROOFS {
    THEOREM LevenshteinEditProperties {
      STATEMENT : âˆ€ (sâ‚ sâ‚‚ : String) . d(sâ‚, sâ‚‚) =
        min {|T| : T âˆˆ EditTranscripts(sâ‚, sâ‚‚)} 
        WHERE EditTranscripts(sâ‚, sâ‚‚) = 
          {T : [EditOperation]* | ApplyEdits(sâ‚, T) = sâ‚‚}
          
      PROOF {
        ASSUME [sâ‚ sâ‚‚ : String]

        DEFINE EditCost(op : EditOperation) = CASE op OF
          | Insert _ -> 1 
          | Delete _ -> 1
          | Replace _ _ -> 1
          | Match _ -> 0

        HAVE : âˆ€ T âˆˆ EditTranscripts(sâ‚, sâ‚‚) . |T| â‰¥ âˆ‘ (op âˆˆ T) EditCost(op) BY PositivityOfCosts

        DEFINE OptimalTranscript = 
          MEMOIZE ğœ†(i, j).
            IF i = 0 THEN [Insert(sâ‚‚[k]) for k in 1..j]
            ELSE IF j = 0 THEN [Delete(sâ‚[k]) for k in 1..i]
            ELSE IF sâ‚[i] = sâ‚‚[j] THEN Match(sâ‚[i]) :: RECUR(i-1, j-1)
            ELSE LET (op, T) = argmin (
                    (Delete(sâ‚[i]), RECUR(i-1, j)),
                    (Insert(sâ‚‚[j]), RECUR(i, j-1)), 
                    (Replace(sâ‚[i], sâ‚‚[j]), RECUR(i-1, j-1))
                 ) BY EditCost(op) + |T|
                 IN op :: T
          APPLIED AT (|sâ‚|, |sâ‚‚|)

        HAVE OptimalityLemma : âˆ€ (i j : â„•) . âˆ€ T âˆˆ EditTranscripts(sâ‚[1..i], sâ‚‚[1..j]) .
          |OptimalTranscript(i, j)| â‰¤ |T| 
          PROOF BY INDUCTION

        CHOOSE T* = OptimalTranscript(|sâ‚|, |sâ‚‚|)

        HAVE : |T*| = âˆ‘ (op âˆˆ T*) EditCost(op) BY ConstructionOfT*
        HAVE : âˆ€ T âˆˆ EditTranscripts(sâ‚, sâ‚‚) . |T*| â‰¤ |T| BY OptimalityLemma

        SHOW d(sâ‚, sâ‚‚) = |T*| = min {|T| : T âˆˆ EditTranscripts(sâ‚, sâ‚‚)} BY DefinitionOfLevenshtein
      }
    }

    THEOREM ApproximateTrieCorrectness[M k : â„•] {
      STATEMENT : âˆ€ (ğ’Ÿ : ğ’«(String)) (s : String) .
        ApproxTrie[M k](s, BuildTrie[M](ğ’Ÿ), k) = {t âˆˆ ğ’Ÿ | d(s, t) â‰¤ k}
        
      PROOF {
        ASSUME [ğ’Ÿ : ğ’«(String)] [s : String] 
        LET root = BuildTrie[M](ğ’Ÿ)

        DEFINE ApproxTrieInductive[dist : â„•](t : String, node : TrieNode[M]) -> ğ’«(String) =
          IF dist < 0 THEN âˆ… 
          ELSE IF t = "" THEN IF node.isEnd âˆ§ dist = 0 THEN {""} ELSE âˆ…
          ELSE LET c = t[0], t' = t[1..] IN
                 (node.children[c] |> ApproxTrieInductive[dist](t', Â·)) --Exact match
            âˆª (â‹ƒ (i : 0..M-1) node.children[i] |> ApproxTrieInductive[dist-1](t', Â·)) --Insertion
            âˆª ApproxTrieInductive[dist-1](t', node) --Deletion
            âˆª (â‹ƒ (i : 0..M-1) IF i â‰  c THEN node.children[i] |> ApproxTrieInductive[dist-1](t', Â·) ELSE âˆ…) --Substitution

        HAVE CorrectnessLemma : âˆ€ (dist : â„•) (t : String) (node : TrieNode[M]) .
            ApproxTrieInductive[dist](t, node) = {u âˆˆ Strings(node) | d(t, u) â‰¤ dist}
          WHERE Strings(node) = {u : String | âˆƒ p : String . u = p ++ [sym | node' â† nodesOnPathTo(node), sym â† node'.children, node'.isEnd]}
          PROOF BY INDUCTION ON |t|

        SHOW ApproxTrie[M k](s, root, k) = {t âˆˆ ğ’Ÿ | d(s, t) â‰¤ k} BY {
          ApproxTrie[M k](s, root, k) 
            = ApproxTrieInductive[k](s, root) BY DefinitionOfApproximateTrie
            = {u âˆˆ Strings(root) | d(s, u) â‰¤ k} BY CorrectnessLemma
            = {u âˆˆ ğ’Ÿ | d(s, u) â‰¤ k} BY DefinitionOfBuildTrie
        }
      }
    }

    THEOREM RegexApproximationTheorem {
      STATEMENT : âˆ€ (r : Regex) (k : â„•) (s : String) . 
        Match(r, s) <-> âˆƒ t âˆˆ (s)áµ£â‚– . Match(r, t)

      PROOF {
        ASSUME [r : Regex] [k : â„•] [s : String]

        SHOW Match(r, s) -> âˆƒ t âˆˆ (s)áµ£â‚– . Match(r, t) BY {
          ASSUME Match(r, s)
          WITNESS s 
          HAVE : s âˆˆ (s)áµ£â‚– BECAUSE d(s, s) = 0 â‰¤ k
          HENCE âˆƒ t âˆˆ (s)áµ£â‚– . Match(r, t)
        }

        SHOW (âˆƒ t âˆˆ (s)áµ£â‚– . Match(r, t)) -> Match(r, s) BY {
          ASSUME âˆƒ t âˆˆ (s)áµ£â‚– . Match(r, t)
          LET t âˆˆ (s)áµ£â‚– SUCH THAT Match(r, t)

          HAVE : d(s, t) â‰¤ k âˆ§ t âˆˆ (r)áµ£ BY {
            d(s, t) â‰¤ k BY DefinitionOfApproxStrings
            t âˆˆ (r)áµ£ BY DefinitionOfMatch
          }
          
          HAVE : s âˆˆ (r)áµ£â‚– BY DefinitionOfApproxStrings

          HENCE Match(r, s) BY DefinitionOfMatch
        }
      }
    }
  }
}