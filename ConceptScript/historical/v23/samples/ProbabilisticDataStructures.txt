CONCEPT ProbabilisticDataStructures {

  LANGUAGE {
    TYPE Index = â„• 
    TYPE Hash[n : â„•] = Index -> ğ”½â‚‚â¿
    TYPE BloomFilter[m n : â„•] = Vector[m] ğ”¹
    TYPE CountMinSketch[d w : â„•] = Matrix[d w] â„•
    TYPE HyperLogLog[m : â„•] = Vector[m] â„•

    FUNC Insert[m n : â„•] : BloomFilter[m n] -> ğ”½â‚‚â¿ -> BloomFilter[m n] 
    FUNC Query[m n : â„•] : BloomFilter[m n] -> ğ”½â‚‚â¿ -> ğ”¹
    FUNC Update[d w : â„•] : CountMinSketch[d w] -> Index -> â„• -> CountMinSketch[d w]
    FUNC Estimate[d w : â„•] : CountMinSketch[d w] -> Index -> â„•  
    FUNC Merge[m : â„•] : HyperLogLog[m] -> HyperLogLog[m] -> HyperLogLog[m]
    FUNC Cardinality[m : â„•] : HyperLogLog[m] -> â„âº

    PRED MayContain[m n : â„•] : BloomFilter[m n] -> ğ”½â‚‚â¿ -> ğ”¹
  }

  STRUCTURE {
    DEF Insert[m n : â„•] (B : BloomFilter[m n], x : ğ”½â‚‚â¿) -> BloomFilter[m n] = 
      LET (hâ‚,...,hâ‚–) = HashFunctions(m, n) IN
        B[hâ‚(x)] := 1, ..., B[hâ‚–(x)] := 1
      RETURN B

    DEF Query[m n : â„•] (B : BloomFilter[m n], x : ğ”½â‚‚â¿) -> ğ”¹ =
      LET (hâ‚,...,hâ‚–) = HashFunctions(m, n) IN
        RETURN B[hâ‚(x)] âˆ§ ... âˆ§ B[hâ‚–(x)]

    DEF Update[d w : â„•] (C : CountMinSketch[d w], i : Index, c : â„•) -> CountMinSketch[d w] =
      LET (hâ‚,...,hâ‚–) = HashFunctions(d, log w) IN
        C[1, hâ‚(i)] += c, ..., C[d, hâ‚–(i)] += c
      RETURN C

    DEF Estimate[d w : â„•] (C : CountMinSketch[d w], i : Index) -> â„• =
      LET (hâ‚,...,hâ‚–) = HashFunctions(d, log w) IN
        RETURN min(C[1, hâ‚(i)], ..., C[d, hâ‚–(i)])

    DEF Merge[m : â„•] (Hâ‚ : HyperLogLog[m], Hâ‚‚ : HyperLogLog[m]) -> HyperLogLog[m] =
      RETURN (i : ğ”½_m) â†¦ max(Hâ‚[i], Hâ‚‚[i])

    DEF Cardinality[m : â„•] (H : HyperLogLog[m]) -> â„âº =
      LET Î± = (0.7213 / (1 + 1.079/m)) IN
        Î±Â·mÂ²Â· (âˆ‘ (i : ğ”½_m) 2^(-H[i]))^(-1)

    DEF MayContain[m n : â„•](B, x) <-> Query[m n](B, x) âˆ§ Â¬âˆƒ (y : ğ”½â‚‚â¿) . (y â‰  x âˆ§ Query[m n](B, y))
  }

  PROOFS {
    THEOREM BloomFilterNoFalseNegative[m n : â„•] {
      STATEMENT : âˆ€ (B : BloomFilter[m n]) (x : ğ”½â‚‚â¿) . 
        x âˆˆ ValuesInserted(B) -> Query[m n](B, x) 

      PROOF {
        ASSUME [B : BloomFilter[m n]] [x : ğ”½â‚‚â¿] : x âˆˆ ValuesInserted(B)
        
        LET (hâ‚,...,hâ‚–) = HashFunctions(m, n)
        
        HAVE : B[hâ‚(x)] = 1 âˆ§ ... âˆ§ B[hâ‚–(x)] = 1  BY InsertSetsHashBits

        SHOW Query[m n](B, x)  BY DefinitionOfQuery
      }
    }

    THEOREM CountMinSketchOverEstimate[d w : â„•] {
      STATEMENT : âˆ€ (C : CountMinSketch[d w]) (i : Index) .
        Estimate[d w](C, i) â‰¥ TrueCount(i)

      PROOF {
        ASSUME [C : CountMinSketch[d w]] [i : Index]

        LET c = TrueCount(i), Ä‰ = Estimate[d w](C, i)
        LET (hâ‚,...,hâ‚–) = HashFunctions(d, log w)

        HAVE : âˆ€ (j : 1..d) . C[j, hâ±¼(i)] â‰¥ c BY {
          INDUCE ON Updates(i) {
            CASE BaseCase: C = ZeroSketch
              HAVE : C[j, hâ±¼(i)] = 0 â‰¥ 0 = c
            CASE InductiveCase: C := Update[d w](C', i, Î´)  
              ASSUME: C'[j, hâ±¼(i)] â‰¥ TrueCount'(i)
              HAVE: C[j, hâ±¼(i)] = C'[j, hâ±¼(i)] + Î´ 
                               â‰¥ TrueCount'(i) + Î´ = TrueCount(i) = c
          }
        }

        HENCE Ä‰ = min(C[1, hâ‚(i)], ..., C[d, hâ‚–(i)]) â‰¥ c 
      }
    }
    
    THEOREM HyperLogLogRelativeError[m : â„•] {
      STATEMENT : âˆ€ (H : HyperLogLog[m]) . 
        |Cardinality[m](H) - TrueCardinality(H)| / TrueCardinality(H) â‰¤ 1.04/âˆšm  
        WITH PROBABILITY â‰¥ 65%

      PROOF {
        ASSUME [H : HyperLogLog[m]]
        
        LET n = TrueCardinality(H)
        LET Î± = 0.7213 / (1 + 1.079/m)
        LET Z = âˆ‘ (i : ğ”½_m) 2^(-H[i])
        LET Ã± = Î±Â·mÂ²Â·(1/Z)
        
        HAVE Bias : ğ”¼[Ã±] = nÂ·(1 + Î´â‚(n)) 
          WHERE |Î´â‚(n)| â‰¤ IF n â‰¤ 5/2Â·m THEN 5Â·10â»âµ ELSE 1/30Â·(log(m/n))â´Â·âˆš(n/m)
        
        HAVE Concentration : â„™[|Ã±/n - 1| â‰¥ 1.04/âˆšm] â‰¤ 0.35 
          BY {
            Ã±/n - 1 = Î±Â·m/nÂ·(Z - ğ”¼[Z])/ğ”¼[Z] + Î´â‚(n)
            HENCE Var[Ã±/n] â‰¤ 3/mÂ·(Î±Â·m/n)Â² + O((log(n/m))â¸Â·n/mÂ²) BY DeltaMethod
            HENCE â„™[|Ã±/n - 1 - Î´â‚(n)| â‰¥ t] â‰¤ exp(-2tÂ²Â·m/(3Î±Â²)) BY Chernoff
            CHOOSE t = 1.04/âˆšm - |Î´â‚(n)|
          }

        SHOW |Ã± - n| / n â‰¤ 1.04/âˆšm WITH PROBABILITY â‰¥ 65%
      }
    }
  }
}