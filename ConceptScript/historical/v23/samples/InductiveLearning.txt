CONCEPT InductiveLearning {

  LANGUAGE {
    TYPE Example = РЪеinput: Vector[n], output: ­Юћ╣РЪЕ
    TYPE Hypothesis = Vector[n] -> ­Юћ╣
    TYPE TrainingData = ­ЮњФ(Example)
    TYPE PerformanceMeasure = Hypothesis -> TrainingData -> РёЮ 

    FUNC LearnHypothesis : РёЋ -> TrainingData -> Hypothesis
    FUNC EvaluateHypothesis : Hypothesis -> TrainingData -> РёЮ

    PRED ╬х-Approximate : Hypothesis -> Hypothesis -> РёЮ -> ­Юћ╣
    PRED PAC-Learnable : (РёЋ -> TrainingData -> Hypothesis) -> РёЋ -> РёЮ -> ­Юћ╣

    NOTATION "(x)рхђ" = RestrictedTo(­ЮњЪ, x)
    NOTATION "err(h, ­ЮњЪ)" = ErrorRate(h, ­ЮњЪ)
  }

  STRUCTURE {
    DEF LearnHypothesis(n, ­ЮњЪ) = 
      MEMOIZE ­Юює(x : Vector[n]) .
        PluralityVote(РІЃ ({d.output | d Рѕѕ (­ЮњЪ)рхђ[d.input = x]} Рѕф {­Юћй}))
        
    DEF EvaluateHypothesis(h, ­ЮњЪ) =
      РѕЉ (d Рѕѕ ­ЮњЪ) IF h(d.input) = d.output THEN 0 ELSE 1
         
    DEF ╬х-Approximate(hРѓЂ, hРѓѓ, ╬х) <-> Рѕђ (­ЮњЪ : ­ЮњФ(Example)) . |err(hРѓЂ, ­ЮњЪ) - err(hРѓѓ, ­ЮњЪ)| РЅц ╬х

    DEF PAC-Learnable(Learn, n, ╬х, ╬┤) <->
      Рѕђ (­ЮњЪ : ­ЮњФ(Example)) (m РЅЦ M(n, 1/╬х, 1/╬┤)) .
        РёЎ[S Рѕ╝ ­ЮњЪрхљ] (╬х-Approximate(Learn(n, S), OptimalHypothesis(­ЮњЪ), ╬х)) РЅЦ 1 - ╬┤
          WHERE M(n, 1/╬х, 1/╬┤) = ...
                
    AXIOM NoFreeLunch : 
      Рѕђ (LearnРѓЂ LearnРѓѓ : РёЋ -> TrainingData -> Hypothesis) .
        РѕЉ (­ЮњЪ : ­ЮњФ(Example)) err(LearnРѓЂ(­ЮњЪ), ­ЮњЪ) = РѕЉ (­ЮњЪ : ­ЮњФ(Example)) err(LearnРѓѓ(­ЮњЪ), ­ЮњЪ)
  }
  
  PROOFS {
    THEOREM FiniteHypothesisClassPAC {
      STATEMENT : Рѕђ (РёІ : ­ЮњФ(Hypothesis)) (n m : РёЋ) (╬х ╬┤ : РёЮ) .
        |РёІ| < Рѕъ РѕД m РЅЦ log(|РёІ|/╬┤)/(2╬х┬▓) ->  
        Рѕђ (­ЮњЪ : ­ЮњФ(Example)) . РёЎ[S Рѕ╝ ­ЮњЪрхљ] (Рѕђ (h Рѕѕ РёІ) . ╬х-Approximate(h, h(­ЮњЪ), ╬х)) РЅЦ 1 - ╬┤
        
      PROOF {
        ASSUME [РёІ : ­ЮњФ(Hypothesis)] [n m : РёЋ] [╬х ╬┤ : РёЮ] :
          |РёІ| < Рѕъ,
          m РЅЦ log(|РёІ|/╬┤)/(2╬х┬▓)
          
        ASSUME [­ЮњЪ : ­ЮњФ(Example)]
        
        HAVE UniformConvergence : Рѕђ (h Рѕѕ РёІ) . РёЎ[S Рѕ╝ ­ЮњЪрхљ] (|err(h, S) - err(h, ­ЮњЪ)| > ╬х) РЅц 2┬иexp(-2m╬х┬▓) BY HoeffdingInequality

        HAVE SimultaneousConvergence :  
          РёЎ[S Рѕ╝ ­ЮњЪрхљ] (РѕЃ (h Рѕѕ РёІ) . |err(h, S) - err(h, ­ЮњЪ)| > ╬х) РЅц РѕЉ (h Рѕѕ РёІ) 2┬иexp(-2m╬х┬▓) РЅц 2|РёІ|┬иexp(-2m╬х┬▓) РЅц ╬┤  
            BY UnionBound, ASSUMPTION
            
        HENCE РёЎ[S Рѕ╝ ­ЮњЪрхљ] (Рѕђ (h Рѕѕ РёІ) . |err(h, S) - err(h, ­ЮњЪ)| РЅц ╬х) РЅЦ 1 - ╬┤ 

        THUS РёЎ[S Рѕ╝ ­ЮњЪрхљ] (Рѕђ (h Рѕѕ РёІ) . ╬х-Approximate(h, h(­ЮњЪ), ╬х)) РЅЦ 1 - ╬┤
      }
    }
    
    THEOREM FinitePACLearnability {
      STATEMENT : Рѕђ (n : РёЋ) . Рѕђ (РёІ : ­ЮњФ(Vector[n] -> ­Юћ╣)) . |РёІ| < Рѕъ ->
        PAC-Learnable(­Юює(n, ­ЮњЪ) . argmin (h Рѕѕ РёІ) EvaluateHypothesis(h, ­ЮњЪ), n, ╬х, ╬┤)
        
      PROOF {
        ASSUME [n : РёЋ] [РёІ : ­ЮњФ(Vector[n] -> ­Юћ╣)] : |РёІ| < Рѕъ
        
        DEFINE ERM(n, ­ЮњЪ) = argmin (h Рѕѕ РёІ) EvaluateHypothesis(h, ­ЮњЪ)
          
        ASSUME [­ЮњЪ : ­ЮњФ(Example)] [╬х ╬┤ : РёЮ] : ╬х > 0, ╬┤ > 0
        
        CHOOSE h* = argmin (h Рѕѕ РёІ) err(h, ­ЮњЪ)  
        
        CHOOSE m РЅЦ log(|РёІ|/╬┤)/(2(╬х/2)┬▓)
        
        HAVE EPACApproximation :
          РёЎ[S Рѕ╝ ­ЮњЪрхљ] (Рѕђ (h Рѕѕ РёІ) . ╬х/2-Approximate(h, h(­ЮњЪ), ╬х/2)) РЅЦ 1 - ╬┤
            BY FiniteHypothesisClassPAC
            
        HAVE ERMOptimality : 
          РёЎ[S Рѕ╝ ­ЮњЪрхљ] (err(ERM(n, S), ­ЮњЪ) РЅц err(h*, ­ЮњЪ) + ╬х) 
            РЅЦ РёЎ[S Рѕ╝ ­ЮњЪрхљ] (Рѕђ (h Рѕѕ РёІ) . ╬х/2-Approximate(h, h(­ЮњЪ), ╬х/2))  
            РЅЦ 1 - ╬┤
            
        HENCE PAC-Learnable(ERM, n, ╬х, ╬┤)
      }
    }
  }
}