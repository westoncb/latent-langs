CONCEPT LambdaCalculus {

  LANGUAGE {
    TYPE Term
    CONST Var : â„• -> Term
    CONST Abs : â„• -> Term -> Term
    CONST App : Term -> Term -> Term

    NOTATION "Î»" = Abs
    NOTATION "(" = App

    REWRITE BetaReduction : (Î» x . M) N => M[x := N]
    REWRITE EtaReduction : (Î» x . M x) => M

    PRED Reducible : Term -> ð”¹
    PRED BetaEquiv : Term -> Term -> ð”¹
  }

  STRUCTURE {
    DEF FreeVars : Term -> ð’«(â„•) 
      FreeVars (Var x) = {x}
      FreeVars (Abs x M) = FreeVars(M) \ {x}
      FreeVars (App M N) = FreeVars(M) âˆª FreeVars(N)
    
    DEF Substitution : Term -> â„• -> Term -> Term
      (Var x)[y := N] = if x = y then N else Var x
      (Abs x M)[y := N] = if x = y then Abs x M 
                           else Abs x (M[y := N])
      (App Mâ‚ Mâ‚‚)[y := N] = App (Mâ‚[y := N]) (Mâ‚‚[y := N])
      
    DEF Reducible(M) : âˆƒ N . M => N

    DEF BetaEquiv(M, N) : âˆƒ P . M =>* P âˆ§ N =>* P
  }
  
  PROOFS {
    THEOREM ChurchRosser {
      STATEMENT : âˆ€ M N P . BetaEquiv(M, N) âˆ§ (M =>* P) -> âˆƒ Q . (N =>* Q) âˆ§ (P =>* Q)
      
      PROOF {
        ASSUME [M N P] : BetaEquiv(M, N), (M =>* P)
        
        HAVE [R] : (M =>* R) âˆ§ (N =>* R) BY BetaEquiv
        
        SHOW âˆƒ Q . (N =>* Q) âˆ§ (P =>* Q) {
          WITNESS R
          HAVE : (N =>* R) BY ASSUMPTION
          HAVE : (P =>* R) BY {
            INDUCE ON (M =>* P) {
              CASE M = P : (P =>* R) BY ASSUMPTION
              CASE âˆƒ M' . (M =>* M') âˆ§ (M' => P) : 
                ASSUME (M' =>* R)
                SHOW (P =>* R) BY {
                  HAVE : (M' => P) BY ASSUMPTION
                  HAVE : (P =>* R) BY TRANSITIVITY
                }
            }
          }
        }
      }
    }
  }
}