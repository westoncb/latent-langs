CONCEPT FormalLanguageTheory {
  
  LANGUAGE {
    TYPE Symbol
    TYPE Alphabet = ùí´(Symbol)
    TYPE String = [Symbol]
    TYPE Language = ùí´(String)
    TYPE Grammar = ‚ü®
      Variables : ùí´(Symbol),
      Terminals : Alphabet,
      Productions : ùí´(‚ü®Variable : Symbol, Body : [Symbol]‚ü©),  
      Start : Symbol
    ‚ü©
    TYPE Automaton = ‚ü®
      States : ùí´(Symbol),
      Alphabet : Alphabet, 
      Transition : States √ó Alphabet -> ùí´(States),
      Start : States,
      Accept : ùí´(States)  
    ‚ü©
    
    FUNC Generates(G : Grammar, s : String) -> ùîπ
    FUNC Accepts(A : Automaton, s : String) -> ùîπ
    FUNC Closure(L : Language, Op : Language -> Language) -> Language

    PRED Regular(L : Language) <-> ‚àÉ (A : Automaton) . ‚àÄ (s : String) . s ‚àà L <-> Accepts(A, s)
    PRED ContextFree(L : Language) <-> ‚àÉ (G : Grammar) . IsContextFree(G) ‚àß ‚àÄ (s : String) . s ‚àà L <-> Generates(G, s)
  }

  STRUCTURE {
    DEF String = [Symbol]
    DEF Œµ : String = []
    DEF Concat(s : String, t : String) : String = s ++ t
    DEF Union(L1 : Language, L2 : Language) : Language = L1 ‚à™ L2
    DEF Intersection(L1 : Language, L2 : Language) : Language = L1 ‚à© L2
    DEF Complement(L : Language) : Language = {s : String | s ‚àâ L}
    DEF KleeneStar(L : Language) : Language = ‚ãÉ (i : ‚Ñï) L‚Å± WHERE L‚Å± = IF i = 0 THEN {Œµ} ELSE Concat(L, L‚Å±‚Åª¬π)
    DEF Generates(G : Grammar, s : String) = s ‚àà {
        t : String 
        | ‚àÉ (d : DerivationTree) . 
            Root(d) = G.Start ‚àß
            ‚àÄ (n : Node(d)) .
              (IsLeaf(n) -> Label(n) ‚àà G.Terminals) ‚àß
              (¬¨IsLeaf(n) -> ‚ü®Label(n), Labels(Children(n))‚ü© ‚àà G.Productions)
      }
    DEF Accepts(A : Automaton, s : String) = ‚àÉ (p : Path(A)) . 
      Start(p) = A.Start ‚àß 
      End(p) ‚àà A.Accept ‚àß 
      ‚àÄ (i : 0..|s|) . ‚ü®State(p, i), s·µ¢, State(p, i+1)‚ü© ‚àà A.Transition
    DEF Closure(L : Language, Op : Language -> Language) : Language =
      Œº (X : Language) . L ‚à™ Op(X)
    DEF IsContextFree(G : Grammar) <-> 
      ‚àÄ (‚ü®V, Œ±‚ü© : G.Productions) . |Œ±| ‚â• 1 ‚àß Œ±[0] ‚àà G.Variables ‚àß (‚àÄ (i : 1..|Œ±|) . Œ±[i] ‚àà G.Terminals)
  }
  
  PROOFS {
    THEOREM RegularClosureProperties {
      STATEMENT: ‚àÄ (L1 L2 : Language) . Regular(L1) ‚àß Regular(L2) -> 
        Regular(Union(L1, L2)) ‚àß 
        Regular(Concat(L1, L2)) ‚àß
        Regular(KleeneStar(L1)) ‚àß
        Regular(Intersection(L1, L2)) ‚àß
        Regular(Complement(L1))

      PROOF {
        ASSUME [L1 L2 : Language] : 
          Regular(L1),
          Regular(L2)
        
        LET [A1 A2 : Automaton] :
          ‚àÄ (s : String) . s ‚àà L1 <-> Accepts(A1, s),
          ‚àÄ (s : String) . s ‚àà L2 <-> Accepts(A2, s)
        
        SHOW Regular(Union(L1, L2)) BY {
          DEFINE AUnion : Automaton = ‚ü®
            States ‚Ü¶ {qStart} ‚à™ A1.States ‚à™ A2.States,
            Alphabet ‚Ü¶ A1.Alphabet ‚à™ A2.Alphabet,
            Transition ‚Ü¶ A1.Transition ‚à™ A2.Transition ‚à™ {
              ‚ü®qStart, Œµ, q‚ü© | q ‚àà {A1.Start, A2.Start}  
            },
            Start ‚Ü¶ qStart,
            Accept ‚Ü¶ A1.Accept ‚à™ A2.Accept
          ‚ü©
          
          ‚àÄ (s : String) . s ‚àà Union(L1, L2) 
            <-> s ‚àà L1 ‚à® s ‚àà L2
            <-> Accepts(A1, s) ‚à® Accepts(A2, s) 
            <-> Accepts(AUnion, s)
        }

        SHOW Regular(Concat(L1, L2)) BY {
          DEFINE AConcat : Automaton = ‚ü®
            States ‚Ü¶ A1.States ‚à™ A2.States,
            Alphabet ‚Ü¶ A1.Alphabet ‚à™ A2.Alphabet,
            Transition ‚Ü¶ A1.Transition ‚à™ A2.Transition ‚à™ {
              ‚ü®q, Œµ, A2.Start‚ü© | q ‚àà A1.Accept  
            },
            Start ‚Ü¶ A1.Start,
            Accept ‚Ü¶ A2.Accept
          ‚ü©
          
          ‚àÄ (s : String) . s ‚àà Concat(L1, L2)
            <-> ‚àÉ (s1 s2 : String) . s = Concat(s1, s2) ‚àß s1 ‚àà L1 ‚àß s2 ‚àà L2
            <-> ‚àÉ (s1 s2 : String) . s = Concat(s1, s2) ‚àß Accepts(A1, s1) ‚àß Accepts(A2, s2)
            <-> Accepts(AConcat, s)
        }
        
        SHOW Regular(KleeneStar(L1)) BY {
          DEFINE AStar : Automaton = ‚ü®
            States ‚Ü¶ {qStart, qAccept} ‚à™ A1.States,
            Alphabet ‚Ü¶ A1.Alphabet,
            Transition ‚Ü¶ A1.Transition ‚à™ {
              ‚ü®qStart, Œµ, A1.Start‚ü©,
              ‚ü®qStart, Œµ, qAccept‚ü©
            } ‚à™ {
              ‚ü®q, Œµ, qAccept‚ü© | q ‚àà A1.Accept
            } ‚à™ {  
              ‚ü®q, Œµ, A1.Start‚ü© | q ‚àà A1.Accept
            },
            Start ‚Ü¶ qStart,
            Accept ‚Ü¶ {qAccept}
          ‚ü©
          
          ‚àÄ (s : String) . s ‚àà KleeneStar(L1)
            <-> ‚àÉ (k : ‚Ñï) (s1 ... s‚Çñ : String) . s = Concat(s1, ..., s‚Çñ) ‚àß ‚àÄ (i : 1..k) . s·µ¢ ‚àà L1
            <-> ‚àÉ (k : ‚Ñï) (s1 ... s‚Çñ : String) . s = Concat(s1, ..., s‚Çñ) ‚àß ‚àÄ (i : 1..k) . Accepts(A1, s·µ¢)  
            <-> Accepts(AStar, s)
        }
        
        SHOW Regular(Intersection(L1, L2)) BY {
          Regular(Complement(Union(Complement(L1), Complement(L2))))
        }
        
        SHOW Regular(Complement(L1)) BY {
          DEFINE AComplement : Automaton = ‚ü®
            States ‚Ü¶ A1.States ‚à™ {qReject},
            Alphabet ‚Ü¶ A1.Alphabet,
            Transition ‚Ü¶ A1.Transition ‚à™ {
              ‚ü®q, a, qReject‚ü© | q ‚àà A1.States, a ‚àà A1.Alphabet, ‚àÑ q' . ‚ü®q, a, q'‚ü© ‚àà A1.Transition  
            } ‚à™ {
              ‚ü®qReject, a, qReject‚ü© | a ‚àà A1.Alphabet
            },
            Start ‚Ü¶ A1.Start,
            Accept ‚Ü¶ A1.States \ A1.Accept
          ‚ü©
          
          ‚àÄ (s : String) . s ‚àà Complement(L1)
            <-> s ‚àâ L1
            <-> ¬¨Accepts(A1, s)
            <-> Accepts(AComplement, s)
        }
      }
    }
    
    THEOREM ContextFreeClosureProperties {
      STATEMENT: ‚àÄ (L1 L2 : Language) . ContextFree(L1) ‚àß ContextFree(L2) ->
        ContextFree(Union(L1, L2)) ‚àß
        ContextFree(Concat(L1, L2)) ‚àß
        ContextFree(KleeneStar(L1)) ‚àß
        ContextFree(Intersection(L1, Regular(L2)))

      PROOF {
        ASSUME [L1 L2 : Language] :
          ContextFree(L1),
          ContextFree(L2)

        LET [G1 G2 : Grammar] :
          IsContextFree(G1) ‚àß ‚àÄ (s : String) . s ‚àà L1 <-> Generates(G1, s),
          IsContextFree(G2) ‚àß ‚àÄ (s : String) . s ‚àà L2 <-> Generates(G2, s)
        
        SHOW ContextFree(Union(L1, L2)) BY {
          DEFINE GUnion : Grammar = ‚ü®
            Variables ‚Ü¶ {S} ‚à™ G1.Variables ‚à™ G2.Variables,
            Terminals ‚Ü¶ G1.Terminals ‚à™ G2.Terminals, 
            Productions ‚Ü¶ G1.Productions ‚à™ G2.Productions ‚à™ {
              ‚ü®S, [G1.Start]‚ü©,
              ‚ü®S, [G2.Start]‚ü©  
            },
            Start ‚Ü¶ S
          ‚ü©
          
          IsContextFree(GUnion),
          ‚àÄ (s : String) . s ‚àà Union(L1, L2)
            <-> s ‚àà L1 ‚à® s ‚àà L2  
            <-> Generates(G1, s) ‚à® Generates(G2, s)
            <-> Generates(GUnion, s)
        }
        
        SHOW ContextFree(Concat(L1, L2)) BY {
          DEFINE GConcat : Grammar = ‚ü®
            Variables ‚Ü¶ {S} ‚à™ G1.Variables ‚à™ G2.Variables,
            Terminals ‚Ü¶ G1.Terminals ‚à™ G2.Terminals,
            Productions ‚Ü¶ G1.Productions ‚à™ G2.Productions ‚à™ {
              ‚ü®S, [G1.Start, G2.Start]‚ü©  
            },
            Start ‚Ü¶ S
          ‚ü©
          
          IsContextFree(GConcat),
          ‚àÄ (s : String) . s ‚àà Concat(L1, L2)
            <-> ‚àÉ (s1 s2 : String) . s = Concat(s1, s2) ‚àß s1 ‚àà L1 ‚àß s2 ‚àà L2
            <-> ‚àÉ (s1 s2 : String) . s = Concat(s1, s2) ‚àß Generates(G1, s1) ‚àß Generates(G2, s2)
            <-> Generates(GConcat, s)
        }
        
        SHOW ContextFree(KleeneStar(L1)) BY {
          DEFINE GStar : Grammar = ‚ü®
            Variables ‚Ü¶ {S} ‚à™ G1.Variables,
            Terminals ‚Ü¶ G1.Terminals,
            Productions ‚Ü¶ G1.Productions ‚à™ {
              ‚ü®S, [Œµ]‚ü©,
              ‚ü®S, [S, G1.Start]‚ü©
            },
            Start ‚Ü¶ S
          ‚ü©
          
          IsContextFree(GStar),
          ‚àÄ (s : String) . s ‚àà KleeneStar(L1)  
            <-> s = Œµ ‚à® ‚àÉ (k : ‚Ñï) (s1 ... s‚Çñ : String) . s = Concat(s1, ..., s‚Çñ) ‚àß ‚àÄ (i : 1..k) . s·µ¢ ‚àà L1
            <-> s = Œµ ‚à® ‚àÉ (k : ‚Ñï) (s1 ... s‚Çñ : String) . s = Concat(s1, ..., s‚Çñ) ‚àß ‚àÄ (i : 1..k) . Generates(G1, s·µ¢)
            <-> Generates(GStar, s)
        }
        
        SHOW ContextFree(Intersection(L1, Regular(L2))) BY {
          LET A : Automaton . ‚àÄ (s : String) . s ‚àà L2 <-> Accepts(A, s)
          
          DEFINE GIntersect : Grammar = ‚ü®
            Variables ‚Ü¶ G1.Variables √ó A.States √ó A.States,
            Terminals ‚Ü¶ G1.Terminals,
            Productions ‚Ü¶ {
              ‚ü®‚ü®X, p, q‚ü©, Œ±‚ü© 
              | ‚ü®X, Œ≤‚ü© ‚àà G1.Productions,
                Œ± ‚àà {
                  [‚ü®Y‚ÇÅ, p, r‚ÇÅ‚ü©, ..., ‚ü®Y‚Çñ, r‚Çñ‚Çã‚ÇÅ, q‚ü©]
                  | Œ≤ = [Y‚ÇÅ, ..., Y‚Çñ] ‚àà G1.Variables^k,
                    ‚àÉ (r‚ÇÅ ... r‚Çñ‚Çã‚ÇÅ : A.States) .
                      ‚àÄ (i : 1..k-1) . ‚ü®r·µ¢‚Çã‚ÇÅ, Y·µ¢, r·µ¢‚ü© ‚àà A.Transition
                } ‚à™ {
                  [a] 
                  | a ‚àà G1.Terminals,
                    ‚ü®p, a, q‚ü© ‚àà A.Transition  
                }
            },
            Start ‚Ü¶ ‚ü®G1.Start, A.Start, q‚ü© WHERE q ‚àà A.Accept
          ‚ü©
          
          IsContextFree(GIntersect),
          ‚àÄ (s : String) . s ‚àà Intersection(L1, L2)
            <-> s ‚àà L1 ‚àß s ‚àà L2
            <-> Generates(G1, s) ‚àß Accepts(A, s)
            <-> Generates(GIntersect, s)
        }
      }
    }
    
    THEOREM PumpingLemma {
      STATEMENT: ‚àÄ (L : Language) . Regular(L) -> 
        ‚àÉ (p : ‚Ñï) . ‚àÄ (s : String) . s ‚àà L ‚àß |s| ‚â• p ->
          ‚àÉ (x y z : String) . s = Concat(x, y, z) ‚àß |y| ‚â• 1 ‚àß |Concat(x, y)| ‚â§ p ‚àß 
            ‚àÄ (i : ‚Ñï) . Concat(x, Repeat(y, i), z) ‚àà L
            
      PROOF {
        ASSUME [L : Language] : Regular(L)
        
        LET A : Automaton . ‚àÄ (s : String) . s ‚àà L <-> Accepts(A, s)
        LET p = |A.States|
        
        ASSUME [s : String] : s ‚àà L ‚àß |s| ‚â• p
        
        LET œÄ : Path(A) . 
          Start(œÄ) = A.Start ‚àß 
          End(œÄ) ‚àà A.Accept ‚àß
          ‚àÄ (i : 0..|s|) . ‚ü®State(œÄ, i), s·µ¢, State(œÄ, i+1)‚ü© ‚àà A.Transition
          
        LET i < j ‚â§ p . State(œÄ, i) = State(œÄ, j)
        
        CHOOSE:
          x = s[0..i],
          y = s[i..j],
          z = s[j..]
          
        HAVE: |y| ‚â• 1 BECAUSE i < j
        HAVE: |Concat(x, y)| ‚â§ p BECAUSE j ‚â§ p
        
        SHOW: ‚àÄ (k : ‚Ñï) . Concat(x, Repeat(y, k), z) ‚àà L BY {
          LET t = Concat(x, Repeat(y, k), z)
          
          DEFINE œÄ·µè : Path(A) = 
            œÄ[0..i] ++ Repeat(œÄ[i..j], k) ++ œÄ[j..]
            
          HAVE: Start(œÄ·µè) = A.Start ‚àß End(œÄ·µè) ‚àà A.Accept
          HAVE: ‚àÄ (i : 0..|t|) . ‚ü®State(œÄ·µè, i), t·µ¢, State(œÄ·µè, i+1)‚ü© ‚àà A.Transition
          
          HENCE Accepts(A, t)
          HENCE t ‚àà L
        }
      }
    }
  }
}