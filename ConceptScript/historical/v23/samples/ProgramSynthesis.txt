CONCEPT ProgramSynthesis {

  LANGUAGE {
    TYPE Program
    TYPE Specification
    TYPE Example = (Input, Output)
    TYPE Constraint
    TYPE Feature
    TYPE Score = â„
    
    FUNC Satisfy : Program -> Specification -> ğ”¹ 
    FUNC Behavior : Program -> Input -> Output
    FUNC Consistent : Program -> ğ’«(Example) -> ğ”¹
    FUNC ExtractConstraints : Specification -> ğ’«(Constraint)
    FUNC ExtractExamples : Specification -> ğ’«(Example)
    FUNC FeatureVector : Program -> Vector[Feature]
    FUNC Distance : Vector[Feature] -> Vector[Feature] -> â„âº
    
    PRED ValidProgram : Program -> ğ”¹
    PRED PartiallyCorrect : Program -> Specification -> ğ”¹
    
    NOTATION "âŸ¦Â·âŸ§" = Behavior
    NOTATION "P âŠ¨ S" = Satisfy(P, S)
    NOTATION "P âˆ¼ ğ“”" = Consistent(P, ğ“”)
    NOTATION "Ï†(Â·)" = FeatureVector
  }
  
  STRUCTURE {
    DEF ValidProgram(P) <-> P is syntactically valid and type-safe
    
    DEF Satisfy(P, S) <-> ValidProgram(P) âˆ§ 
                           (âˆ€ c âˆˆ ExtractConstraints(S). P satisfies c) âˆ§
                           (âˆ€ (i, o) âˆˆ ExtractExamples(S). âŸ¦PâŸ§(i) = o)
                          
    DEF Consistent(P, ğ“”) <-> âˆ€ (i, o) âˆˆ ğ“”. âŸ¦PâŸ§(i) = o
    
    DEF PartiallyCorrect(P, S) <-> ValidProgram(P) âˆ§ P âˆ¼ ExtractExamples(S)
    
    REWRITE Generalize : (Pâ‚ âˆ¼ ğ“”) âˆ§ (Pâ‚‚ âˆ¼ ğ“”) âˆ§ (Ï†(Pâ‚) â‰º Ï†(Pâ‚‚)) -> Pâ‚‚
      WHERE â‰º is a partial order on Feature
    
    REWRITE Abstract : (Pâ‚ âˆ¼ ğ“”) âˆ§ (Ï†(Pâ‚) = Ï†(Pâ‚‚)) âˆ§ (Size(Pâ‚‚) < Size(Pâ‚)) -> Pâ‚‚
  }
  
  PROOFS {
    THEOREM Synthesis {
      STATEMENT: 
        âˆ€ S:Specification. âˆƒ P:Program. P âŠ¨ S
      
      PROOF {
        DEFINE Synthesize(S) = {
          ğ“” := ExtractExamples(S)
          ğ“’ := ExtractConstraints(S)
          P := SearchValidPrograms(ğ“”, ğ“’)
          WHILE Â¬(P âŠ¨ S) DO {
            ğ“”' := ğ“” âˆª {(i, o) | (i, o) âˆˆ GenerateExamples(S) âˆ§ âŸ¦PâŸ§(i) â‰  o} 
            P := SearchValidPrograms(ğ“”', ğ“’)
            P := Generalize(P, ğ“”')
            P := Abstract(P)
          }
          RETURN P
        }
        
        ASSUME [S : Specification]
        LET P = Synthesize(S)
        SHOW P âŠ¨ S BY construction
      }
    }
    
    TACTIC SearchValidPrograms(ğ“”, ğ“’) {
      GENERATE candidate programs P consistent with ğ“”
      FILTER P satisfying constraints ğ“’ 
      RANK P by Distance(Ï†(P), Ï†(Pâ‚€)) for some desired Pâ‚€
      RETURN top-ranked P
    }
    
    TACTIC GenerateExamples(S) {
      GENERATE inputs i covering feature space
      RETURN (i, o) where o is computed via S  
    }
    
    TACTIC Generalize(P, ğ“”) {
      FIND P' such that P' âˆ¼ ğ“” âˆ§ Ï†(P) â‰º Ï†(P')
      RETURN P'
    }
    
    TACTIC Abstract(P) {
      FIND P' such that Ï†(P) = Ï†(P') âˆ§ Size(P') < Size(P)
      RETURN P'
    }
  }
}

This Concept formalizes the key ideas in program synthesis:

Searching for programs consistent with examples and constraints
Iterative refinement by generating additional examples
Generalization and abstraction to find "better" programs
Ranking synthesized programs by distance to some target in feature space

The main theorem states that for any specification, a satisfying program exists and can be found by the synthesis procedure. The tactics define heuristics used in the synthesis process.