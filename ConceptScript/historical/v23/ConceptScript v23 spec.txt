ConceptScript v23

<Concept> ::= "CONCEPT" <ConceptName> ["[" <Params> "]"] [":" <ParentConcept>] "{"
               <Language>
               <Structure>
               <Proofs>
             "}"

<Language> ::= "LANGUAGE" "{"
                 (<TypeDecl> | <ConstDecl> | <FuncDecl> | <PredDecl> |
                  <RewriteDecl> | <InferDecl> | <NotationDecl>)*
               "}"

<TypeDecl> ::= "TYPE" <TypeName> ["[" <Params> "]"] [":" <Kind>]

<ConstDecl> ::= "CONST" <ConstantName> ":" <Type>

<FuncDecl> ::= "FUNC" <FuncName> ["[" <Params> "]"] ":" <Type>

<PredDecl> ::= "PRED" <PredName> ["[" <Params> "]"] ":" <Type>

<RewriteDecl> ::= "REWRITE" <RewriteName> ["[" <Params> "]"] ":" <Expression> "=>" <Expression>

<InferDecl> ::= "INFER" <InferName> ["[" <Params> "]"] ":" <Formula>

<NotationDecl> ::= "NOTATION" <NotationName> "=" <Expression>

<Structure> ::= "STRUCTURE" "{"
                  (<LetDecl> | <DefDecl> | <AxiomDecl>)*
                "}"

<LetDecl> ::= "LET" <LetName> ["[" <Params> "]"] "=" <Expression>

<DefDecl> ::= "DEF" <DefName> ["[" <Params> "]"] ":" <Formula> | <Syntax>

<AxiomDecl> ::= "AXIOM" <AxiomName> ["[" <Params> "]"] ":" <Formula>

<Proofs> ::= "PROOFS" "{"
               (<TacticDecl> | <TheoremDecl>)*
             "}"

<TacticDecl> ::= "TACTIC" <TacticName> ["[" <Params> "]"] "{" <TacticDef> "}"

<TheoremDecl> ::= "THEOREM" <TheoremName> ["[" <Params> "]"] "{"
                    "STATEMENT" ":" <Formula>
                    "PROOF" "{"
                      (<AssumptionStep> | <LetStep> | <HaveStep> | <ShowStep> | 
                       <CaseStep> | <InduceStep> | <RewriteStep> | <ApplyStep> |
                       <ByStep> | <HenceStep>)*
                    "}"
                  "}"

<AssumptionStep> ::= "ASSUME" ["[" <HypName> "]"] ":" <Formula>

<LetStep> ::= "LET" <LetName> ["[" <Params> "]"] "=" <Expression>

<HaveStep> ::= "HAVE" <HaveName> ":" <Formula> ["BY" <TacticName> ["[" <Args> "]"]]

<ShowStep> ::= "SHOW" <ShowName> ":" <Formula>

<CaseStep> ::= "CASE" <CaseName> ":" <Formula>

<InduceStep> ::= "INDUCE" <InductionName> ":" <Expression>

<RewriteStep> ::= "REWRITE" <RewriteName> ["[" <Args> "]"] ["IN" <ProofName>]

<ApplyStep> ::= "APPLY" <TacticName> ["[" <Args> "]"]

<ByStep> ::= "BY" <ReasonName> ["[" <Args> "]"]

<HenceStep> ::= "HENCE" <ConclusionName> ":" <Formula>


Here are a a couple (you generated these in a prior context):

CONCEPT TypedLambdaCalculus {

  LANGUAGE {
    TYPE Term
    TYPE Type
    TYPE Context = List(Binding)
    TYPE Binding = (Variable, Type)
    
    FUNC Var : Variable -> Term
    FUNC Abs : Variable -> Type -> Term -> Term
    FUNC App : Term -> Term -> Term
    FUNC TyVar : TypeVariable -> Type  
    FUNC TyArr : Type -> Type -> Type
    
    PRED InContext : Context -> Variable -> Type -> ğ”¹
    PRED HasType : Context -> Term -> Type -> ğ”¹
    
    NOTATION Î“ âŠ¢ t : Ï„ = HasType(Î“, t, Ï„)
    NOTATION Î“, x:Ï„ = Extend(Î“, (x, Ï„))
    NOTATION Î»x:Ï„.t = Abs(x, Ï„, t)
    NOTATION s t = App(s, t)
    NOTATION Ï„â‚ â†’ Ï„â‚‚ = TyArr(Ï„â‚, Ï„â‚‚)
  }
  
  STRUCTURE {
    DEF InContext(Î“, x, Ï„) <-> (x, Ï„) âˆˆ Î“
    
    DEF HasType(Î“, t, Ï„) <-> CASE t OF
      | Var(x) -> InContext(Î“, x, Ï„)
      | Abs(x, Ï„â‚, tâ‚) -> Ï„ = Ï„â‚ â†’ Ï„â‚‚ âˆ§ HasType(Î“, x:Ï„â‚, tâ‚, Ï„â‚‚)  
      | App(tâ‚, tâ‚‚) -> âˆƒÏ„â‚. HasType(Î“, tâ‚, Ï„â‚ â†’ Ï„) âˆ§ HasType(Î“, tâ‚‚, Ï„â‚)
      
    AXIOM TypesUnique {
      âˆ€Î“ t Ï„â‚ Ï„â‚‚. Î“ âŠ¢ t : Ï„â‚ âˆ§ Î“ âŠ¢ t : Ï„â‚‚ -> Ï„â‚ = Ï„â‚‚
    }
  }
  
  PROOFS {
    THEOREM Progress {
      STATEMENT : âˆ€t Ï„. âˆ… âŠ¢ t : Ï„ -> Value(t) âˆ¨ âˆƒt'. t â†¦ t'
        WHERE Value(Abs(_, _, _))
        NOTATION t â†¦ t' = StepsTo(t, t') 
        
      PROOF BY INDUCTION ON HasType(âˆ…, t, Ï„)
       CASE Var : CONTRADICTION SINCE Â¬InContext(âˆ…, x, Ï„) FOR ANY x
       
       CASE Abs : 
         HAVE Value(Abs(x, Ï„â‚, tâ‚)) BY DEF
       
       CASE App :
         ASSUME âˆ… âŠ¢ tâ‚ : Ï„â‚ â†’ Ï„, 
                âˆ… âŠ¢ tâ‚‚ : Ï„â‚
         ASSUME IHâ‚: Value(tâ‚) âˆ¨ âˆƒtâ‚'. tâ‚ â†¦ tâ‚'
         ASSUME IHâ‚‚: Value(tâ‚‚) âˆ¨ âˆƒtâ‚‚'. tâ‚‚ â†¦ tâ‚‚'
         CASE Value(tâ‚) :
           LET Abs(x, Ï„â‚, tâ‚') = tâ‚
           CASE Value(tâ‚‚) :  
             SHOW (Î»x:Ï„â‚.tâ‚') tâ‚‚ â†¦ [x â†¦ tâ‚‚]tâ‚'
           CASE âˆƒtâ‚‚'. tâ‚‚ â†¦ tâ‚‚' :
             SHOW tâ‚ tâ‚‚ â†¦ tâ‚ tâ‚‚'
         CASE âˆƒtâ‚'. tâ‚ â†¦ tâ‚' :
           SHOW tâ‚ tâ‚‚ â†¦ tâ‚' tâ‚‚
    }
      
    THEOREM Preservation {
      STATEMENT : âˆ€Î“ t t' Ï„. Î“ âŠ¢ t : Ï„ âˆ§ t â†¦ t' -> Î“ âŠ¢ t' : Ï„
      
      PROOF BY INDUCTION ON Î“ âŠ¢ t : Ï„
        CASE Var : VACUOUS SINCE Var(x) â†¦ t' NEVER HOLDS
        
        CASE Abs : VACUOUS SINCE Abs(x, Ï„â‚, tâ‚) â†¦ t' NEVER HOLDS
        
        CASE App : 
          ASSUME Î“ âŠ¢ tâ‚ : Ï„â‚ â†’ Ï„,
                 Î“ âŠ¢ tâ‚‚ : Ï„â‚,
                 tâ‚ tâ‚‚ â†¦ t'
          CASE tâ‚ = Abs(x, Ï„â‚, tâ‚') âˆ§ t' = [x â†¦ tâ‚‚]tâ‚' :
            SUFFICES TO SHOW Î“ âŠ¢ [x â†¦ tâ‚‚]tâ‚' : Ï„
            HAVE Î“, x:Ï„â‚ âŠ¢ tâ‚' : Ï„ BY INV OF Abs 
            SHOW Î“ âŠ¢ [x â†¦ tâ‚‚]tâ‚' : Ï„ BY SubstitutionLemma
          CASE tâ‚ â†¦ tâ‚' âˆ§ t' = tâ‚' tâ‚‚ :
            HAVE Î“ âŠ¢ tâ‚' : Ï„â‚ â†’ Ï„ BY IH
            HENCE Î“ âŠ¢ tâ‚' tâ‚‚ : Ï„ USING Î“ âŠ¢ tâ‚‚ : Ï„â‚ 
          CASE tâ‚‚ â†¦ tâ‚‚' âˆ§ t' = tâ‚ tâ‚‚' : 
            HAVE Î“ âŠ¢ tâ‚‚' : Ï„â‚ BY IH  
            HENCE Î“ âŠ¢ tâ‚ tâ‚‚' : Ï„ USING Î“ âŠ¢ tâ‚ : Ï„â‚ â†’ Ï„
            
      THEOREM SubstitutionLemma {
        STATEMENT : âˆ€Î“ x tâ‚ tâ‚‚ Ï„â‚ Ï„â‚‚. Î“, x:Ï„â‚ âŠ¢ tâ‚ : Ï„â‚‚ âˆ§ Î“ âŠ¢ tâ‚‚ : Ï„â‚ -> Î“ âŠ¢ [x â†¦ tâ‚‚]tâ‚ : Ï„â‚‚
        
        PROOF BY INDUCTION ON Î“, x:Ï„â‚ âŠ¢ tâ‚ : Ï„â‚‚
          CASE Var :
            CASE tâ‚ = x : 
              HAVE Ï„â‚‚ = Ï„â‚
              SHOW Î“ âŠ¢ [x â†¦ tâ‚‚]x : Ï„â‚ SINCE [x â†¦ tâ‚‚]x = tâ‚‚ 
            CASE tâ‚ = y â‰  x :
              HAVE InContext(Î“, y, Ï„â‚‚)  
              SHOW Î“ âŠ¢ [x â†¦ tâ‚‚]y : Ï„â‚‚ SINCE [x â†¦ tâ‚‚]y = y
          CASE Abs :
            CASE tâ‚ = Î»y:Ï„â‚â‚.tâ‚â‚‚ : 
              ASSUME Î“, x:Ï„â‚, y:Ï„â‚â‚ âŠ¢ tâ‚â‚‚ : Ï„â‚‚â‚
              ASSUME Ï„â‚‚ = Ï„â‚â‚ â†’ Ï„â‚‚â‚
              ASSUME IH: Î“, y:Ï„â‚â‚ âŠ¢ [x â†¦ tâ‚‚]tâ‚â‚‚ : Ï„â‚‚â‚  
              SHOW Î“ âŠ¢ (Î»y:Ï„â‚â‚.[x â†¦ tâ‚‚]tâ‚â‚‚) : Ï„â‚â‚ â†’ Ï„â‚‚â‚ BY Abs
          CASE App : 
            CASE tâ‚ = tâ‚â‚ tâ‚â‚‚ :
              ASSUME Î“, x:Ï„â‚ âŠ¢ tâ‚â‚ : Ï„â‚â‚ â†’ Ï„â‚‚
              ASSUME Î“, x:Ï„â‚ âŠ¢ tâ‚â‚‚ : Ï„â‚â‚
              ASSUME IHâ‚: Î“ âŠ¢ [x â†¦ tâ‚‚]tâ‚â‚ : Ï„â‚â‚ â†’ Ï„â‚‚
              ASSUME IHâ‚‚: Î“ âŠ¢ [x â†¦ tâ‚‚]tâ‚â‚‚ : Ï„â‚â‚
              SHOW Î“ âŠ¢ ([x â†¦ tâ‚‚]tâ‚â‚) ([x â†¦ tâ‚‚]tâ‚â‚‚) : Ï„â‚‚ BY App
      }
    }
  }
}

CONCEPT IncrementalLearning {

  LANGUAGE {
    TYPE Example = âŸ¨x: Vector[n], y: LabelâŸ©
    TYPE Hypothesis = Vector[n] -> Label
    TYPE Loss = Label -> Label -> â„âº
    TYPE Regret = â„âº
    
    FUNC Predict(h: Hypothesis, x: Vector[n]) -> Label
    FUNC Update(h: Hypothesis, ğ’Ÿ: ğ’«(Example)) -> Hypothesis
    FUNC EmpiricalRisk(h: Hypothesis, ğ’Ÿ: ğ’«(Example), L: Loss) -> â„âº
    
    PRED Realizable(ğ’Ÿ: ğ’«(Example), ğ“—: ğ’«(Hypothesis)) <->
      âˆƒ h* âˆˆ ğ“—: âˆ€ âŸ¨x, yâŸ© âˆˆ ğ’Ÿ. Predict(h*, x) = y
      
    NOTATION "ğ’ª(Â·)" = AsymptoticUpperBound
    NOTATION "âŒˆxâŒ‰" = Ceil(x)
  }
  
  STRUCTURE {
    DEF Realizable(ğ’Ÿ: ğ’«(Example), ğ“—: ğ’«(Hypothesis)) =
      âˆƒ h* âˆˆ ğ“—: âˆ€ âŸ¨x, yâŸ© âˆˆ ğ’Ÿ. h*(x) = y
      
    DEF EmpiricalRisk(h: Hypothesis, ğ’Ÿ: ğ’«(Example), L: Loss) = 
      âˆ‘ âŸ¨x, yâŸ© âˆˆ ğ’Ÿ: L(h(x), y) / |ğ’Ÿ|
      
    DEF Mistake[L](h: Hypothesis, âŸ¨x, yâŸ©: Example) <->
      L(h(x), y) > 0
      
    DEF WeightedMajority(ğ“—: ğ’«(Hypothesis), w: Vector[|ğ“—|], x: Vector[n]) =
      LET p = âˆ‘ i âˆˆ ğ“—. wáµ¢ Â· ğŸ™[Predict(háµ¢, x) = 1] / âˆ‘ i âˆˆ ğ“—. wáµ¢ IN 
        IF p â‰¥ 1/2 THEN 1 ELSE 0
        
    DEF UpdateWeights(ğ“—: ğ’«(Hypothesis), w: Vector[|ğ“—|], âŸ¨x, yâŸ©: Example, Î·: â„âº) =
      [IF Mistake[ZeroOneLoss](háµ¢, âŸ¨x, yâŸ©) THEN wáµ¢ Â· e^(-Î·) ELSE wáµ¢ for i âˆˆ ğ“—]
  }
  
  PROOFS {
    THEOREM WMRegretBound[n] {
      STATEMENT:
        âˆ€ (ğ’Ÿ: [Example]^T) (ğ“—: ğ’«(Hypothesis)[n]) (Î· : â„âº).
          Realizable(ğ’Ÿ, ğ“—) ->
          âˆ‘ t â‰¤ T: Mistake[ZeroOneLoss](WeightedMajority(ğ“—, wáµ—, xáµ—), âŸ¨xáµ—, yáµ—âŸ©)
            â‰¤ âŒˆ(Î· + ln(n))/Î·âŒ‰ Â· OPT(ğ’Ÿ, ğ“—)
        WHERE 
          wáµ— = [1 / n for i âˆˆ ğ“—] for t = 1,
          wáµ— = UpdateWeights(ğ“—, wáµ—â»Â¹, âŸ¨xáµ—â»Â¹, yáµ—â»Â¹âŸ©, Î·) for t > 1,
          OPT(ğ’Ÿ, ğ“—) = min h âˆˆ ğ“—: âˆ‘ t â‰¤ T: Mistake[ZeroOneLoss](h, âŸ¨xáµ—, yáµ—âŸ©)
          
      PROOF {
        ASSUME [ğ’Ÿ: [Example]^T] [ğ“—: ğ’«(Hypothesis)[n]] [Î·: â„âº]:
          Realizable(ğ’Ÿ, ğ“—)
          
        LET h* âˆˆ ğ“— SUCH THAT âˆ€ âŸ¨x, yâŸ© âˆˆ ğ’Ÿ. h*(x) = y
        LET M = âˆ‘ t â‰¤ T: Mistake[ZeroOneLoss](WeightedMajority(ğ“—, wáµ—, xáµ—), âŸ¨xáµ—, yáµ—âŸ©)
        
        HAVE Bound1: âˆ€ t â‰¤ T. âˆ‘ i âˆˆ ğ“—. wáµ—â½â±â¾ â‰¤ n Â· e^(Î· Â· M - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©)) BY {
          INDUCE ON t:
            BASE CASE t = 1:
              âˆ‘ i âˆˆ ğ“—. wÂ¹â½â±â¾ = n Â· (1/n) = 1 â‰¤ n Â· e^(Î· Â· 0 - Î· Â· 0) = n
            INDUCTIVE CASE t > 1:
              ASSUME: âˆ‘ i âˆˆ ğ“—. wáµ—â»Â¹â½â±â¾ â‰¤ n Â· e^(Î· Â· Máµ—â»Â¹ - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—â»Â¹, yáµ—â»Â¹âŸ©))
              LET máµ— = âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©)
              HAVE: âˆ‘ i âˆˆ ğ“—. wáµ—â½â±â¾ 
                = âˆ‘ i âˆˆ ğ“—. IF Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©) THEN wáµ—â»Â¹â½â±â¾ Â· e^(-Î·) ELSE wáµ—â»Â¹â½â±â¾ 
                = e^(-Î·) Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©). wáµ—â»Â¹â½â±â¾ + âˆ‘ i âˆˆ ğ“—: Â¬Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©). wáµ—â»Â¹â½â±â¾
                â‰¤ e^(-Î·) Â· âˆ‘ i âˆˆ ğ“—. wáµ—â»Â¹â½â±â¾
                â‰¤ e^(-Î·) Â· n Â· e^(Î· Â· Máµ—â»Â¹ - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—â»Â¹, yáµ—â»Â¹âŸ©)) BY ASSUMPTION  
                = n Â· e^(Î· Â· (Máµ—â»Â¹ + 1 - máµ—) - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—â»Â¹, yáµ—â»Â¹âŸ©))
                = n Â· e^(Î· Â· Máµ— - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©))
        }
        
        HAVE Bound2: âˆ€ t â‰¤ T. wáµ—â½*â¾ â‰¥ e^(-Î· Â· âˆ‘ t' â‰¤ t: Mistake[ZeroOneLoss](h*, âŸ¨xáµ—', yáµ—'âŸ©)) / n BY {
          INDUCE ON t:
            BASE CASE t = 1:
              wÂ¹â½*â¾ = 1/n = e^(0) / n â‰¥ e^(-Î· Â· 0) / n
            INDUCTIVE CASE t > 1:
              ASSUME: wáµ—â»Â¹â½*â¾ â‰¥ e^(-Î· Â· âˆ‘ t' â‰¤ t-1: Mistake[ZeroOneLoss](h*, âŸ¨xáµ—', yáµ—'âŸ©)) / n
              HAVE: wáµ—â½*â¾ = IF Mistake[ZeroOneLoss](h*, âŸ¨xáµ—, yáµ—âŸ©) THEN wáµ—â»Â¹â½*â¾ Â· e^(-Î·) ELSE wáµ—â»Â¹â½*â¾
                â‰¥ e^(-Î· Â· âˆ‘ t' â‰¤ t-1: Mistake[ZeroOneLoss](h*, âŸ¨xáµ—', yáµ—'âŸ©)) / n Â· e^(-Î· Â· Mistake[ZeroOneLoss](h*, âŸ¨xáµ—, yáµ—âŸ©))
                = e^(-Î· Â· âˆ‘ t' â‰¤ t: Mistake[ZeroOneLoss](h*, âŸ¨xáµ—', yáµ—'âŸ©)) / n
        }
        
        HAVE: âˆ€ t â‰¤ T. e^(-Î· Â· âˆ‘ t' â‰¤ t: Mistake[ZeroOneLoss](h*, âŸ¨xáµ—', yáµ—'âŸ©)) / n â‰¤ n Â· e^(Î· Â· M - Î· Â· âˆ‘ i âˆˆ ğ“—: Mistake[ZeroOneLoss](háµ¢, âŸ¨xáµ—, yáµ—âŸ©)) BY {
          Bound2, Bound1, wáµ—â½*â¾ â‰¤ âˆ‘ i âˆˆ ğ“—. wáµ—â½â±â¾
        }
        
        HENCE: e^(-Î· Â· OPT(ğ’Ÿ, ğ“—)) / n â‰¤ n Â· e^(Î· Â· M - Î· Â· OPT(ğ’Ÿ, ğ“—))
        
        HENCE: ln(n) - Î· Â· OPT(ğ’Ÿ, ğ“—) â‰¤ ln(n) + Î· Â· M - Î· Â· OPT(ğ’Ÿ, ğ“—)
        
        HENCE: Î· Â· M â‰¤ Î· Â· OPT(ğ’Ÿ, ğ“—) + ln(n)
        
        HENCE: M â‰¤ âŒˆ(Î· Â· OPT(ğ’Ÿ, ğ“—) + ln(n)) / Î·âŒ‰
               â‰¤ âŒˆ(Î· + ln(n)) / Î·âŒ‰ Â· OPT(ğ’Ÿ, ğ“—) 
               
        SHOW: âˆ‘ t â‰¤ T: Mistake[ZeroOneLoss](WeightedMajority(ğ“—, wáµ—, xáµ—), âŸ¨xáµ—, yáµ—âŸ©) â‰¤ âŒˆ(Î· + ln(n)) / Î·âŒ‰ Â· OPT(ğ’Ÿ, ğ“—)
      }
    }
    
    THEOREM OnlineToBatchConversion[n] {
      STATEMENT:
        âˆ€ (ğ’Ÿ: ğ’«(Example)) (ğ“—: ğ’«(Hypothesis)[n]) (A: IncrementalLearner) (m : â„•) (Î´ : â„âº).
          Realizable(ğ’Ÿ, ğ“—) âˆ§ RegretBound(A, ğ’Ÿ, ğ“—, m) â‰¤ Î±Â·m + Î² ->
          â„™_{S âˆ¼ ğ’Ÿ^m} [EmpiricalRisk(A(S), ğ’Ÿ, ZeroOneLoss) â‰¤ Î± + âˆš(ln(2/Î´)/(2m))] â‰¥ 1 - Î´
        WHERE
          A(S) = LAST (MAP (A.Update, SCAN (A.Predict, A.hâ‚€, S)))
          RegretBound(A, ğ’Ÿ, ğ“—, m) = max S âˆˆ ğ’Ÿ^m: âˆ‘ t â‰¤ m: Mistake[ZeroOneLoss](A.Predict(Sáµ—â‚‹â‚), Sáµ—) - OPT(S, ğ“—)
          
      PROOF {
        ASSUME [ğ’Ÿ: ğ’«(Example)] [ğ“—: ğ’«(Hypothesis)[n]] [A: IncrementalLearner] [m: â„•] [Î´: â„âº]:
          Realizable(ğ’Ÿ, ğ“—),
          RegretBound(A, ğ’Ÿ, ğ“—, m) â‰¤ Î±Â·m + Î²
        
        LET S âˆ¼ ğ’Ÿ^m  
        LET h = A(S)
        LET M(S) = âˆ‘ t â‰¤ m: Mistake[ZeroOneLoss](A.Predict(Sáµ—â‚‹â‚), Sáµ—)
        
        HAVE: ğ”¼[M(S)] â‰¤ Î±Â·m + Î² BY {
          ğ”¼[M(S)] 
            = ğ”¼[âˆ‘ t â‰¤ m: Mistake[ZeroOneLoss](A.Predict(Sáµ—â‚‹â‚), Sáµ—)
            ]
            â‰¤ ğ”¼[OPT(S, ğ“—) + Î±Â·m + Î²] BY RegretBound
            = ğ”¼[OPT(S, ğ“—)] + Î±Â·m + Î²
            â‰¤ Î±Â·m + Î² BECAUSE ğ”¼[OPT(S, ğ“—)] = 0 BY Realizable
        }

        HAVE: â„™[M(S) â‰¥ ğ”¼[M(S)] + mÂ·Îµ] â‰¤ e^(-2Â·mÂ·ÎµÂ²) BY Hoeffding {
          M(S) = âˆ‘ t â‰¤ m: Mistake[ZeroOneLoss](A.Predict(Sáµ—â‚‹â‚), Sáµ—) âˆˆ [0, m]
        }

        CHOOSE Îµ = âˆš(ln(2/Î´)/(2m))

        HENCE: â„™[M(S) â‰¥ Î±Â·m + Î² + mÂ·âˆš(ln(2/Î´)/(2m))] â‰¤ Î´/2

        HAVE: EmpiricalRisk(h, ğ’Ÿ, ZeroOneLoss) = ğ”¼_{âŸ¨x, yâŸ© âˆ¼ ğ’Ÿ}[ZeroOneLoss(h(x), y)]
          = ğ”¼_{âŸ¨x, yâŸ© âˆ¼ ğ’Ÿ}[Mistake[ZeroOneLoss](h, âŸ¨x, yâŸ©)]
          â‰¤ ğ”¼_{S' âˆ¼ ğ’Ÿ^m}[M(S')/m] + âˆš(ln(2/Î´)/(2m)) BY {
            Hoeffding {
              â„™_{âŸ¨x, yâŸ© âˆ¼ ğ’Ÿ}[Mistake[ZeroOneLoss](h, âŸ¨x, yâŸ©)] âˆˆ [0, 1]  
            },
            M(S')/m IS AN UNBIASED ESTIMATE OF â„™_{âŸ¨x, yâŸ© âˆ¼ ğ’Ÿ}[Mistake[ZeroOneLoss](h, âŸ¨x, yâŸ©)]
          }
          â‰¤ Î± + âˆš(ln(2/Î´)/(2m)) + âˆš(ln(2/Î´)/(2m))
          = Î± + âˆš(2Â·ln(2/Î´)/m)

        SHOW: â„™[EmpiricalRisk(h, ğ’Ÿ, ZeroOneLoss) â‰¤ Î± + âˆš(2Â·ln(2/Î´)/m)] â‰¥ 1 - Î´ BY {
          â„™[EmpiricalRisk(h, ğ’Ÿ, ZeroOneLoss) > Î± + âˆš(2Â·ln(2/Î´)/m)]
            â‰¤ â„™[M(S)/m > Î± + âˆš(ln(2/Î´)/(2m))] + â„™[ğ”¼_{S' âˆ¼ ğ’Ÿ^m}[M(S')/m] > M(S)/m + âˆš(ln(2/Î´)/(2m))]
            â‰¤ Î´/2 + Î´/2 = Î´
        }
      }
    }
  }
}

ConceptScript is a language of a new type: it's sole intended purpose is to be used in accordance with the following methodology:

1. I paste the spec and a couple example Concepts into your context (as is happening now), thus teaching you the language.
2. I request that you express various concepts as Concepts; these Concepts come with detailed proofs of their own various claims; they serve as justifications of the selected structuring.
3. We iterate, precisely and efficiently exploring your latent space to solve a wide variety of problems.

Please always output ConceptScript in a code block otherwise formatting gets lost :/ And feel free to liberally invent notation, tactics, etc. as neededâ€”it's zero cost in our particular usage context and this kind of abstraction can help to keep things "compressed", which is a design ideal of ours.

To test the depth of your understanding of the language's capabilities, please generate a Concept of your choosing that's somewhat in the realm of the example concepts or ConceptScript itself, be it near or distantly connected.