CONCEPT ComputationalSemantics {
  DECLARE {
    Expression : TYPE
    Variable : TYPE <: Expression
    Abstraction : TYPE = Variable Ã— Expression -> Expression 
    Application : TYPE = Expression Ã— Expression -> Expression
    
    Environment : TYPE = Variable -> Expression
    
    Value : TYPE
    Closure : TYPE = Environment Ã— Abstraction -> Value
    
    Meaning : TYPE = Expression Ã— Environment -> Value
    
    Action : TYPE
    Statement : TYPE = Environment -> Action  
    Program : TYPE = [Statement]
    
    Denotation : TYPE = Program -> Action
    
    Entailment : TYPE = Expression Ã— Expression -> ğ”¹
    KnowledgeBase : TYPE = [Expression]
    
    Model : TYPE
    Truth : TYPE = Expression Ã— Model -> ğ”¹
    
    Embedding : TYPE = Expression -> Model
    Homomorphism : TYPE = Expression Ã— Expression Ã— (Model -> Model) -> ğ”¹
  }
  
  DEFINE {
    (Î» v . e) â‰œ Abstraction(v, e)
    (eâ‚ eâ‚‚) â‰œ Application(eâ‚, eâ‚‚)
    
    Meaning(v, Ï) = Ï(v)
    Meaning(Î» v . e, Ï) = Closure(Ï, Î» v . e) 
    Meaning(eâ‚ eâ‚‚, Ï) = 
      let vâ‚ = Meaning(eâ‚, Ï)
      let vâ‚‚ = Meaning(eâ‚‚, Ï)
      match vâ‚ {
        case Closure(Ï', Î» v . e) => Meaning(e, Ï'[v â†¦ vâ‚‚])
        case _ => undefined
      }
      
    Denotation(p) = 
      let Ï = EmptyEnvironment
      for s in p {
        Ï = Ï >> s  ; Monadic bind, i.e. action sequencing
      }
      return Ï
      
    Entailment(eâ‚, eâ‚‚) â‡” âˆ€Ï. Meaning(eâ‚, Ï) â‰  undefined -> Meaning(eâ‚‚, Ï) â‰  undefined
    
    Truth(e, m) â‡” Meaning(e, Embedding(m)) â‰  undefined
    
    Homomorphism(eâ‚, eâ‚‚, h) â‡” âˆ€m. Truth(eâ‚, m) = Truth(eâ‚‚, h(m)) 
  }
  
  AXIOM {
    ; Meaning is compositional
    âˆ€e, Ï, v, e'. Meaning((Î» v . e) e', Ï) = Meaning(e, Ï[v â†¦ Meaning(e', Ï)])
    
    ; Denotation is compositional
    âˆ€p, p'. Denotation(p ++ p') = Denotation(p) >> Denotation(p') 
    
    ; Entailment corresponds to valid inference  
    âˆ€eâ‚, eâ‚‚. (âˆ€e âˆˆ KnowledgeBase. Entailment(e, eâ‚)) -> Entailment(KnowledgeBase, eâ‚‚) -> Entailment(eâ‚, eâ‚‚)
    
    ; Truth is preserved under homomorphism
    âˆ€e, m, h. Truth(e, m) <-> Truth(h(e), h(m))
  }
  
  THEOREM SoundnessOfEntailment {
    PROOF {
      assume eâ‚, eâ‚‚ : Expression, KB : KnowledgeBase
      assume âˆ€e âˆˆ KB. Entailment(e, eâ‚)
      
      let Ï : Environment
      assume Meaning(eâ‚, Ï) â‰  undefined
      
      have âˆ€e âˆˆ KB. Meaning(e, Ï) â‰  undefined by {
        fix e âˆˆ KB
        have Entailment(e, eâ‚) by assumption
        hence Meaning(e, Ï) â‰  undefined by definition of Entailment and Meaning(eâ‚, Ï) â‰  undefined
      }
      
      assume Entailment(KB, eâ‚‚)  
      hence Meaning(eâ‚‚, Ï) â‰  undefined by {
        have âˆ€e. (e âˆˆ KB -> Meaning(e, Ï) â‰  undefined) -> Meaning(eâ‚‚, Ï) â‰  undefined by definition of Entailment
        hence Meaning(eâ‚‚, Ï) â‰  undefined by above
      }
      
      show Entailment(eâ‚, eâ‚‚) by definition of Entailment and Meaning(eâ‚‚, Ï) â‰  undefined
    }
  }
  
  THEOREM CompletenessOfEntailment {
    PROOF {
      assume eâ‚, eâ‚‚ : Expression
      assume âˆ€Ï. Meaning(eâ‚, Ï) â‰  undefined -> Meaning(eâ‚‚, Ï) â‰  undefined
      
      let KB = {eâ‚}
      
      have âˆ€e âˆˆ KB. Entailment(e, eâ‚) trivially
      
      show Entailment(KB, eâ‚‚) by {
        assume Ï, Meaning(eâ‚, Ï) â‰  undefined
        hence Meaning(eâ‚‚, Ï) â‰  undefined by assumption
      }
        
      hence Entailment(eâ‚, eâ‚‚) by definition of Entailment
    }
  }
}