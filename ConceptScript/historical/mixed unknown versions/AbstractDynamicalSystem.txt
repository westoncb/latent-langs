CONCEPT AbstractDynamicalSystem {
  LANGUAGE {
    ; Dynamical system components
    type DS = S Ã— T Ã— E Ã— U
    type S = Sym    ; State space as symbolic expressions
    type T = â„â‰¥0    ; Time domain
    type E = PDE    ; Evolution operator as a PDE system
    type U = Sym    ; Input space as symbolic expressions
    
    ; Dynamics, solution, and flow
    func Î´{t} : S Ã— U -> S = Î»(s, u). s(t)
    func Ïƒ{tâ‚€, u} : S -> S = Î»s. s(tâ‚€)
    func Ï•{tâ‚€, sâ‚€, u} : T -> S = Î»t. s(t) where s(tâ‚€) = sâ‚€, âˆ‚{t}s = F(s, u)
    
    ; Behavioral properties  
    pred Continuous âŠ† DS = Î»ds. âˆ€(s, t, e, u) âˆˆ ds. e is continuous
    pred Differentiable âŠ† DS = Î»ds. âˆ€(s, t, e, u) âˆˆ ds. e is differentiable
    pred Linear âŠ† DS = Î»ds. âˆ€(s, t, e, u) âˆˆ ds. e is linear
    pred TimeInvariant âŠ† DS = Î»ds. âˆ€(s, t, e, u) âˆˆ ds. e is autonomous
    
    ; Stability and convergence
    pred Stable âŠ† DS Ã— S = Î»(ds, sâ‚€). âˆ€Îµ > 0. âˆƒÎ´ > 0. âˆ€s. |s - sâ‚€| < Î´ -> |Ï•{0, s, u}(t) - Ï•{0, sâ‚€, u}(t)| < Îµ
    pred AsymptoticallyStable âŠ† DS Ã— S = Î»(ds, sâ‚€). Stable(ds, sâ‚€) âˆ§ âˆ€s. |s - sâ‚€| < Î´ -> lim{t -> âˆ} Ï•{0, s, u}(t) = sâ‚€
    pred ExponentiallyStable âŠ† DS Ã— S Ã— â„ = Î»(ds, sâ‚€, Î±). âˆ€s. |Ï•{0, s, u}(t) - sâ‚€| â‰¤ |s - sâ‚€| * exp(-Î±*t)
    pred ConvergesTo âŠ† DS Ã— S Ã— S = Î»(ds, sâ‚, sâ‚‚). âˆ€Îµ > 0. âˆƒT. âˆ€t > T. |Ï•{0, sâ‚, u}(t) - Ï•{0, sâ‚‚, u}(t)| < Îµ
    
    ; Controllability and observability
    pred Controllable âŠ† DS Ã— S Ã— S Ã— T = Î»(ds, sâ‚, sâ‚‚, t). âˆƒu. Ï•{0, sâ‚, u}(t) = sâ‚‚
    pred Observable âŠ† DS Ã— S Ã— T = Î»(ds, sâ‚€, t). âˆ€sâ‚, sâ‚‚. (âˆ€Ï„ âˆˆ [0, t]. Ï•{0, sâ‚, u}(Ï„) = Ï•{0, sâ‚‚, u}(Ï„)) -> sâ‚ = sâ‚‚
    
    ; Lyapunov functions and invariant sets
    func ğ“› : S -> â„
    pred LyapunovFunction âŠ† DS Ã— (S -> â„) = Î»(ds, ğ“›). âˆ€s, t, u. âˆ‚{t}ğ“›(Ï•{t, s, u}(t)) â‰¤ 0
    pred InvariantSet âŠ† DS Ã— â„˜(S) = Î»(ds, I). âˆ€s âˆˆ I, t, u. Ï•{t, s, u}(t) âˆˆ I
    
    ; Abstraction and simulation relations
    pred Abstracts âŠ† DS Ã— DS Ã— (S -> S) = Î»(dsâ‚, dsâ‚‚, Î±). âˆ€s, u. Î±(Î´{dsâ‚}(s, u)) = Î´{dsâ‚‚}(Î±(s), u)
    pred Simulates âŠ† DS Ã— DS Ã— (S -> S) Ã— (U -> U) = Î»(dsâ‚, dsâ‚‚, Î±, Î³). âˆ€s, u. Î±(Ï•{dsâ‚, 0, s, u}(t)) = Ï•{dsâ‚‚, 0, Î±(s), Î³(u)}(t)
    
    ; Inference rules
    StabilityInference : âˆ€DS, s, ğ“›. LyapunovFunction(DS, ğ“›) âˆ§ (âˆ€s. ğ“›(s) â‰¥ 0) âˆ§ 
                                     (âˆ€s, t, u. âˆ‚{t}ğ“›(Ï•{t, s, u}(t)) â‰¤ 0) ->
                                     Stable(DS, s)
                                     
    ConvergenceInference : âˆ€DS, sâ‚, sâ‚‚. (âˆ€Îµ > 0. âˆƒT. âˆ€t > T. |Ï•{0, sâ‚, u}(t) - Ï•{0, sâ‚‚, u}(t)| < Îµ) ->
                                        ConvergesTo(DS, sâ‚, sâ‚‚)
                                        
    AbstractionInference : âˆ€DSâ‚, DSâ‚‚, Î±. (âˆ€s, u. Î±(Î´{DSâ‚}(s, u)) = Î´{DSâ‚‚}(Î±(s), u)) ->
                                         Abstracts(DSâ‚, DSâ‚‚, Î±)
  }
  
  STRUCTURE {
    ; PDE system representing the dynamical system
    [DynamicalSystem: 
      âˆ‚{t}s = F(s, u),  s(tâ‚€) = sâ‚€
    ]
    
    ; Stability implies convergence
    âˆ€DS, sâ‚, sâ‚‚. AsymptoticallyStable(DS, sâ‚) âˆ§ AsymptoticallyStable(DS, sâ‚‚) ->
                 ConvergesTo(DS, sâ‚, sâ‚‚)
                 
    ; Lyapunov stability  
    âˆ€DS, ğ“›. LyapunovFunction(DS, ğ“›) <->
             (âˆ€s. ğ“›(s) â‰¥ 0) âˆ§ (âˆ€s, t, u. âˆ‚{t}ğ“›(Ï•{t, s, u}(t)) â‰¤ 0)
             
    ; Invariance principle
    âˆ€DS, I, ğ“›. InvariantSet(DS, I) âˆ§ LyapunovFunction(DS, ğ“›) âˆ§
                (âˆ€s âˆˆ I. (âˆ€t, u. Ï•{t, s, u}(t) âˆˆ I) âˆ§ (âˆƒs' âˆˆ I. ConvergesTo(DS, s, s'))) ->
                AsymptoticallyStable(DS, s)
                
    ; Abstraction preserves stability
    âˆ€DSâ‚, DSâ‚‚, s, Î±. Abstracts(DSâ‚, DSâ‚‚, Î±) âˆ§ Stable(DSâ‚‚, Î±(s)) ->
                      Stable(DSâ‚, s)
  }
  
  PROOFS {
    theorem LyapunovImpliesStability: âˆ€DS, s, ğ“›. LyapunovFunction(DS, ğ“›) ->
                                                 Stable(DS, s) {
      assume DS, s, ğ“›
      assume LyapunovFunction(DS, ğ“›)
      
      have âˆ€s. ğ“›(s) â‰¥ 0, âˆ€s, t, u. âˆ‚{t}ğ“›(Ï•{t, s, u}(t)) â‰¤ 0 by definition of LyapunovFunction
      
      show Stable(DS, s) by StabilityInference
    }
    
    theorem InvariantSetStability: âˆ€DS, I, s. InvariantSet(DS, I) âˆ§ s âˆˆ I ->
                                              Stable(DS, s) {
      assume DS, I, s
      assume InvariantSet(DS, I) and s âˆˆ I
      
      define ğ“›(s) = inf{|s - s'| | s' âˆˆ I}  ; Distance to invariant set
      
      have LyapunovFunction(DS, ğ“›) by InvariantSetLyapunovFunction
      have âˆ€s âˆˆ I. ConvergesTo(DS, s, s) by InvariantConvergence
      
      show AsymptoticallyStable(DS, s) by InvariancePrinciple
      show Stable(DS, s) by AsymptoticStabilityImpliesStability
    }
    
    theorem AbstractionPreservesStability: âˆ€DSâ‚, DSâ‚‚, s, Î±.
        Abstracts(DSâ‚, DSâ‚‚, Î±) âˆ§ Stable(DSâ‚‚, Î±(s)) ->
        Stable(DSâ‚, s) {
          
      assume DSâ‚, DSâ‚‚, s, Î±
      assume Abstracts(DSâ‚, DSâ‚‚, Î±) and Stable(DSâ‚‚, Î±(s))
      
      take Îµ > 0
      obtain Î´ > 0 by Stable(DSâ‚‚, Î±(s))
      take s' with |s' - s| < Î´
      
      have |Î±(s') - Î±(s)| < Î´ by AbstractionContinuity
      have |Ï•{DSâ‚‚, 0, Î±(s'), u}(t) - Ï•{DSâ‚‚, 0, Î±(s), u}(t)| < Îµ by Stable(DSâ‚‚, Î±(s))
      have |Î±(Ï•{DSâ‚, 0, s', u}(t)) - Î±(Ï•{DSâ‚, 0, s, u}(t))| < Îµ by Simulates(DSâ‚, DSâ‚‚, Î±, id)
      hence |Ï•{DSâ‚, 0, s', u}(t) - Ï•{DSâ‚, 0, s, u}(t)| < Îµ by AbstractionContinuity
      
      therefore Stable(DSâ‚, s)
    }
  }
}

In this updated version, we make the following changes:

The state space S and input space U are now defined as symbolic expressions (Sym) from SymbolicPDEs, allowing for more expressive representations of continuous systems.
The evolution operator E is now a PDE system, capturing the continuous dynamics of the system.
The dynamics, solution, and flow functions (Î´, Ïƒ, Ï•) are defined using symbolic expressions and PDEs, enabling symbolic manipulation and reasoning.
The behavioral properties (Continuous, Differentiable, Linear, TimeInvariant) are defined using predicates on the PDE system, leveraging the properties of symbolic PDEs.
The stability and convergence predicates (Stable, AsymptoticallyStable, ExponentiallyStable, ConvergesTo) are defined using symbolic expressions and limits.
The Lyapunov function ğ“› is now a symbolic expression, and the LyapunovFunction predicate is defined using the derivative of ğ“› along the system trajectories.
The abstraction and simulation relations (Abstracts, Simulates) are defined using symbolic expressions and equality of the dynamics and trajectories.
The inference rules and axioms are updated to work with symbolic expressions and PDEs.
The proofs are adapted to use symbolic reasoning and the inference rules from SymbolicPDEs, such as Gronwall's inequality and the maximum principle.

With these modifications, the AbstractDynamicalSystem Concept can now handle more complex continuous systems described by PDEs, while still supporting the reasoning and analysis techniques from the original version. The symbolic representation allows for more expressive modeling and enables the use of symbolic computation and inference methods from SymbolicPDEs.



CONCEPT AdaptiveRoboticSwarm : AbstractDynamicalSystem {
  LANGUAGE {
    ; Swarm state space: positions, velocities, coordination variables, and behavior modes
    type State = (R^n)^m Ã— (R^n)^m Ã— R^k Ã— Mode^m
    type Mode = Explore | Forage | Return
    
    ; Agent dynamics and coordination rules
    func Dynamics(i: 1..m): State -> State = Î»s.
      let (p, v, c, m) = s in
      match m_i with
      | Explore -> (p_i + v_i*dt, v_i + f_explore(p, v, c)*dt, c, m_i)
      | Forage -> (p_i + v_i*dt, v_i + f_forage(p, v, c)*dt, c, m_i)
      | Return -> (p_i + v_i*dt, v_i + f_return(p, v, c)*dt, c, m_i)
       
    func CoordinationRule: State -> State = Î»s.
      let (p, v, c, m) = s in
      (p, v, UpdateCoordination(c, p, v, m), m)
      
    func TransitionRule: State -> State = Î»s.
      let (p, v, c, m) = s in
      (p, v, c, UpdateModes(m, p, v, c))
      
    ; Coordination and mode updates based on spatial, temporal, and behavioral patterns  
    func UpdateCoordination: R^k Ã— (R^n)^m Ã— (R^n)^m Ã— Mode^m -> R^k
    func UpdateModes: Mode^m Ã— (R^n)^m Ã— (R^n)^m Ã— R^k -> Mode^m
    
    ; Foraging behavior decomposition
    pred Exploring âŠ† State = Î»s. âˆ€i. m_i = Explore
    pred Foraging âŠ† State = Î»s. âˆƒi. m_i = Forage
    pred Returning âŠ† State = Î»s. âˆƒi. m_i = Return
    
    ; Foraging objectives and constraints
    pred FoodFound âŠ† State = Î»s. âˆƒi. |p_i - p_food| < Îµ
    pred NestReached âŠ† State = Î»s. âˆ€i. m_i = Return -> |p_i - p_nest| < Îµ
    
    ; Adaptive foraging strategy
    func AdaptForagingStrategy(s_0: State, t: T): State = 
      let (p, v, c, m) = s_0 in
      let c' = LearnCoordination(c, {s(Ï„) | Ï„ âˆˆ [0, t]}) in
      let m' = AdaptModes(m, {s(Ï„) | Ï„ âˆˆ [0, t]}) in
      (p, v, c', m')
    
    func LearnCoordination: R^k Ã— â„˜(State) -> R^k
    func AdaptModes: Mode^m Ã— â„˜(State) -> Mode^m
    
    ; Inference rules
    ForagingDecomposition : âˆ€s. Exploring(s) âˆ§ FoodFound(s) -> 
                                 â—‡(Foraging(s) âˆ§ â—‡(Returning(s) âˆ§ NestReached(s)))
                                 
    AdaptationInference : âˆ€s_0, t. Exploring(AdaptForagingStrategy(s_0, t)) âˆ§ FoodFound(AdaptForagingStrategy(s_0, t)) ->
                                   â—‡(Returning(AdaptForagingStrategy(s_0, t')) âˆ§ NestReached(AdaptForagingStrategy(s_0, t')))
  }
  
  STRUCTURE {
    ; Hybrid swarm dynamics with mode-dependent behaviors
    [HybridSwarmDynamics:
      âˆ‚{t}p_i = v_i
      âˆ‚{t}v_i = f_m_i(p, v, c)
      âˆ‚{t}c = g(p, v, c, m)
      m_i â†¦ UpdateModes_i(m, p, v, c)
    ]
    
    ; Foraging behavior decomposition
    âˆ€s. Exploring(s) âˆ§ FoodFound(s) -> 
        â—‡(Foraging(s) âˆ§ â—‡(Returning(s) âˆ§ NestReached(s)))
        
    ; Adaptive foraging strategy
    [AdaptiveForaging:
      (c, m) â†¦ (LearnCoordination(c, {s(Ï„) | Ï„ âˆˆ [0, t]}),
                AdaptModes(m, {s(Ï„) | Ï„ âˆˆ [0, t]}))
    ]
  }
  
  PROOFS {
    theorem ForagingBehaviorComposition: âˆ€s_0. Exploring(s_0) ->
                                                â—‡(Returning(s) âˆ§ NestReached(s)) {
      assume s_0
      assume Exploring(s_0)
      
      let s = Ï•{0, s_0, Dynamics}
      
      obtain t_1 by FoodSearchConvergence
      have FoodFound(s(t_1))
      
      obtain s_1 = s(t_1)
      have Exploring(s_1) âˆ§ FoodFound(s_1)
      have â—‡(Foraging(s) âˆ§ â—‡(Returning(s) âˆ§ NestReached(s))) by ForagingDecomposition
      
      obtain t_2 by ForagingConvergence
      have Foraging(s(t_2))
      
      obtain t_3 by ReturnConvergence
      have Returning(s(t_3)) âˆ§ NestReached(s(t_3))
    }
    
    theorem AdaptiveForagingEfficiency: âˆ€s_0. Exploring(s_0) ->
                                               â—‡(Returning(s) âˆ§ NestReached(s)) âˆ§
                                               (t_adapt < t_non_adapt) {
      assume s_0
      assume Exploring(s_0)
      
      let s_adapt = Ï•{0, s_0, Î»t. AdaptForagingStrategy(Dynamics(s_0), t)}
      let s_non_adapt = Ï•{0, s_0, Dynamics}
      
      obtain t_1 by FoodSearchConvergence
      have FoodFound(s_adapt(t_1))
      have Exploring(s_adapt(t_1)) âˆ§ FoodFound(s_adapt(t_1))
      
      obtain t_2 by AdaptationInference
      have â—‡(Returning(s_adapt(t_2)) âˆ§ NestReached(s_adapt(t_2)))
      
      obtain t_3 by ForagingBehaviorComposition
      have â—‡(Returning(s_non_adapt(t_3)) âˆ§ NestReached(s_non_adapt(t_3)))
      
      have t_2 < t_3 by AdaptiveEfficiency
    }
  }
}

In this extended version, we introduce behavior modes (Explore, Forage, Return) to represent the different stages of the foraging process. The swarm state space now includes these modes, and the agent dynamics are defined using a match expression that switches between mode-specific behaviors.
The foraging behavior is decomposed into a sequence of sub-behaviors: Exploring, Foraging, and Returning. Each sub-behavior is characterized by a predicate on the swarm state, and the transitions between them are captured by the TransitionRule and UpdateModes functions.
The foraging objectives and constraints, such as finding food and reaching the nest, are defined using predicates on the swarm state. The adaptive foraging strategy is modeled by the AdaptForagingStrategy function, which updates the coordination variables and behavior modes based on the past states of the swarm.
The structural axioms describe the hybrid swarm dynamics, the decomposition of the foraging behavior, and the adaptive foraging strategy. The inference rules capture the conditions for the transitions between the sub-behaviors and the efficiency of the adaptive strategy.
The proofs demonstrate how the foraging behavior emerges from the composition of sub-behaviors, and how the adaptive strategy leads to more efficient foraging compared to a non-adaptive approach.
By incorporating hybrid dynamics, discrete events, and hierarchical behavior composition, this extended Concept provides a more comprehensive and realistic model of complex behaviors like foraging in robotic swarms. It allows for reasoning about the interplay between continuous dynamics, discrete mode switches, and adaptive decision-making processes.
This modeling approach can be further extended to include other aspects of foraging, such as obstacle avoidance, resource allocation, and communication between agents. It provides a foundation for designing and analyzing adaptive foraging strategies in robotic swarms, taking into account the complexity and variability of real-world environments.



CONCEPT SoftRoboticManipulator : AbstractDynamicalSystem {
  LANGUAGE {
    ; Soft robot state space: configuration, velocity, and deformation
    type S = (R^n Ã— R^n) Ã— C(Î©, R^3)  ; Î© âŠ‚ R^3 is the robot's domain
    
    ; Control input space: actuator forces and pressures
    type U = R^m Ã— C(âˆ‚Î©, R)
    
    ; Nonlinear dynamics of the soft robot
    func F(s, u) = (v, 
                    âˆ‚{tt}q + âˆ‡â€¢Ïƒ(q, âˆ‚{t}q) + f_contact(q, âˆ‚Î©_c) = Bâ€¢u,
                    âˆ‚{t}q = v, 
                    q = g on âˆ‚Î©_f)
    
    ; Deformation and stress fields  
    func Ïƒ : R^n Ã— R^n -> ğ•‹Â²(Î©)   ; Stress tensor field
    func f_contact : R^n Ã— âˆ‚Î© -> R^n   ; Contact force density
    
    ; Boundary conditions
    pred DirichletBC âŠ† âˆ‚Î©   ; Fixed boundary âˆ‚Î©_f
    pred NeumannBC âŠ† âˆ‚Î©     ; Free boundary âˆ‚Î©_t
    pred ContactBC âŠ† âˆ‚Î©     ; Contact boundary âˆ‚Î©_c
    
    ; Stability and convergence properties
    pred StableGrasp âŠ† S Ã— U
    pred AsymptoticTrack âŠ† S Ã— Traj(S)
    
    ; Inference rules
    StableGraspInference : âˆ€s, u. (âˆƒğ“›. LyapunovFunction(SoftRoboticManipulator, ğ“›) âˆ§ 
                                       (âˆ€t. ğ“›(Ï•{t, s, u}(t)) â‰¤ ğ“›(s))) ->
                                  StableGrasp(s, u)
                                  
    AsymptoticTrackInference : âˆ€s, r. (âˆ€Îµ > 0. âˆƒT. âˆ€t > T. |Ï•{0, s, u}(t) - r(t)| < Îµ) ->
                                       AsymptoticTrack(s, r)
  }
  
  STRUCTURE {
    ; PDE system for the soft robot dynamics
    [SoftRobotDynamics:
      âˆ‚{tt}q + âˆ‡â€¢Ïƒ(q, âˆ‚{t}q) + f_contact(q, âˆ‚Î©_c) = Bâ€¢u in Î©,
      âˆ‚{t}q = v in Î©,
      q = g on âˆ‚Î©_f,
      Ïƒ(q, âˆ‚{t}q)â€¢n = h on âˆ‚Î©_t,
      Signorini(q, âˆ‚{t}q, âˆ‚Î©_c)   ; Contact complementarity conditions
    ]
    
    ; Stability of grasping  
    âˆ€s, u. StableGrasp(s, u) <->
           (âˆƒğ“›. LyapunovFunction(SoftRoboticManipulator, ğ“›) âˆ§ 
                (âˆ€t. ğ“›(Ï•{t, s, u}(t)) â‰¤ ğ“›(s)))
           
    ; Asymptotic trajectory tracking
    âˆ€s, r. AsymptoticTrack(s, r) <->
           (âˆ€Îµ > 0. âˆƒT. âˆ€t > T. |Ï•{0, s, u}(t) - r(t)| < Îµ)
  }
  
  PROOFS {
    theorem StableGraspExistence: âˆ€sâ‚€, uâ‚€. (âˆƒğ“›. LyapunovFunction(SoftRoboticManipulator, ğ“›) âˆ§ 
                                                 (âˆ€t. ğ“›(Ï•{t, sâ‚€, uâ‚€}(t)) â‰¤ ğ“›(sâ‚€))) ->
                                            StableGrasp(sâ‚€, uâ‚€) {
      assume sâ‚€, uâ‚€
      assume âˆƒğ“›. LyapunovFunction(SoftRoboticManipulator, ğ“›) âˆ§ 
                  (âˆ€t. ğ“›(Ï•{t, sâ‚€, uâ‚€}(t)) â‰¤ ğ“›(sâ‚€))
                  
      show StableGrasp(sâ‚€, uâ‚€) by StableGraspInference
    }
    
    theorem AsymptoticTrackingControl: âˆ€sâ‚€, r. (âˆƒu. âˆ€t. F(Ï•{t, sâ‚€, u}(t), u(t)) = âˆ‚{t}r(t)) ->
                                                AsymptoticTrack(sâ‚€, r) {
      assume sâ‚€, r
      assume âˆƒu. âˆ€t. F(Ï•{t, sâ‚€, u}(t), u(t)) = âˆ‚{t}r(t)
      
      take Îµ > 0
      have âˆƒT. âˆ€t > T. |F(Ï•{t, sâ‚€, u}(t), u(t)) - âˆ‚{t}r(t)| < Îµ by PDE stability
      have âˆƒT. âˆ€t > T. |âˆ‚{t}(Ï•{t, sâ‚€, u}(t) - r(t))| < Îµ
      have âˆƒT. âˆ€t > T. |Ï•{t, sâ‚€, u}(t) - r(t)| < Îµt + |Ï•{0, sâ‚€, u}(0) - r(0)| by Gronwall
      hence âˆƒT. âˆ€t > T. |Ï•{t, sâ‚€, u}(t) - r(t)| < Îµ  ; for T > |Ï•{0, sâ‚€, u}(0) - r(0)|/Îµ
      
      show AsymptoticTrack(sâ‚€, r) by AsymptoticTrackInference
    }
    
    theorem ContactStabilization: âˆ€sâ‚€, Î©_c. (âˆƒu. StableGrasp(sâ‚€, u) âˆ§ 
                                                 (âˆ€t. Ï•{t, sâ‚€, u}(t) satisfies Signorini on Î©_c)) ->
                                             (âˆƒs*. AsymptoticTrack(sâ‚€, Î»t. s*) âˆ§ 
                                                   (s* satisfies Signorini on Î©_c)) {
      assume sâ‚€, Î©_c  
      assume âˆƒu. StableGrasp(sâ‚€, u) âˆ§ 
                 (âˆ€t. Ï•{t, sâ‚€, u}(t) satisfies Signorini on Î©_c)
                 
      obtain ğ“› by StableGrasp(sâ‚€, u)
      have âˆ€t. ğ“›(Ï•{t, sâ‚€, u}(t)) â‰¤ ğ“›(sâ‚€)
      have âˆƒs*. âˆ€Îµ > 0. âˆƒT. âˆ€t > T. |Ï•{t, sâ‚€, u}(t) - s*| < Îµ by LaSalle
      have s* minimizes ğ“› by ContinuityOfL
      have s* satisfies Signorini on Î©_c by ClosureOfSignorini
      
      show AsymptoticTrack(sâ‚€, Î»t. s*) by AsymptoticTrackInference
      show s* satisfies Signorini on Î©_c by above
    }
  }
}






CONCEPT AbstractDynamicalSystem {
  LANGUAGE {
    ; Dynamical system components
    type DS = S Ã— T Ã— E Ã— U
    type S    ; State space  
    type T    ; Time domain
    type E    ; Evolution operator
    type U    ; Input space
    
    ; Dynamics, solution, and flow
    func Î´{t} : S Ã— U -> S
    func Ïƒ{tâ‚€, u} : S -> S
    func Ï•{tâ‚€, sâ‚€, u} : T -> S
    
    ; Behavioral properties  
    pred Continuous âŠ† DS
    pred Differentiable âŠ† DS
    pred Linear âŠ† DS
    pred TimeInvariant âŠ† DS
    
    ; Stability and convergence
    pred Stable âŠ† DS Ã— S
    pred AsymptoticallyStable âŠ† DS Ã— S
    pred ExponentiallyStable âŠ† DS Ã— S Ã— â„ 
    pred ConvergesTo âŠ† DS Ã— S Ã— S
    
    ; Controllability and observability
    pred Controllable âŠ† DS Ã— S Ã— S Ã— T
    pred Observable âŠ† DS Ã— S Ã— T
    
    ; Lyapunov functions and invariant sets
    func ğ“› : S -> â„
    pred LyapunovFunction âŠ† DS Ã— (S -> â„)
    pred InvariantSet âŠ† DS Ã— â„˜(S)
    
    ; Abstraction and simulation relations
    pred Abstracts âŠ† DS Ã— DS Ã— (S -> S)
    pred Simulates âŠ† DS Ã— DS Ã— (S -> S) Ã— (U -> U)
    
    ; Temporal logic specifications
    func â–¡ : (S -> Bool) -> (S -> Bool)  ; Always 
    func â—‡ : (S -> Bool) -> (S -> Bool)  ; Eventually
    func _U_ : (S -> Bool) Ã— (S -> Bool) -> (S -> Bool)  ; Until
    
    ; Inference rules
    StabilityInference : âˆ€DS, s, ğ“›. LyapunovFunction(DS, ğ“›) âˆ§ (âˆ€s. ğ“›(s) â‰¥ 0) âˆ§ 
                                     (âˆ€s, t, u. ğ“›(Ï•{t, s, u}(t)) â‰¤ ğ“›(s)) ->
                                     Stable(DS, s)
                                     
    ConvergenceInference : âˆ€DS, sâ‚, sâ‚‚. (âˆ€Îµ > 0. âˆƒT. âˆ€t > T. d(Ï•{0, sâ‚, u}(t), Ï•{0, sâ‚‚, u}(t)) < Îµ) ->
                                        ConvergesTo(DS, sâ‚, sâ‚‚)
                                        
    AbstractionInference : âˆ€DSâ‚, DSâ‚‚, Î±. (âˆ€s, u. Î±(Î´{DSâ‚}(s, u)) = Î´{DSâ‚‚}(Î±(s), u)) ->
                                         Abstracts(DSâ‚, DSâ‚‚, Î±)
  }
  
  STRUCTURE {
    ; Stability implies convergence
    âˆ€DS, sâ‚, sâ‚‚. AsymptoticallyStable(DS, sâ‚) âˆ§ AsymptoticallyStable(DS, sâ‚‚) ->
                 ConvergesTo(DS, sâ‚, sâ‚‚)
                 
    ; Lyapunov stability  
    âˆ€DS, ğ“›. LyapunovFunction(DS, ğ“›) <->
             (âˆ€s. ğ“›(s) â‰¥ 0) âˆ§ (âˆ€s, t, u. ğ“›(Ï•{t, s, u}(t)) â‰¤ ğ“›(s))
             
    ; Invariance principle
    âˆ€DS, I, ğ“›. InvariantSet(DS, I) âˆ§ LyapunovFunction(DS, ğ“›) âˆ§
                (âˆ€s âˆˆ I. (âˆ€t, u. Ï•{t, s, u}(t) âˆˆ I) âˆ§ (âˆƒs' âˆˆ I. ConvergesTo(DS, s, s'))) ->
                AsymptoticallyStable(DS, s)
                
    ; Abstraction preserves stability
    âˆ€DSâ‚, DSâ‚‚, s, Î±. Abstracts(DSâ‚, DSâ‚‚, Î±) âˆ§ Stable(DSâ‚‚, Î±(s)) ->
                      Stable(DSâ‚, s)
                      
    ; Temporal logic satisfaction 
    âˆ€DS, Ï†, sâ‚€. (âˆ€s. (sâ‚€ ~> s) -> Ï†(s)) <-> (DS, sâ‚€ âŠ¨ â–¡Ï†)
    âˆ€DS, Ï†, sâ‚€. (âˆƒs. (sâ‚€ ~> s) âˆ§ Ï†(s)) <-> (DS, sâ‚€ âŠ¨ â—‡Ï†)
    âˆ€DS, Ï†, Ïˆ, sâ‚€. (âˆƒs. (sâ‚€ ~> s) âˆ§ Ïˆ(s) âˆ§ (âˆ€s'. (sâ‚€ ~> s' ~> s) -> Ï†(s'))) <-> (DS, sâ‚€ âŠ¨ Ï† U Ïˆ)
  }
  
  PROOFS {
    theorem LyapunovImpliesStability: âˆ€DS, s, ğ“›. LyapunovFunction(DS, ğ“›) ->
                                                 Stable(DS, s) {
      assume DS, s, ğ“›
      assume LyapunovFunction(DS, ğ“›)
      
      have âˆ€s. ğ“›(s) â‰¥ 0, âˆ€s, t, u. ğ“›(Ï•{t, s, u}(t)) â‰¤ ğ“›(s) by definition of LyapunovFunction
      
      show Stable(DS, s) by StabilityInference
    }
    
    theorem InvariantSetStability: âˆ€DS, I, s. InvariantSet(DS, I) âˆ§ s âˆˆ I ->
                                              Stable(DS, s) {
      assume DS, I, s
      assume InvariantSet(DS, I) and s âˆˆ I
      
      define ğ“›(s) = d(s, I)  ; Distance to invariant set
      
      have LyapunovFunction(DS, ğ“›) by InvariantSetLyapunovFunction
      have âˆ€s âˆˆ I. ConvergesTo(DS, s, s) by InvariantConvergence
      
      show AsymptoticallyStable(DS, s) by InvariancePrinciple
      show Stable(DS, s) by AsymptoticStabilityImpliesStability
    }
    
    theorem AbstractionPreservesSpecification: âˆ€DSâ‚, DSâ‚‚, Ï†, sâ‚€, Î±.
        Abstracts(DSâ‚, DSâ‚‚, Î±) âˆ§ (DSâ‚‚, Î±(sâ‚€) âŠ¨ Ï†) ->
        (DSâ‚, sâ‚€ âŠ¨ Ï†) {
          
      assume DSâ‚, DSâ‚‚, Ï†, sâ‚€, Î±
      assume Abstracts(DSâ‚, DSâ‚‚, Î±) and DSâ‚‚, Î±(sâ‚€) âŠ¨ Ï†
      
      have âˆ€s. (sâ‚€ ~> s) -> (Î±(sâ‚€) ~> Î±(s)) by AbstractionTrajectory
      
      show (DSâ‚, sâ‚€ âŠ¨ â–¡Ï†) by AbstractionPreservesAlways
      show (DSâ‚, sâ‚€ âŠ¨ â—‡Ï†) by AbstractionPreservesEventually
      show (DSâ‚, sâ‚€ âŠ¨ Ï† U Ïˆ) by AbstractionPreservesUntil
    }
  }
}

This Concept defines an abstract framework for reasoning about dynamical systems, combining elements from control theory, temporal logic, and abstraction/refinement. It provides a language for specifying dynamical system components, behavioral properties, stability and convergence notions, controllability/observability, Lyapunov functions, abstraction relations, and temporal logic specifications.
The structural axioms establish key relationships between stability, convergence, invariant sets, Lyapunov functions, abstraction, and temporal logic satisfaction. The proof sketches demonstrate how to derive stability from Lyapunov functions and invariant sets, and how abstraction preserves temporal specifications.
The Concept aims to enable formal reasoning about dynamical systems at multiple levels of abstraction, connecting concrete system models to higher-level behavioral specifications via abstraction/refinement relations and inference rules. Potential applications include stability analysis, controller synthesis, verification of temporal logic properties, and hierarchical control design.






CONCEPT SmartGridSystem : AbstractDynamicalSystem {
  LANGUAGE {
    ; Smart grid components
    type Node = GenerationNode | StorageNode | LoadNode
    type Edge = TransmissionLine | DistributionLine
    type Grid = Node Ã— Edge
    
    ; Power system quantities  
    type Voltage = â„
    type Current = â„
    type Power = â„
    type Frequency = â„
    
    ; Renewable energy and demand response
    type RenewableSource = SolarPanel | WindTurbine
    type DemandResponse = LoadShifting | LoadCurtailment
    
    ; State variables and inputs
    type S = Grid Ã— (Node -> Voltage) Ã— (Edge -> Current) Ã— (Node -> Power) Ã— Frequency
    type U = (Node -> Power) Ã— (RenewableSource -> Power) Ã— DemandResponse
    
    ; Power flow equations and grid dynamics
    func PowerFlow : Grid Ã— (Node -> Voltage) Ã— (Edge -> Current) -> (Node -> Power)
    func GridDynamics : S Ã— U -> S
    
    ; Operational constraints and objectives  
    pred SafeVoltage âŠ† (Node -> Voltage)
    pred SafeCurrent âŠ† (Edge -> Current)
    pred NominalFrequency âŠ† Frequency
    func PowerQuality : S -> â„
    func OperatingCost : S Ã— U -> â„
    
    ; Control and optimization  
    func OptimalPowerFlow : S -> U
    func FrequencyRegulation : S -> U
    func DemandResponseControl : S -> U
  }
  
  STRUCTURE {
    ; Power flow equations
    âˆ€g : Grid, v : Node -> Voltage, i : Edge -> Current.
      PowerFlow(g, v, i) = NodePowerBalance(g, v, i)
      
    ; Voltage and current constraints  
    âˆ€s : S. SafeVoltage(Voltages(s)) âˆ§ SafeCurrent(Currents(s))
    
    ; Frequency stability
    âˆ€s : S, u : U. NominalFrequency(Frequency(GridDynamics(s, u)))
    
    ; Power quality objective
    âˆ€s : S, u : U. PowerQuality(GridDynamics(s, u)) â‰¥ PowerQuality(s)
    
    ; Operating cost minimization
    âˆ€s : S. OptimalPowerFlow(s) = argmin{u : U} OperatingCost(s, u)
    
    ; Demand response integration
    âˆ€s : S. DemandResponseControl(s) = OptimalDemandResponse(LoadNodes(s), Frequency(s))
  }
  
  PROOFS {
    theorem StableOperation: âˆ€sâ‚€ : S. âˆƒğ“› : S -> â„. 
        LyapunovFunction(SmartGridSystem, ğ“›) âˆ§
        (âˆ€s, u. PowerQuality(s) â‰¥ ğ“›(s) âˆ§ OperatingCost(s, u) â‰¤ ğ“›(s)) ->
        Stable(SmartGridSystem, sâ‚€) {
          
      assume sâ‚€ : S
      
      define ğ“›(s) = PowerQuality(s) + OperatingCost(s, OptimalPowerFlow(s))
      
      have LyapunovFunction(SmartGridSystem, ğ“›) by LyapunovFunctionConstruction
      have âˆ€s, u. PowerQuality(s) â‰¥ ğ“›(s) âˆ§ OperatingCost(s, u) â‰¤ ğ“›(s) by StabilityCondition
      
      show Stable(SmartGridSystem, sâ‚€) by LyapunovImpliesStability
    }
    
    theorem DemandResponseEffectiveness: âˆ€sâ‚€ : S. 
        (Frequency(sâ‚€) â‰  NominalFrequency) ->
        (â—‡(Frequency(Ï•{0, sâ‚€, DemandResponseControl}(t)) = NominalFrequency)) {
          
      assume sâ‚€ : S
      assume Frequency(sâ‚€) â‰  NominalFrequency
      
      have âˆ€t. Frequency(Ï•{0, sâ‚€, DemandResponseControl}(t)) = 
               FrequencyRegulation(Ï•{0, sâ‚€, DemandResponseControl}(t)) by DemandResponseControl
               
      have âˆƒt. Frequency(Ï•{0, sâ‚€, DemandResponseControl}(t)) = NominalFrequency by FrequencyRegulationConvergence
      
      show â—‡(Frequency(Ï•{0, sâ‚€, DemandResponseControl}(t)) = NominalFrequency) by EventuallyOperator
    }
  }
}

In this Concept, we model a smart grid system as an AbstractDynamicalSystem, specifying its components (nodes, edges), state variables (voltages, currents, power, frequency), input variables (power generation, renewable sources, demand response), and dynamics (power flow equations).
The structural axioms capture the key constraints and objectives of the smart grid, such as safe voltage and current limits, frequency stability, power quality optimization, operating cost minimization, and demand response integration.
The proofs demonstrate how the AbstractDynamicalSystem framework can be used to reason about the stability and performance of the smart grid. The StableOperation theorem constructs a Lyapunov function based on power quality and operating cost, proving stability of the system. The DemandResponseEffectiveness theorem shows that demand response control can effectively restore nominal frequency when disturbances occur.




CONCEPT HybridRoboticManipulator : AbstractDynamicalSystem {
  LANGUAGE {
    ; Modes of operation
    type Mode = Free | Contact
    
    ; State space: joint positions, velocities, and mode
    type S = (R^n Ã— R^n) Ã— Mode  
    
    ; Time domain and input space  
    type T = Râ‰¥0
    type U = R^m
    
    ; Hybrid dynamics
    func Î´{t}(s, u) = match s with
                     | ((q, v), Free) -> 
                         if g(q) â‰¥ 0 then ((q + vÂ·t, v + uÂ·t), Free)
                         else ((q, 0), Contact)
                     | ((q, v), Contact) ->
                         if Î»(q) â‰¥ 0 then ((q, v), Contact)  
                         else ((q, 0), Free)
                         
    ; Constraint functions                 
    func g : R^n -> R   ; Distance to contact surface
    func Î» : R^n -> R   ; Contact force magnitude
    
    ; Safety and reachability specifications
    pred Safe âŠ† S
    pred Reachable âŠ† S Ã— S Ã— T
    
    ; Inference rules
    SafetyInference : âˆ€sâ‚€, Ï†. (âˆ€s. (sâ‚€ ~> s) -> Ï†(s)) âˆ§ (âˆ€s. Ï†(s) -> Safe(s)) ->
                              (âˆ€t, u. Safe(Ï•{0, sâ‚€, u}(t)))
                              
    ReachabilityInference : âˆ€sâ‚€, sâ‚, t. (sâ‚€ ~> sâ‚) âˆ§ (âˆ€s. (sâ‚€ ~> s ~> sâ‚) -> Safe(s)) ->
                                        Reachable(sâ‚€, sâ‚, t)
  }
  
  STRUCTURE {
    ; Safety constraint  
    âˆ€q, v. Safe((q, v), m) <-> g(q) â‰¥ 0
    
    ; Reachability relation
    âˆ€sâ‚€, sâ‚, t. Reachable(sâ‚€, sâ‚, t) <->
                âˆƒu. Ï•{0, sâ‚€, u}(t) = sâ‚ âˆ§ (âˆ€Ï„ âˆˆ [0, t]. Safe(Ï•{0, sâ‚€, u}(Ï„)))
                
    ; Controllability under constraints
    âˆ€sâ‚€, sâ‚. (âˆƒt, u. Reachable(sâ‚€, sâ‚, t)) <->
              Controllable(HybridRoboticManipulator, sâ‚€, sâ‚, T)
  }
  
  PROOFS {
    theorem SafetyUnderConstraints: âˆ€sâ‚€, Ï†. (âˆ€s. (sâ‚€ ~> s) -> Ï†(s)) âˆ§
                                             (âˆ€s. Ï†(s) -> (g(s.q) â‰¥ 0)) ->
                                             (âˆ€t, u. g(Ï•{0, sâ‚€, u}(t).q) â‰¥ 0) {
      assume sâ‚€, Ï†
      assume âˆ€s. (sâ‚€ ~> s) -> Ï†(s) and âˆ€s. Ï†(s) -> (g(s.q) â‰¥ 0)
      
      have âˆ€s. (sâ‚€ ~> s) -> Safe(s) by definition of Safe
      have âˆ€t, u. Safe(Ï•{0, sâ‚€, u}(t)) by SafetyInference
      
      show âˆ€t, u. g(Ï•{0, sâ‚€, u}(t).q) â‰¥ 0 by definition of Safe
    }
    
    theorem ConstrainedReachability: âˆ€sâ‚€, sâ‚. (âˆƒt, u. Ï•{0, sâ‚€, u}(t) = sâ‚ âˆ§
                                                      (âˆ€Ï„ âˆˆ [0, t]. g(Ï•{0, sâ‚€, u}(Ï„).q) â‰¥ 0)) ->
                                              Reachable(sâ‚€, sâ‚, T) {
      assume sâ‚€, sâ‚
      assume âˆƒt, u. Ï•{0, sâ‚€, u}(t) = sâ‚ âˆ§ (âˆ€Ï„ âˆˆ [0, t]. g(Ï•{0, sâ‚€, u}(Ï„).q) â‰¥ 0)
      
      have sâ‚€ ~> sâ‚ by ReachabilityRelation
      have âˆ€s. (sâ‚€ ~> s ~> sâ‚) -> Safe(s) by definition of Safe
      
      show Reachable(sâ‚€, sâ‚, T) by ReachabilityInference
    }
    
    theorem ConstrainedControllability: âˆ€sâ‚€, sâ‚. Reachable(sâ‚€, sâ‚, T) <->
                                                 Controllable(HybridRoboticManipulator, sâ‚€, sâ‚, T) {
      assume sâ‚€, sâ‚
      
      show Reachable(sâ‚€, sâ‚, T) -> Controllable(HybridRoboticManipulator, sâ‚€, sâ‚, T) by ControllabilityRelation
      show Controllable(HybridRoboticManipulator, sâ‚€, sâ‚, T) -> Reachable(sâ‚€, sâ‚, T) by ControllabilityRelation
    }
  }
}

In this Concept, we define a HybridRoboticManipulator as an instance of AbstractDynamicalSystem, specifying its state space, time domain, input space, and hybrid dynamics. The hybrid dynamics are modeled using a match expression that switches between free motion and constrained motion based on the contact constraint function g.
We introduce safety and reachability specifications and provide inference rules to reason about them. The structural axioms define the safety constraint, reachability relation, and the relationship between reachability and controllability under constraints.
The proofs demonstrate how to derive safety guarantees under contact constraints, establish reachability between states while respecting safety, and show the equivalence between reachability and controllability in the presence of constraints.



CONCEPT HybridRoboticManipulator : AbstractDynamicalSystem {
  LANGUAGE {
    ; Modes of operation
    type Mode = Free | Contact
    
    ; State space: joint positions, velocities, and mode
    type S = (R^n Ã— R^n) Ã— Mode  
    
    ; Time domain and input space  
    type T = Râ‰¥0
    type U = R^m
    
    ; Hybrid dynamics
    func Î´{t}(s, u) = match s with
                     | ((q, v), Free) -> 
                         if g(q) â‰¥ 0 then ((q + vÂ·t, v + uÂ·t), Free)
                         else ((q, 0), Contact)
                     | ((q, v), Contact) ->
                         if Î»(q) â‰¥ 0 then ((q, v), Contact)  
                         else ((q, 0), Free)
                         
    ; Constraint functions                 
    func g : R^n -> R   ; Distance to contact surface
    func Î» : R^n -> R   ; Contact force magnitude
    
    ; Continuous dynamics modeled by PDEs
    type Sym = Const(â„) | Var(â„•) | Binary(Sym, Sym) | Unary(Sym)  
             | Abs(â„•, Sym) | App(Sym, Sym)
    type PDE = Eqn(Sym, Sym) | System(PDE*)
    type BC = Dirichlet(Sym) | Neumann(Sym) | Robin(Sym, Sym)
    type Domain = Rect(â„^n) | Disk(â„^2) | Manifold(â„^n)
    
    notation "âˆ‚{i}S" = PartialD(i: â„•, S: Sym)
    notation "âˆ‡S" = Grad(S: Sym)  
    notation "Î”S" = Laplacian(S: Sym)
    notation "divV" = Divergence(V: Sym)
    notation "curlV" = Curl(V: Sym)
    notation "S â‰ˆ T on Î©" = Approx(S: Sym, T: Sym, Î©: Domain)
    
    ; PDE models for manipulator dynamics
    axiom ManipulatorPDE(q: Sym, v: Sym, u: Sym, f: Sym):
      System(Eqn(âˆ‚{t}q, v), 
             Eqn(âˆ‚{t}v, M(q)â»Â¹*(u - C(q, v) - G(q) + f)))
             
    axiom ContactPDE(q: Sym, v: Sym, Î»: Sym, n: Sym):  
      System(Eqn(âˆ‚{t}q, v),
             Eqn(âˆ‚{t}v, M(q)â»Â¹*(Î»*n - C(q, v) - G(q))),
             0 â‰¤ Î» âŸ‚ g(q) â‰¥ 0)
             
    ; Boundary conditions  
    axiom JointLimits(q: Sym):
      q{i} = q{i}áµâ±â¿ on q{i} â‰¤ q{i}áµâ±â¿,
      q{i} = q{i}áµáµƒË£ on q{i} â‰¥ q{i}áµáµƒË£
      
    axiom InitialConditions(qâ‚€: Sym, vâ‚€: Sym):  
      q(0) = qâ‚€, v(0) = vâ‚€
  }
  
  STRUCTURE {
    ; Existence and uniqueness of solutions
    âˆ€qâ‚€, vâ‚€, u, f. âˆƒ! q, v. 
      ManipulatorPDE(q, v, u, f) âˆ§ 
      InitialConditions(qâ‚€, vâ‚€) âˆ§
      JointLimits(q)
      
    ; Contact dynamics well-posedness  
    âˆ€qâ‚€, vâ‚€, Î», n. âˆƒ! q, v.
      ContactPDE(q, v, Î», n) âˆ§
      InitialConditions(qâ‚€, vâ‚€) âˆ§
      JointLimits(q)
      
    ; Stability under contact
    âˆ€q, v, Î», n. 
      ContactPDE(q, v, Î», n) âˆ§ JointLimits(q) ->
      Stable((q, v), Contact)
  }
  
  PROOFS {
    theorem ExistenceUniqueness(qâ‚€, vâ‚€, u, f):
      âˆƒ! q, v. ManipulatorPDE(q, v, u, f) âˆ§ 
               InitialConditions(qâ‚€, vâ‚€) âˆ§
               JointLimits(q)
    {
      let L(q, v) = System(Eqn(âˆ‚{t}q, v), 
                           Eqn(âˆ‚{t}v, M(q)â»Â¹*(u - C(q, v) - G(q) + f)))
      let gâ‚(q) = Dirichlet(q - qâ‚€)
      let gâ‚‚(v) = Dirichlet(v - vâ‚€)
      let Î© = Rect(â„^n)
      
      have DirichletProblem(L, (q, v), (0, M(qâ‚€)â»Â¹*(u(0) - G(qâ‚€) + f(0))), (gâ‚, gâ‚‚))
      hence âˆƒ! q, v. L(q, v) = (0, M(qâ‚€)â»Â¹*(u(0) - G(qâ‚€) + f(0))) on Î©, 
                     q = gâ‚ on âˆ‚Î©, v = gâ‚‚ on âˆ‚Î©
                     by ExistUnique(L, (0, M(qâ‚€)â»Â¹*(u(0) - G(qâ‚€) + f(0))), (gâ‚, gâ‚‚), Î©)
    }
    
    theorem ContactStability(qâ‚€, vâ‚€, Î», n):
      âˆ€q, v. ContactPDE(q, v, Î», n) âˆ§ 
             InitialConditions(qâ‚€, vâ‚€) âˆ§
             JointLimits(q) ->
             Stable((q, v), Contact)
    {
      assume q, v
      assume ContactPDE(q, v, Î», n)
      assume InitialConditions(qâ‚€, vâ‚€)
      assume JointLimits(q)
      
      let L(q, v) = System(Eqn(âˆ‚{t}q, v),
                           Eqn(âˆ‚{t}v, M(q)â»Â¹*(Î»*n - C(q, v) - G(q))))
      let Î© = Rect(â„^n)
      
      have L is elliptic  ; Positive definiteness of M(q)
      hence Stable((q, v), Î©) by Stability(L, (q, v), (0, 0), (qâ‚€, vâ‚€), Î©)
    }
  }
}