METALANGUAGE MaterialsScience {
  EXTENDS SymbolicDifferentialGeometry {
    type Material
    type Structure
    type Properties
    type Processes
    type Elements
    type Bonds
    type Atom
    type Molecule 
    type Defect
    type Scale
    type Phase
    type Microstructure
    type Lattice
    type Dislocation
    type Grain
    type GrainBoundary
    type Interface
    type ElasticityTensor
    type PlasticityTensor  
    type FractureToughness
    type Hardness
    type Conductivity
    type Permeability
    type Permittivity
    type FreeEnergy
    type Entropy
    type ChemicalPotential
    type ReactionRate
    
    func Tuple(Structure, Properties, Processes): Material
    func Graph(Elements, Bonds): Structure
    func Mechanical(Material): ElasticityTensor
    func Thermal(Material): Function(â„)
    func Electromagnetic(Material): VectorField
    func Flow(Properties): Processes
    func Composite(Material, Material): Material
    func Polycrystal(Grain): Material
    func SingleCrystal(Lattice): Material
    func Isotropic(Properties): Properties
    func Anisotropic(Properties): Properties
    func Homogeneous(Properties): Properties
    func Heterogeneous(Properties): Properties
    func +(Properties, Properties): Properties
    func *(â„, Properties): Properties
    func âŠ—(Properties, Properties): Properties
    func âˆ˜(Processes, Processes): Processes
    func âŠ•(Processes, Processes): Processes
    func âŠ–(Processes, Processes): Processes
    func Deformation(Material): Material
    func Fracture(Material): Material  
    func PhaseTransformation(Material): Material
    func Recrystallization(Material): Material
    func Sintering(Material): Material
    
    pred Ionic(Bonds)
    pred Covalent(Bonds)
    pred Metallic(Bonds) 
    pred vanDerWaals(Bonds)
    pred HydrogenBond(Bonds)
    
    rel Coupling(StructureFlow, PropertyFlow, ProcessFlow)
    rel Equilibrium(Material)
    rel Diffusion(Elements, Material)
    rel Nucleation(Phase, Material)
    rel Growth(Phase, Material)
    
    const YoungModulus(Material): â„ 
    const ShearModulus(Material): â„
    const BulkModulus(Material): â„
    const PoissonRatio(Material): â„
    const YieldStrength(Material): â„
    const UltimateTensileStrength(Material): â„
    
    notation "ğ“œ" = Material
    notation "ğ“¢" = Structure
    notation "ğ“Ÿ" = Properties
    notation "ğ“•" = Processes  
    notation "ğ“”" = Elements
    notation "ğ“‘" = Bonds
    notation "Îµ" = Scale
    
    infer Equivariance(â„±, g):
      â„±(g â‹… ğ“¢, ğ“Ÿ) = g â‹… â„±(ğ“¢, ğ“Ÿ) âŠ¢ 
        âˆ€ ğ“¢, ğ“Ÿ. â„±(ğ“¢, ğ“Ÿ) â‰ˆ â„±(g â‹… ğ“¢, ğ“Ÿ)
        
    rewrite Leibniz(ğ“¢, ğ“Ÿ):
      d[ğ“¢ âŠ— ğ“Ÿ] ~> d[ğ“¢] âŠ— ğ“Ÿ + ğ“¢ âŠ— d[ğ“Ÿ]
      
    axiom Linearity(p, q: Properties, a, b: â„):  
      (a * p) + (b * q) = (a + b) * (p + q)
      
    axiom Monotonicity(p, q: Properties):
      p â‰¤ q â‡’ âˆ€ r: Properties. p + r â‰¤ q + r
      
    infer Associativity(p, q, r: Properties):
      (p + q) + r = p + (q + r)
      
    infer Distributivity(p, q, r: Properties):
      p âŠ— (q + r) = (p âŠ— q) + (p âŠ— r)  
  }
}

THEORY MultiscaleMaterialEvolution : MaterialsScience {

  structure HeterogeneousMaterial {
    matrix: Material
    inclusions: Material
    interfaces: Interface
    
    couple: Coupling(
      StructureFlow(matrix), 
      PropertyFlow(inclusions),
      ProcessFlow(interfaces)
    )
  }
  
  theorem MultiscaleStructureEvolution(ğ“œ: HeterogeneousMaterial, t: Time)
  {
    let ğ“¢_matrix = ğ“œ.matrix.Structure
    let ğ“¢_inclusions = ğ“œ.inclusions.Structure
    
    assert âˆ‚[ğ“¢_matrix, t] = Deformation(ğ“¢_matrix) + Recrystallization(ğ“¢_matrix)
    assert âˆ‚[ğ“¢_inclusions, t] = Fracture(ğ“¢_inclusions) + PhaseTransformation(ğ“¢_inclusions)
    
    assert Nucleation(NewPhase, ğ“œ.interfaces) â‡’ Growth(NewPhase, ğ“œ.matrix)
  }
  
  theorem MultiscalePropertyEvolution(ğ“œ: HeterogeneousMaterial, t: Time)
  {
    let ğ“Ÿ_matrix = ğ“œ.matrix.Properties
    let ğ“Ÿ_inclusions = ğ“œ.inclusions.Properties
    
    assert âˆ‚[Mechanical(ğ“Ÿ_matrix), t] = Elastic(âˆ‚[ğ“¢_matrix, t]) + Plastic(âˆ‚[ğ“¢_matrix, t])
    assert âˆ‚[Thermal(ğ“Ÿ_inclusions), t] = Conduction(âˆ‡[Temperature(ğ“œ)], ğ“Ÿ_inclusions)
    
    assert Diffusion(Species, ğ“œ.interfaces) â‡’ âˆ‡[ChemicalPotential(Species), ğ“œ.interfaces] â‰  0
  }
  
  theorem MultiscaleProcessCoupling(ğ“œ: HeterogeneousMaterial, t: Time)
  {
    let ğ“•_matrix = Processes(ğ“œ.matrix)
    let ğ“•_inclusions = Processes(ğ“œ.inclusions) 
    let ğ“•_interfaces = Processes(ğ“œ.interfaces)
    
    assert ğ“•_matrix â‰ˆ â¨_i ğ“•_matrix_i(Îµ)
    assert ğ“•_inclusions â‰ˆ â¨_j ğ“•_inclusions_j(Îµ) 
    assert ğ“•_interfaces â‰ˆ â¨_k ğ“•_interfaces_k(Îµ)
    
    assert âˆƒ Îµ, i, j, k. Coupling(ğ“•_matrix_i(Îµ), ğ“•_inclusions_j(Îµ), ğ“•_interfaces_k(Îµ)) â‰  0
  }
  
  proof MultiscaleStructurePropertyCoupling(ğ“œ: HeterogeneousMaterial, t: Time):
    âˆ€ Îµ, i, j. d[ğ“¢_matrix_i(Îµ) âŠ— ğ“Ÿ_inclusions_j(Îµ)] â‰ˆ 0 
    âŠ¢ âˆƒ k. Coupling(ğ“•_matrix_i(Îµ), ğ“•_inclusions_j(Îµ), ğ“•_interfaces_k(Îµ)) â‰  0
  {
    assume âˆ€ Îµ, i, j. d[ğ“¢_matrix_i(Îµ) âŠ— ğ“Ÿ_inclusions_j(Îµ)] â‰ˆ 0
    
    have âŸ¨d[ğ“¢_matrix_i(Îµ)], ğ“Ÿ_inclusions_j(Îµ)âŸ© + âŸ¨ğ“¢_matrix_i(Îµ), d[ğ“Ÿ_inclusions_j(Îµ)]âŸ© â‰ˆ 0
      by StructurePropertyDuality(ğ“œ.matrix âŠ• ğ“œ.inclusions)
      
    let ğ“•_matrix_i = Processes(ğ“¢_matrix_i(Îµ))  
    let ğ“•_inclusions_j = Processes(ğ“Ÿ_inclusions_j(Îµ))
    
    have ğ“•_matrix_i(ğ“¢_matrix_i(Îµ), ğ“Ÿ_inclusions_j(Îµ)) 
         â‰ˆ ğ“•_matrix_i(ğ“¢_matrix_i(Îµ) + d[ğ“¢_matrix_i(Îµ)], ğ“Ÿ_inclusions_j(Îµ) - âŸ¨d[ğ“¢_matrix_i(Îµ)], d[ğ“Ÿ_inclusions_j(Îµ)]âŸ©)
      by StructurePropertyCorrespondence(ğ“œ.matrix âŠ• ğ“œ.inclusions, ğ“•_matrix_i)
      
    let Î”ğ“¢_matrix_i = d[ğ“¢_matrix_i(Îµ)]
    let Î”ğ“Ÿ_inclusions_j = -âŸ¨d[ğ“¢_matrix_i(Îµ)], d[ğ“Ÿ_inclusions_j(Îµ)]âŸ©
    
    have Î”ğ“¢_matrix_i â‰ˆ â¨_k Î”ğ“¢_interfaces_k(Îµ) 
      by ğ“œ.couple
    have Î”ğ“Ÿ_inclusions_j â‰ˆ â¨_k Î”ğ“Ÿ_interfaces_k(Îµ)
      by ğ“œ.couple
      
    so âˆƒ k. Coupling(ğ“•_matrix_i(Îµ), ğ“•_inclusions_j(Îµ), ğ“•_interfaces_k(Îµ)) â‰  0  
  }
}





METALANGUAGE MaterialsScience {
  EXTENDS SymbolicDifferentialGeometry {
    type Material
    type Structure
    type Properties
    type Processes
    type Elements
    type Bonds
    type Atom
    type Molecule 
    type Defect
    type Scale
    
    func Tuple(Structure, Properties, Processes): Material
    func Graph(Elements, Bonds): Structure
    func Mechanical(Material): (1,1)-Tensor
    func Thermal(Material): Function(â„)  
    func Electromagnetic(Material): VectorField
    func Flow(Properties): Processes
    
    pred Ionic(Bonds)
    pred Covalent(Bonds) 
    pred Metallic(Bonds)
    pred vanDerWaals(Bonds)
    pred HydrogenBond(Bonds)
    
    rel Coupling(StructureFlow, PropertyFlow, ProcessFlow)
    
    notation "ğ“œ" = Material
    notation "ğ“¢" = Structure 
    notation "ğ“Ÿ" = Properties
    notation "ğ“•" = Processes
    notation "ğ“”" = Elements
    notation "ğ“‘" = Bonds
    notation "Îµ" = Scale
    
    infer Equivariance(â„±, g):
      â„±(g â‹… ğ“¢, ğ“Ÿ) = g â‹… â„±(ğ“¢, ğ“Ÿ) âŠ¢ 
        âˆ€ ğ“¢, ğ“Ÿ. â„±(ğ“¢, ğ“Ÿ) â‰ˆ â„±(g â‹… ğ“¢, ğ“Ÿ)
        
    rewrite Leibniz(ğ“¢, ğ“Ÿ):  
      d[ğ“¢ âŠ— ğ“Ÿ] ~> d[ğ“¢] âŠ— ğ“Ÿ + ğ“¢ âŠ— d[ğ“Ÿ]
  }
}



THEORY MultiscaleMaterialBehavior : MaterialsScience {

  structure MultiscaleMaterial {
    macro: Material
    meso: Material
    micro: Material
    
    couple: Coupling(StructureFlow(macro), PropertyFlow(meso), ProcessFlow(micro))
  }
  
  theorem MultiscaleDecomposition(ğ“œ: Material, Îµ: Scale)
  {
    let ğ“¢ = ğ“œ.Structure
    let ğ“Ÿ = ğ“œ.Properties
    
    assert ğ“¢ = ğ“¢_macro(Îµ) âŠ• ğ“¢_meso(Îµ) âŠ• ğ“¢_micro(Îµ)
    assert ğ“Ÿ = ğ“Ÿ_macro(Îµ) âŠ• ğ“Ÿ_meso(Îµ) âŠ• ğ“Ÿ_micro(Îµ)
    
    let â„± = Processes(ğ“œ)
    
    assert â„±(ğ“¢, ğ“Ÿ) â‰ˆ â¨_i â„±(ğ“¢_i(Îµ), ğ“Ÿ_i(Îµ))
  }
  
  proof MultiscaleEquivariance: 
    âˆ€ g: StructureFlow(ğ“œ.macro), â„±: Processes(ğ“œ).
      Equivariance(â„±, g) âŠ¢ 
        â„±(ğ“¢, ğ“Ÿ) â‰ˆ â¨_i â„±(ğ“¢_i(Îµ), ğ“Ÿ_i(Îµ))
  {
    assume g: StructureFlow(ğ“œ.macro), â„±: Processes(ğ“œ)
    assume Equivariance(â„±, g)
    
    let ğ“¢_i = ğ“œ.Structure_i(Îµ)
    let ğ“Ÿ_i = ğ“œ.Properties_i(Îµ) 
    have â„±(ğ“¢_i, ğ“Ÿ_i) â‰ˆ â„±(g â‹… ğ“¢_i, ğ“Ÿ_i) by Equivariance(â„±, g)
    
    let â„±_i = â„±(ğ“¢_i, ğ“Ÿ_i)
    suffices to show â„±(ğ“¢, ğ“Ÿ) â‰ˆ â¨_i â„±_i
    {
      have â„±(â¨_i ğ“¢_i, â¨_i ğ“Ÿ_i) = â¨_i â¨_j â„±(ğ“¢_i, ğ“Ÿ_j) by linearity of â„±
      have â„±(ğ“¢_i, ğ“Ÿ_j) â‰ˆ 0 for i â‰  j by ğ“œ.couple
      hence â„±(ğ“¢, ğ“Ÿ) â‰ˆ â¨_i â„±(ğ“¢_i, ğ“Ÿ_i) = â¨_i â„±_i
    }
  }
  
  theorem StructurePropertyDuality(ğ“œ: Material)
  {
    let ğ“¢ = ğ“œ.Structure
    let ğ“Ÿ = ğ“œ.Properties
    
    assert d[ğ“¢ âŠ— ğ“Ÿ] â‰ˆ 0 âŸº âŸ¨d[ğ“¢], ğ“ŸâŸ© + âŸ¨ğ“¢, d[ğ“Ÿ]âŸ© â‰ˆ 0
  }
  
  proof StructurePropertyCorrespondence(ğ“œ: Material, â„±: Processes):
    âˆ€ ğ“¢: ğ“œ.Structure, ğ“Ÿ: ğ“œ.Properties. 
      d[ğ“¢ âŠ— ğ“Ÿ] â‰ˆ 0 âŠ¢ â„±(ğ“¢, ğ“Ÿ) â‰ˆ â„±(ğ“¢ + d[ğ“¢], ğ“Ÿ - âŸ¨d[ğ“¢], d[ğ“Ÿ]âŸ©)
  {
    assume ğ“¢: ğ“œ.Structure, ğ“Ÿ: ğ“œ.Properties
    assume d[ğ“¢ âŠ— ğ“Ÿ] â‰ˆ 0
    
    have d[ğ“¢ âŠ— ğ“Ÿ] ~> d[ğ“¢] âŠ— ğ“Ÿ + ğ“¢ âŠ— d[ğ“Ÿ] by Leibniz(ğ“¢, ğ“Ÿ)
    so d[ğ“¢] âŠ— ğ“Ÿ + ğ“¢ âŠ— d[ğ“Ÿ] â‰ˆ 0
    iff âŸ¨d[ğ“¢], ğ“ŸâŸ© + âŸ¨ğ“¢, d[ğ“Ÿ]âŸ© â‰ˆ 0  by tensor-inner product duality
    iff âŸ¨d[ğ“¢], ğ“ŸâŸ© â‰ˆ âŸ¨d[ğ“¢], -d[ğ“Ÿ]âŸ©
    so ğ“Ÿ â‰ˆ -d[ğ“Ÿ] at d[ğ“¢]
    
    have â„±(ğ“¢, ğ“Ÿ) â‰ˆ â„±(ğ“¢, ğ“Ÿ - âŸ¨d[ğ“¢], d[ğ“Ÿ]âŸ©) by substitution
    have â„±(ğ“¢, ğ“Ÿ - âŸ¨d[ğ“¢], d[ğ“Ÿ]âŸ©) â‰ˆ â„±(ğ“¢ + d[ğ“¢], ğ“Ÿ - âŸ¨d[ğ“¢], d[ğ“Ÿ]âŸ©) by â„± is a flow
    hence â„±(ğ“¢, ğ“Ÿ) â‰ˆ â„±(ğ“¢ + d[ğ“¢], ğ“Ÿ - âŸ¨d[ğ“¢], d[ğ“Ÿ]âŸ©)
  }
}