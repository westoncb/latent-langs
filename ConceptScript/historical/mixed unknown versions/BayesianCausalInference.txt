CONCEPT BayesianCausalInference {
  LANGUAGE {
    type Variable = Symbol
    type Value = Symbol | Number
    type Dataset = List<Map<Variable, Value>>
    type BayesNet = (Set<Variable>, Map<Variable, Set<Variable>>, Map<Variable, CPT>) 
    type CPT = Map<Map<Variable, Value>, Probability>
    type Intervention = Map<Variable, Value>
    type Query = (Variable, Map<Variable, Value>)

    func Parents : BayesNet Ã— Variable -> Set<Variable>
    func Probability : BayesNet Ã— Map<Variable, Value> -> Real
    func Intervene : BayesNet Ã— Intervention -> BayesNet
    func Marginal : BayesNet Ã— Query -> Probability
    func LearnStructure : Dataset -> BayesNet
    func LearnParameters : Dataset Ã— BayesNet -> BayesNet  
  }
    
  STRUCTURE {
    ; Bayesian network axioms
    âˆ€(B: BayesNet) (x: Map<Variable, Value>).
      Probability(B, x) = âˆ_{v âˆˆ B.Variables} B.CPT[v][x|_{Parents(B, v)}]

    âˆ€(B: BayesNet) (i: Intervention).
      Intervene(B, i) = (B.Variables, B.Parents, B.CPT|_{B.Variables - i.Keys})

    âˆ€(B: BayesNet) ((v, e): Query).  
      Marginal(B, (v, e)) = âˆ‘_{x|_{B.Variables - {v} - e.Keys}} Probability(B, x âˆª e âˆª {(v, *)})

    ; Causal inference axioms  
    âˆ€(B: BayesNet) (i: Intervention) ((v, e): Query).
      Marginal(Intervene(B, i), (v, e)) = P(v | do(i), e)

    âˆ€(B: BayesNet) (i: Intervention) (x: Map<Variable, Value>).  
      Probability(Intervene(B, i), x) = (âˆ_{v âˆˆ B.Variables - i.Keys} B.CPT[v][x|_{Parents(B, v)}]) Ã— âˆ_{v âˆˆ i.Keys} ğŸ™{x[v] = i[v]}
  }
   
  PROOFS {
    theorem CausalEffect<B, i, v> {
      assume B: BayesNet, i: Intervention, Marginal(B, (v, âˆ…))
      
      let B' = Intervene(B, i)
      
      ; Law of total probability  
      Marginal(B, (v, âˆ…)) 
        = âˆ‘_{x|_{B.Variables - {v}}} Probability(B, x âˆª {(v, *)})

      ; Intervention axiom
      Marginal(B', (v, âˆ…))  
        = âˆ‘_{x|_{B'.Variables - {v}}} Probability(B', x âˆª {(v, *)})
        = P(v | do(i))

      ; Difference in marginals  
      Marginal(B', (v, âˆ…)) - Marginal(B, (v, âˆ…))
        = P(v | do(i)) - P(v)
        = CausalEffect(i, v) 
        
      hence CausalEffect(i, v) = Marginal(Intervene(B, i), (v, âˆ…)) - Marginal(B, (v, âˆ…))
    }
    
    theorem Identifiability<B, D> {
      assume âˆ€B, B'. (Marginal(B, *) = Marginal(B', *)) => (B = B')
      
      let B = LearnStructure(D)  
      let B' = LearnParameters(D, B)
      
      Marginal(B', *) = Marginal(B, *) = Pr(D)
      
      hence Pr(D) identifies a unique B'
    }
  }
}

This Concept demonstrates several powerful features of ConceptScript:

The use of complex data types, such as maps, sets, and tuples, to define Bayesian networks, probability distributions, interventions, and queries in a structured and modular way.
The use of mathematical functions and operators, such as products, sums, and indicators, to express probabilistic and causal relationships concisely.
The formalization of key axioms of Bayesian networks and causal inference, such as factorization, intervention, and marginalization, using equational and logical reasoning.
The use of structured proofs to derive important results, such as the identification of causal effects and the uniqueness of learned Bayesian networks, using the defined concepts and axioms.
The integration of learning algorithms, such as structure and parameter learning, as primitive functions within the language, allowing for a seamless connection between data and models.