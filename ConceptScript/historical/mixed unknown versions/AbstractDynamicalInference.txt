CONCEPT AbstractDynamicalInference {
  LANGUAGE {
    type Sys<S>
    type State<S>
    type Dynamics<S>
    
    type Endo<S>
    type Obs<S>
    
    type Prop<S>
    
    func Measure<S>(s: State<S>): ℝ
    func Update<S>(f: Endo<State<S>>, s: State<S>): State<S>  
    func Generator<S>(s: Sys<S>): Endo<State<S>>
    func Invariant<S>(f: Endo<S>): S

    pred Consistent<S>(Γ: Set<Prop<S>>)
    pred Valid<S>(s: State<S>, φ: Prop<S>)
    pred Entails<S>(Γ: Set<Prop<S>>, φ: Prop<S>)
    
    notation "G(s)" = Generator(s)
    notation "s ⊧ φ" = Valid(s, φ)
    notation "Γ ⊧ φ" = Entails(Γ, φ)
    notation "s ⇒ t" = Dynamics(s) = t  
    notation "s ⇛ σ" = σ = Invariant(Update(G(s), -))
    
    infer Invariance<S>(s: Sys<S>, t: Sys<S>, T: Endo<State<S>>):
      s ≈ t ↔ ∃σ. G(s) = T⁻¹ ∘ G(t) ∘ T ∧ (σ ⊧ s) = (σ ⊧ t)
      
    infer MaxMeasureInvariant<S>(s: Sys<S>, σ: State<S>):
      (s ⇛ σ) ↔ σ = argmax_τ {Measure(τ) | (τ ⊧ s) = (τ ⊧ σ)} 
      
    infer ProofToDynamics<S>(Γ: Set<Prop<S>>, φ: Prop<S>, s: State<S>):
      (Consistent(Γ ∪ {φ}) ∧ ∀ψ ∈ Γ. (s ⊧ ψ)) -> (s ⊧ φ) = (s ⊧ Update(G(s), s))
  }

  STRUCTURE {
    ; Fundamental Measurement Theorem  
    ∀S, (s: Sys<S>, σ: State<S>). dMeasure(s) = dValid(s, σ) + dValid(σ, Encoded(s))
    
    ; Univalence of Equivalence
    (s ≈ t) ∧ (t ≈ r) -> (s ≈ r) 
  }
  
  PROOFS {
    theorem MaxMeasureIsInvariant<S>:
      ∀(s: Sys<S>). 
        (∃σ. s ⇛ σ) -> σ = MaxMeasure(G(s))
    {
      assume ∃σ. s ⇛ σ  
      let σ such that s ⇛ σ
      
      s ⇛ σ
      ↔ σ = argmax_τ {Measure(τ) | (τ ⊧ s) = (τ ⊧ σ)}   ; by MaxMeasureInvariant
      ↔ σ = MaxMeasure(G(s))   ; by definition
    }
    
    theorem DynamicalEquilibrium<S>:
      ∀(s: Sys<S>). 
        s ⇒ s <-> ∃σ: State<S>. s ⇛ σ ∧ σ = MaxMeasure(G(s))  
    {
      ; Proof sketch:
      ; (->)  
      ;   Assume s ⇒ s
      ;   Let σ = MaxMeasure(G(s))
      ;   Show σ ⊧ G(s) = Valid(σ, G(s))  
      ;   Conclude s ⇛ σ ∧ σ = MaxMeasure(G(s))
      ; (<-)
      ;   Assume ∃σ. s ⇛ σ ∧ σ = MaxMeasure(G(s))
      ;   Show σ ⊧ G(s) = Valid(σ, G(s))
      ;   Show σ = Invariant(Update(G(s), σ))
      ;   Conclude s ⇒ s
    }

    theorem ProofDrivenDynamics<S>:
      ∀(s: Sys<S>, Γ: Set<Prop<S>>, φ: Prop<S>).
        (∃σ. s ⇛ σ ∧ ∀ψ ∈ Γ. (σ ⊧ ψ) ∧ Consistent(Γ ∪ {φ})) -> Dynamics(s) ⊧ φ
    {
      ; Proof sketch: 
      ;   Assume ∃σ. s ⇛ σ ∧ ∀ψ ∈ Γ. (σ ⊧ ψ) ∧ Consistent(Γ ∪ {φ})
      ;   Let σ such that s ⇛ σ ∧ ∀ψ ∈ Γ. (σ ⊧ ψ) ∧ Consistent(Γ ∪ {φ})
      ;   From ProofToDynamics: Consistent(Γ ∪ {φ}) ∧ ∀ψ ∈ Γ. (σ ⊧ ψ) -> (σ ⊧ φ) = (σ ⊧ Update(G(s), σ))
      ;   Then show:
      ;     σ ⊧ φ                                 ; by assumption
      ;     σ ⊧ Update(G(s), σ)                   ; by ProofToDynamics  
      ;     Dynamics(σ) ⊧ φ                       ; by definition of ⇛
      ;     Dynamics(σ) = Dynamics(s)             ; since s ⇛ σ
      ;   Conclude Dynamics(s) ⊧ φ
    }
  }
}

In this abstracted version, I've used the following generic/invented terms:

Sys<S> : An abstract dynamical system with state space S
State<S> : The state space of the system
Dynamics<S> : The dynamics on the state space
Endo<S>, Obs<S>: Endomorphisms and Observables on the state space
Prop<S> : Logical propositions about states
Measure : An abstract measurement/entropy-like function on states
Update : A generic update rule for states
Generator : Generates the dynamics of the system from its specification
Invariant : Finds invariant states of an endomorphism
Valid (⊧) : A generic valid/true relation between states and propositions
Entails (⊧) : Entailment relation on propositions
s ⇒ t : System s transitions to state t
s ⇛ σ : σ is a steady state of the dynamics generated by s

The core ideas are:

Dynamical systems have an associated logic of propositions about states
Valid propositions constrain the system's dynamics
Consistent proposition sets drive the dynamics via an abstract "proof-to-dynamics" inference rule
Steady states maximize an abstract "measure" analogous to entropy
Logical inference drives systems to dynamical equilibrium