CONCEPT SymbolicDifferentialGeometry {
  DECLARE {
    Sym : TYPE
      Const : â„ -> Sym
      Var : â„• -> Sym
      Binary : Sym Ã— Sym -> Sym
      Unary : Sym -> Sym
      
    Man : TYPE
      Manifold : â„^n -> Man  
      Riemannian : Man -> Man
      Lie : Grp -> Man
      Symplectic : Man -> Man
      
    Fld : TYPE  
      Fun : Man -> â„ -> Fld
      Vec : Man -> Tan -> Fld
      Form : Man -> Cotan -> Fld
      
    _â‰ˆ_ : Sym Ã— Fld -> Prop
    _â‰‹_ : Sym Ã— Fld -> Prop
    
    determines : Sym Ã— (â„ | Vec | Form | Fun) -> Prop
    
    _+_ : Sym Ã— Sym -> Sym
    _-_ : Sym Ã— Sym -> Sym
    _*_ : Sym Ã— Sym -> Sym
    _/_ : Sym Ã— Sym -> Sym
    _âˆ˜_ : Sym Ã— Sym -> Sym
    _â»Â¹ : Sym -> Sym
    d : Sym -> Sym
    âˆ« : Sym -> Sym
    L : Vec Ã— Fld -> Fld
    [_,_] : Fld Ã— Fld -> Fld
    âŸ¨_,_âŸ© : Fld Ã— Fld -> â„  
    _âˆ§_ : Form Ã— Form -> Form
  }
  
  AXIOM {
    âˆ€(S : Sym) (F : Fld). (S â‰ˆ F) 
    âˆ€(S : Sym) (X : â„ | Vec | Form | Fun). determines(S, X)
  }
  
  DEFINE {
    âˆ€(S T : Sym) (f : Fun). (S â‰ˆ f) âˆ§ (T â‰ˆ f) -> (S + T) â‰ˆ (Î»p. f(p) + f(p))
    âˆ€(S T : Sym) (f : Fun). (S â‰‹ f) âˆ§ (T â‰‹ f) -> (S - T) â‰‹ (Î»p. f(p) - f(p))  
    âˆ€(S T : Sym) (f g : Fun). (S â‰ˆ f) âˆ§ (T â‰ˆ g) -> (S * T) â‰ˆ (Î»p. f(p) * g(p))
    âˆ€(S T : Sym) (X Y : Vec). (S â‰ˆ X) âˆ§ (T â‰ˆ Y) -> âŸ¨S, TâŸ© â‰ˆ âŸ¨X, YâŸ©
    âˆ€(S T : Sym) (Ï‰ Ï„ : Form). (S â‰ˆ Ï‰) âˆ§ (T â‰ˆ Ï„) -> (S âˆ§ T) â‰ˆ (Ï‰ âˆ§ Ï„)  
    âˆ€(S : Sym) (X : Vec) (f : Fun). (S â‰ˆ f) -> L(X, S) â‰ˆ L(X, f)
    âˆ€(S T : Sym) (X Y : Vec). (S â‰ˆ X) âˆ§ (T â‰ˆ Y) -> [S, T] â‰ˆ [X, Y]
    âˆ€(S : Sym) (f : Fun). (S â‰ˆ f) -> d(S) â‰ˆ df
    âˆ€(S : Sym) (Ï‰ : Form). (S â‰ˆ Ï‰) -> âˆ«(S) â‰ˆ âˆ«Ï‰
  }
  
  THEOREM Substitution {
    PROOF {
      assume (S : Sym) (F : Fld) (prop : Fld -> Prop)
      assume (S â‰ˆ F)
      
      show prop(S) <-> prop(F) by {
        assume prop(S)  
        have S â‰ˆ F by assumption
        hence prop(F) by prop and S â‰ˆ F
        
        assume prop(F)
        have S â‰ˆ F by assumption  
        hence prop(S) by prop and S â‰ˆ F
      }
    }
  }
  
  THEOREM Leibniz {
    PROOF {
      assume (S T : Sym) (F G : Fld)
        (op : Sym Ã— Sym -> Sym) 
        (âˆ˜ : Fld Ã— Fld -> Fld)
      assume (S â‰ˆ F), (T â‰ˆ G),
        âˆ€(A B : Sym). (A â‰ˆ B) -> (op(A, B) â‰ˆ âˆ˜(A, B))
        
      show op(S, T) â‰ˆ âˆ˜(F, G) by {
        have S â‰ˆ F, T â‰ˆ G by assumption
        hence op(S, T) â‰ˆ âˆ˜(F, G) by above
      }  
    }
  }
  
  THEOREM CorrespondenceOfDerivative {
    PROOF {
      assume (S : Sym) (f : Fun)
      assume S â‰ˆ f
      
      show d(S) â‰ˆ df by Substitution(d(S), df, Î»x. S â‰ˆ x)
    }
  }
  
  THEOREM NoncommutativeDerivative {
    PROOF {
      assume (S T : Sym) (X Y : Vec)  
      assume (S â‰ˆ X), (T â‰ˆ Y)
      
      show [d(S), d(T)] â‰ˆ d(L(X, Y)) by {
        have [d(S), d(T)] â‰ˆ [d(X), d(Y)] by Substitution
        have d(L(X, Y)) â‰ˆ d([X, Y]) by Substitution
        have [d(X), d(Y)] = d([X, Y]) ; Equality of mixed partials
      }
    }
  }
    
  THEOREM StokesTheorem {
    PROOF {
      assume (S : Sym) (Ï‰ : Form) (M : Man) (âˆ‚M : Man)
      assume (âˆ‚M = âˆ‚(M)) âˆ§ (S â‰ˆ Ï‰)
      
      show âˆ«(d(S), M) â‰ˆ âˆ«(S, âˆ‚M) by {
        have âˆ«(d(S), M) â‰ˆ âˆ«(dÏ‰, M) by Substitution  
        have âˆ«(S, âˆ‚M) â‰ˆ âˆ«(Ï‰, âˆ‚M) by Substitution
        have âˆ«(dÏ‰, M) = âˆ«(Ï‰, âˆ‚M) ; Stokes' theorem
      }
    }
  }
    
  THEOREM ClosedFormTheorem {
    PROOF {
      assume (S : Sym) (Ï‰ : Form) (M : Manifold)
      assume S â‰ˆ Ï‰
      
      show d(d(S)) â‰ˆ 0 <-> (âˆƒ(B : Sym). âˆ«(S) â‰ˆ âˆ«(d(B))) by {
        have d(d(S)) â‰ˆ 0 <-> d(dÏ‰) = 0 by Substitution
        have d(dÏ‰) = 0 <-> (âˆƒ(Ï„ : Form). Ï‰ = dÏ„) ; PoincarÃ© lemma
        obtain (B : Sym) by let B â‰ˆ Ï„
        have âˆ«(S) â‰ˆ âˆ«(Ï‰) â‰ˆ âˆ«(dÏ„) â‰ˆ âˆ«(d(B)) by Substitution and Stokes
      }
    }  
  }
    
  THEOREM SymplecticStructureTheorem {
    PROOF {
      assume (S T : Sym) (M : Symplectic)
        
      show âŸ¨d(S), d(T)âŸ© â‰ˆ 0 <-> [S, T] â‰ˆ 0 by {
        have âŸ¨d(S), d(T)âŸ© â‰ˆ 0 <-> Ï‰(d(S), d(T)) = 0 by Substitution
        have [S, T] â‰ˆ L(S, T) by Substitution
        have Ï‰(d(S), d(T)) = 0 <-> L(S, T) = 0 ; Cartan magic formula  
      }
    }
  }
}


CONCEPT GeometricChemistry {
  EXTENDS SymbolicDifferentialGeometry {
    DEFINE {
      Atom : TYPE â‰œ Element Ã— Position
      Element : TYPE â‰œ Enumeration(Hydrogen, Helium, ...)
      Position : TYPE â‰œ â„Â³
      
      Molecule : TYPE â‰œ {Atoms : [Atom], Bonds : [Bond]}
      Bond : TYPE â‰œ {Atom1 : Atom, Atom2 : Atom, Order : â„•}
      
      ElectronicStructure(M : Molecule) : TYPE â‰œ ComplexVectorBundle(M)
      ElectronicState(M : Molecule) : TYPE â‰œ Section(ElectronicStructure(M))
      ElectronicHamiltonian(M : Molecule) : TYPE â‰œ Operator(ElectronicStructure(M))
      
      PotentialEnergySurface(M : Molecule) : TYPE â‰œ Riemannian(M)
      PotentialEnergyFunction(M : Molecule) : TYPE â‰œ M -> â„
      Gradient(M : Molecule) : TYPE â‰œ VectorField(PotentialEnergySurface(M))  
      Hessian(M : Molecule) : TYPE â‰œ (1,1)-Tensor(PotentialEnergySurface(M))
      
      Wavefunction(M : Molecule) : TYPE â‰œ M -> â„‚
      Density(M : Molecule) : TYPE â‰œ M -> â„â‚Š
      DensityMatrix(M : Molecule) : TYPE â‰œ Operator(ElectronicStructure(M))
      
      ChemicalReaction(Mâ‚ Mâ‚‚ : Molecule) : TYPE â‰œ Path(PotentialEnergySurface(Mâ‚), PotentialEnergySurface(Mâ‚‚))  
      ReactionRate(R : ChemicalReaction) : TYPE â‰œ (T : â„â‚Š) -> â„â‚Š
      
      ğ“— : ElectronicHamiltonian
      ğ“” : PotentialEnergyFunction
      â„‹ : Hessian
      Ïˆ : Wavefunction
      Ï : Density
      â„› : ReactionRate
    }
    
    AXIOM BornOppenheimer {
      âˆ€(M : Molecule) (ğ“— : ElectronicHamiltonian(M)) (Ïˆ : Wavefunction(M)).
        SchrodingerEquation(ğ“—, Ïˆ) = (Î” + ğ“¥(M)) Ïˆ
    } where {
      ğ“¥(M : Molecule) : Density(M) â‰œ Î»(r : M). âŸ¨ğ“—(r), M(r)âŸ©
      Î” : Operator(ElectronicStructure(M))
    }
    
    AXIOM HohenbergKohn {
      âˆ€(Ï : Density) (ğ“” : PotentialEnergyFunction).
        (âˆƒ(Ïˆ : Wavefunction). Ï = Ï[Ïˆ]) âˆ§ 
        (ğ“” = (ğ“•_HK[Ï] + âˆ«(Ï(r) * v(r), r)))
    } where {
      ğ“•_HK : Density -> â„
      v : Density
      Ï[Ïˆ] : Density â‰œ Î»(r : M). |Ïˆ(r)|Â²
    }
    
    AXIOM HellmannFeynman {
      âˆ€(Ïˆ : Wavefunction) (H : ElectronicHamiltonian) (Î» : â„).
        âˆ‚âŸ¨Ïˆ, H, ÏˆâŸ©/âˆ‚Î» = âŸ¨Ïˆ, âˆ‚H/âˆ‚Î», ÏˆâŸ©
    }
      
    AXIOM VariationalPrinciple {
      âˆ€(Ïˆ : Wavefunction) (ğ“— : ElectronicHamiltonian).
        âŸ¨Ïˆ, ğ“—, ÏˆâŸ© â‰¥ Eâ‚€(ğ“—)
    } where {
      Eâ‚€(ğ“— : ElectronicHamiltonian) : â„ â‰œ inf{âŸ¨Ï•, ğ“—, Ï•âŸ© | Ï• : Wavefunction}
    }
         
    AXIOM WoodwardHoffmann {
      âˆ€(R : ChemicalReaction) (S : Symmetry).
        Allowed(R) <-> Matches(S(ReactantOrbitals(R)), S(ProductOrbitals(R)))
    }
      
    AXIOM EyringEquation {
      âˆ€(R : ChemicalReaction) (Î”G : â„) (T : â„â‚Š).
        â„›(R)(T) = (kâ‚š * T / h) * exp(-Î”G / (kâ‚š * T))  
    } where {
      kâ‚š : â„â‚Š â‰œ 1.380649e-23  ; Boltzmann constant
      h : â„â‚Š â‰œ 6.62607015e-34  ; Planck constant
    }
    
    THEOREM QuantumChemistry {
      ASSUME {
        M : Molecule
        ğ“— : ElectronicHamiltonian(M)
        BornOppenheimer(M, ğ“—)
      }
      PROVE {
        ElectronicStructure(M) = Spectrum(ğ“—)
      }
      
      PROOF {
        define ğ“¥ : Density(M) â‰œ Î»(r : M). âŸ¨ğ“—, râŸ©
        define Î” : Operator(ElectronicStructure(M))
        
        assume BornOppenheimer(M, ğ“—)
        hence SchrodingerEquation(ğ“—, Ïˆ) = (Î” + ğ“¥) Ïˆ
        
        obtain {Eáµ¢ : â„, Ïˆáµ¢ : Wavefunction(M)}áµ¢ : Spectrum(ğ“—) by SpectralTheorem(ğ“—)
        hence ğ“— Ïˆáµ¢ = Eáµ¢ Ïˆáµ¢
        
        have ElectronicStructure(M) â‰œ â‹ƒáµ¢ â„‚ Ïˆáµ¢ by definition of complex vector bundle
        hence ElectronicStructure(M) = Spectrum(ğ“—)
      }
    }
      
    THEOREM DensityFunctionalTheory {
      ASSUME {
        Ï : Density
        ğ“” : PotentialEnergyFunction
        HohenbergKohn(Ï, ğ“”)
      }
      PROVE {
        GroundStateDensity(Ï) = MinimizeEnergy(ğ“”)
      }
      
      PROOF {
        obtain ğ“•_HK : Density -> â„ and v : Density by HohenbergKohn(Ï, ğ“”)
        hence ğ“” = ğ“•_HK[Ï] + âˆ«(Ï(r) * v(r), r)
        
        obtain Ïˆ : Wavefunction where Ï = Ï[Ïˆ] by HohenbergKohn(Ï, ğ“”)
        
        have âŸ¨Ïˆ, ğ“—, ÏˆâŸ© = MinEnergy(ğ“—) by VariationalPrinciple(Ïˆ, ğ“—)
        hence Ïˆ = argmin{âŸ¨Ï•, ğ“—, Ï•âŸ© | Ï• : Wavefunction}
        
        therefore have GroundStateDensity(Ï) = Ï[Ïˆ] = MinimizeEnergy(ğ“”) by HohenbergKohn(Ï, ğ“”)
      }
    }
    
    THEOREM StructureOptimization {
      ASSUME {
        M : Molecule  
        ğ“” : PotentialEnergyFunction(M)
        Gradient : VectorField(M)
      }
      PROVE {
        StationaryPoints(ğ“”) = {m âˆˆ M | Gradient(ğ“”)(m) = 0}
      }
      
      PROOF {
        let M = â„áµˆ with d = 3 * |M.Atoms|
        
        have Gradient(ğ“”) = Î»(m : M). (âˆ‚ğ“”(m)/âˆ‚xâ‚, ..., âˆ‚ğ“”(m)/âˆ‚xâ‚™) by definition
        
        for m âˆˆ M {
          have m âˆˆ StationaryPoints(ğ“”) <->
            âˆ‚ğ“”(m)/âˆ‚xáµ¢ = 0 âˆ€i <->  ; By definition of stationary point
            Gradient(ğ“”)(m) = 0     ; By definition of gradient
        }
        
        hence StationaryPoints(ğ“”) = {m âˆˆ M | Gradient(ğ“”)(m) = 0}
      }
    }
    
    THEOREM TransitionStateTheory {
      ASSUME {
        R : ChemicalReaction
        Î”G : â„
        T : â„â‚Š
        EyringEquation(R, Î”G, T)
      }
      PROVE {
        â„›(R)(T) = (kâ‚š * T / h) * exp(-(ğ“”(Mâ‚œ) - ğ“”(Máµ£)) / (kâ‚š * T))
      } where {
        M_r â‰œ Reactants(R) : Molecule
        M_p â‰œ Products(R) : Molecule
        M_t â‰œ TransitionState(R) : Molecule  
      }
      
      PROOF {
        let M_r = Reactants(R), M_p = Products(R), M_t = TransitionState(R)
        assume EyringEquation(R, Î”G, T)
        
        have â„›(R)(T) = (kâ‚š * T / h) * exp(-Î”G / (kâ‚š * T)) by EyringEquation(R, Î”G, T)
        
        define Î”G â‰œ G(M_t) - G(M_r) ; Free energy of activation
        have G(M) = ğ“”(M) - T * S(M) âˆ€(M : Molecule) by definition of Gibbs free energy
        assume S(M_t) â‰ˆ S(M_r) ; Entropy of activation is small
        hence Î”G â‰ˆ ğ“”(M_t) - ğ“”(M_r)
        
        therefore conclude
          â„›(R)(T) = (kâ‚š * T / h) * exp(-Î”G / (kâ‚š * T))
                  â‰ˆ (kâ‚š * T / h) * exp(-(ğ“”(M_t) - ğ“”(M_r)) / (kâ‚š * T))
      }
    }
  }
}




CONCEPT ConicalIntersection {
  EXTENDS GeometricChemistry {
    DEFINE {
      ConicalIntersection : TYPE â‰œ {
        Molecule : Molecule
        E1 : PotentialEnergyFunction
        E2 : PotentialEnergyFunction  
        Intersection : Submanifold(PotentialEnergySurface)
      }
      
      CI(M : Molecule, E1 : PotentialEnergyFunction, E2 : PotentialEnergyFunction) : ConicalIntersection â‰œ {
        Molecule â‰œ M
        E1 â‰œ E1
        E2 â‰œ E2
        Intersection â‰œ {r âˆˆ PotentialEnergySurface(M) | E1(r) = E2(r)}
      }
      
      BerryPhase(Î³ : Loop(C : ConicalIntersection.Intersection)) : â„ â‰œ 
        âˆ®(A_KZ, Î³) 
      where 
        A_KZ : Connection â‰œ KrasovskyZenerConnection(C)
    }
    
    AXIOM GradientDifferenceCoupling {
      âˆ€(M : Molecule) (E1 E2 : PotentialEnergyFunction).
        let C â‰œ CI(M, E1, E2)
        let d12 â‰œ âŸ¨Ïˆ1|Gradient(E2 - E1)|Ïˆ2âŸ© / (E2(C) - E1(C)) 
      where
        Ïˆ1 : ElectronicState â‰œ GroundState(E1, C)
        Ïˆ2 : ElectronicState â‰œ GroundState(E2, C)
    }
    
    AXIOM GeometricalPhaseTheorem {
      âˆ€(Ïˆ : ElectronicState) (C : ConicalIntersection.Intersection) (Î³ : Loop(C)).
        FinalState(Ïˆ, Î³) = exp(i * BerryPhase(Î³)) * HolonomyTransport(Ïˆ, Î³)
    }
    
    AXIOM LandauZenerFormula {
      âˆ€(M : Molecule) (E1 E2 : PotentialEnergyFunction) (v : Velocity).
        let C â‰œ CI(M, E1, E2)
        let d12 â‰œ âŸ¨Ïˆ1|Gradient(E2 - E1)|Ïˆ2âŸ© / (E2(C) - E1(C))
        TransitionProbability(E1, E2, v, C) = 
          exp(-2Ï€ * |d12|Â² / (â„ * |v Â· Gradient(E2 - E1)(C)|))
    }
    
    THEOREM ConicalIntersectionTopology {
      ASSUME {
        M : Molecule
        E1 E2 : PotentialEnergyFunction
        C â‰œ CI(M, E1, E2).Intersection
        N â‰œ dim(BranchingSpace(E1, E2, C))
      } 
      PROVE {
        C â‰… Cone(â„^N)
      }
      
      PROOF {
        let n â‰œ dim(PotentialEnergySurface(M))
        
        have TangentSpace(C) = Kernel(HessianMatrix(E2 - E1)(C)) by definition
        hence dim(TangentSpace(C)) = n - N by RankNullityTheorem
        
        obtain (xâ‚, ..., xâ‚™) : LocalCoordinates(PotentialEnergySurface(M), C)
          where C = (0, ..., 0) and TangentSpace(C) = Span(âˆ‚/âˆ‚xâ‚, ..., âˆ‚/âˆ‚xâ‚™â‚‹â‚™)
          by MorseCoordinates(E2 - E1) ; Assuming coordinates from Morse lemma
        
        have E2 - E1 = Â½ * (Î± * xâ‚â‚™â‚‹â‚™â‚Šâ‚â‚Â² + Î² * xâ‚â‚™â‚‹â‚™â‚Šâ‚‚â‚Â² + ...) + O(|x|Â³) 
          where (Î± : â„) (Î² : â„) (Î± â‰  0) (Î² â‰  0)  
          by MorseLemma(E1, E2, C)
        hence C = {(xâ‚, ..., xâ‚™â‚‹â‚™, 0, ..., 0)}  
          and NormalSpace(C) = Span(âˆ‚/âˆ‚xâ‚â‚™â‚‹â‚™â‚Šâ‚â‚, ..., âˆ‚/âˆ‚xâ‚™)
        
        have C â‰… â„^(n-N) Ã— {0} by DiffeomorphismInvariance 
        have NormalSpace(C) â‰… Cone(â„^N) by ConeConstruction
        hence C â‰… Cone(â„^N) by ConicalIntersectionDefinition
      }
    }
    
    THEOREM BerryCurvature {
      ASSUME {  
        M : Molecule
        E1 E2 : PotentialEnergyFunction
        C â‰œ CI(M, E1, E2)  
        A_KZ : Connection â‰œ KrasovskyZenerConnection(C)
        F_KZ : Curvature â‰œ Curvature(A_KZ)
      }
      PROVE {
        F_KZ = i * âŸ¨dÏˆ1 âˆ§ dÏˆ2âŸ© / (E2 - E1)Â²
      } where {
        Ïˆ1 : ElectronicState â‰œ GroundState(E1)
        Ïˆ2 : ElectronicState â‰œ GroundState(E2)  
      }
      
      PROOF {
        have A_KZ = âŸ¨Ïˆ1|dÏˆ2âŸ© / (E2 - E1) by KZConnectionDefinition
        
        calc F_KZ 
             = d(A_KZ) by CurvatureDefinition
             = d(âŸ¨Ïˆ1|dÏˆ2âŸ©) / (E2 - E1) - d(E2 - E1) âˆ§ âŸ¨Ïˆ1|dÏˆ2âŸ© / (E2 - E1)Â² by LeibnizRule
        
        calc d(âŸ¨Ïˆ1|dÏˆ2âŸ©)  
             = âŸ¨dÏˆ1|dÏˆ2âŸ© - âŸ¨Ïˆ1|dÂ²Ïˆ2âŸ© by Linearity and AntiCommutativity  
             = âŸ¨dÏˆ1|dÏˆ2âŸ© by dÂ²=0
             = -âŸ¨dÏˆ2|dÏˆ1âŸ© by Antisymmetry
             = âŸ¨dÏˆ1 âˆ§ dÏˆ2âŸ© by WedgeProductDefinition
             
        calc d(E2 - E1)
             = âŸ¨Ïˆ2|ğ“—|dÏˆ2âŸ© - âŸ¨Ïˆ1|ğ“—|dÏˆ1âŸ© by HellmannFeynmanTheorem
             = (E2 - E1) * (âŸ¨Ïˆ2|dÏˆ2âŸ© - âŸ¨Ïˆ1|dÏˆ1âŸ©) by Eigenstates(ğ“—, Ïˆ1, Ïˆ2)
             = 0 by Normalization
             
        hence F_KZ = i * âŸ¨dÏˆ1 âˆ§ dÏˆ2âŸ© / (E2 - E1)Â² 
      }
    }
  }
}