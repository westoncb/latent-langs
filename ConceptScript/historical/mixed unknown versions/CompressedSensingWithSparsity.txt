CONCEPT CompressedSensingWithSparsity {
  DECLARE {
    Signal : TYPE
    SparseSignal : TYPE = {s : Signal | âˆƒÎ© âŠ† Domain(s). |Î©| â‰ª |Domain(s)| âˆ§ âˆ€i âˆ‰ Î©. s(i) = 0}
    Measurement : TYPE = Signal -> â„
    SensingMatrix : TYPE = â„^(m Ã— n)
    Dictionary : TYPE = â„^(n Ã— p)
    
    L0Norm : TYPE = Signal -> â„•
    L1Norm : TYPE = Signal -> â„
    L2Norm : TYPE = Signal -> â„
    
    MutualCoherence : TYPE = SensingMatrix Ã— Dictionary -> â„
    RestrictedIsometry : TYPE = SensingMatrix Ã— â„• -> ð”¹
    
    BasisPursuit : TYPE = [Measurement] Ã— SensingMatrix -> Signal
    OrthogonalMatchingPursuit : TYPE = [Measurement] Ã— SensingMatrix Ã— â„• -> SparseSignal
    
    SparseRecovery : TYPE = SparseSignal Ã— SensingMatrix Ã— [Measurement] -> SparseSignal
  }
  
  DEFINE {
    ; L0 norm (sparsity) of a signal
    L0Norm(s) â‰œ |{i âˆˆ Domain(s) | s(i) â‰  0}|
    
    ; L1 norm of a signal  
    L1Norm(s) â‰œ âˆ‘{i âˆˆ Domain(s)} |s(i)|
    
    ; L2 norm (Euclidean) of a signal
    L2Norm(s) â‰œ âˆš(âˆ‘{i âˆˆ Domain(s)} s(i)^2)
    
    ; Mutual coherence of a sensing matrix and dictionary
    MutualCoherence(A, Î¨) â‰œ max{âŸ¨A_i, Î¨_jâŸ© | i âˆˆ [m], j âˆˆ [p], i â‰  j} / (âˆ¥A_iâˆ¥_2 * âˆ¥Î¨_jâˆ¥_2)
    
    ; Restricted isometry property of a sensing matrix
    RestrictedIsometry(A, k) â‰œ âˆ€s âˆˆ SparseSignal. L0Norm(s) â‰¤ k â‡’ 
      (1 - Î´_k) * âˆ¥sâˆ¥_2^2 â‰¤ âˆ¥A * sâˆ¥_2^2 â‰¤ (1 + Î´_k) * âˆ¥sâˆ¥_2^2
    
    ; Basis pursuit recovery algorithm
    BasisPursuit(y, A) â‰œ argmin{âˆ¥sâˆ¥_1 | A * s = y}
    
    ; Orthogonal matching pursuit recovery algorithm  
    OrthogonalMatchingPursuit(y, A, k) â‰œ {
      let r = y
      let Î© = {}
      repeat k times {
        let i = argmax{|âŸ¨r, A_jâŸ©| | j âˆˆ [n]}
        let Î© = Î© âˆª {i}
        let P_Î© = A_Î© * (A_Î©^T * A_Î©)^(-1) * A_Î©^T
        let r = (I - P_Î©) * y
      }
      return s with Support(s) = Î© and A_Î© * s_Î© = P_Î© * y
    }
  }
  
  AXIOM {
    ; Sparse signals have small L0 norm
    âˆ€s âˆˆ SparseSignal. L0Norm(s) â‰ª |Domain(s)|
    
    ; L1 norm is a convex relaxation of L0 norm 
    âˆ€s âˆˆ Signal. L1Norm(s) â‰¤ âˆš(L0Norm(s)) * L2Norm(s)
    
    ; Mutual coherence bounds the restricted isometry constant
    âˆ€A âˆˆ SensingMatrix, Î¨ âˆˆ Dictionary, k âˆˆ â„•.
      MutualCoherence(A, Î¨) < 1 / (2 * k - 1) â‡’ RestrictedIsometry(A * Î¨, k)
    
    ; Sparse recovery is possible under restricted isometry
    âˆ€s âˆˆ SparseSignal, A âˆˆ SensingMatrix, y âˆˆ [Measurement].
      RestrictedIsometry(A, 2 * L0Norm(s)) â‡’ 
      L2Norm(SparseRecovery(s, A, [âŸ¨A_i, sâŸ© | i âˆˆ [m]]) - s) â‰¤ C * L1Norm(s - s_k) / âˆšk
        where s_k = argmin{âˆ¥s - zâˆ¥_1 | L0Norm(z) â‰¤ k}
  }
  
  THEOREM BasisPursuitRecovery {
    PROOF {
      assume s âˆˆ SparseSignal, A âˆˆ SensingMatrix, y = [âŸ¨A_i, sâŸ© | i âˆˆ [m]]
      assume RestrictedIsometry(A, 2 * k) for k = L0Norm(s)
      
      let s' = BasisPursuit(y, A)
      
      have L1Norm(s') â‰¤ L1Norm(s) by optimality of basis pursuit
      have L2Norm(s' - s) â‰¤ C * L1Norm(s - s_k) / âˆšk for s_k = s by sparse recovery axiom
      hence L2Norm(s' - s) â‰¤ C * 0 / âˆšk = 0
      
      show s' = s by properties of L2 norm
    }
  }
  
  THEOREM OrthogonalMatchingPursuitRecovery {
    PROOF {
      assume s âˆˆ SparseSignal, A âˆˆ SensingMatrix, y = [âŸ¨A_i, sâŸ© | i âˆˆ [m]]
      assume MutualCoherence(A, I) < 1 / (2 * k - 1) for k = L0Norm(s)
      
      let s' = OrthogonalMatchingPursuit(y, A, k)
      
      have Support(s') âŠ† Support(s) by construction of OMP
      have A_Support(s') * s'_Support(s') = P_Support(s') * y by construction of OMP
      hence A_Support(s') * s'_Support(s') = A_Support(s') * s_Support(s')
      
      have RestrictedIsometry(A, k) by mutual coherence axiom
      hence (1 - Î´_k) * âˆ¥s'âˆ¥_2^2 â‰¤ âˆ¥A * s'âˆ¥_2^2 â‰¤ (1 + Î´_k) * âˆ¥s'âˆ¥_2^2
      have (1 - Î´_k) * âˆ¥sâˆ¥_2^2 â‰¤ âˆ¥A * sâˆ¥_2^2 â‰¤ (1 + Î´_k) * âˆ¥sâˆ¥_2^2
      
      calc {
        âˆ¥s' - sâˆ¥_2^2 
          = âˆ¥s'âˆ¥_2^2 + âˆ¥sâˆ¥_2^2 - 2 * âŸ¨s', sâŸ©
          â‰¤ (1 + Î´_k) / (1 - Î´_k) * âˆ¥sâˆ¥_2^2 + âˆ¥sâˆ¥_2^2 - 2 * âŸ¨s'_Support(s), s_Support(s)âŸ©
          = (1 + Î´_k) / (1 - Î´_k) * âˆ¥sâˆ¥_2^2 +
          = (1 + Î´_k) / (1 - Î´_k) * âˆ¥sâˆ¥_2^2 + âˆ¥sâˆ¥_2^2 - 2 * âŸ¨s'_Support(s), s_Support(s)âŸ©
          = (1 + Î´_k) / (1 - Î´_k) * âˆ¥sâˆ¥_2^2 + âˆ¥sâˆ¥_2^2 - 2 * âˆ¥s_Support(s)âˆ¥_2^2
          = ((1 + Î´_k) / (1 - Î´_k) - 1) * âˆ¥sâˆ¥_2^2
          â‰¤ 4 * Î´_k / (1 - Î´_k) * âˆ¥sâˆ¥_2^2
          â‰¤ 8 * Î´_k * âˆ¥sâˆ¥_2^2  ; for Î´_k â‰¤ 1/2
      }
      
      show âˆ¥s' - sâˆ¥_2 â‰¤ âˆš(8 * Î´_k) * âˆ¥sâˆ¥_2 by properties of L2 norm
    }
  }
}