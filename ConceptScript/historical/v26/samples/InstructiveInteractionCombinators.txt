CONCEPT InstructiveInteractionCombinators {
  LANGUAGE {
    -- Symbols represent the different types of combinators in the interaction system.
    TYPE Symbol

    -- A cell is a pair of a symbol and a list of ports, representing a combinator and its connections.
    TYPE Cell = (Symbol, List[Port])

    -- A port is a pair of a cell and a natural number, representing a connection point on a cell.
    TYPE Port = (Cell, â„•)

    -- A net is a triple of sets: cells, ports, and connections between ports.
    -- It represents the state of the interaction system at a given point in time.
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])
    
    -- The arity function maps a symbol to the number of auxiliary ports it has.
    FUNC Arity : Symbol -> â„•

    -- The interaction function defines the rewrite rules for pairs of symbols.
    -- It returns a net that represents the result of the interaction, if defined.
    FUNC Interaction : (Symbol, Symbol) -> Maybe[Net]

    -- The reduced predicate checks whether a net is in a fully reduced state.
    PRED Reduced : Net -> ğ”¹
    
    -- Axiom: The number of ports in a cell must match the arity of its symbol plus one (for the principal port).
    AXIOM PortCount {
      âˆ€ (s : Symbol) (c : Cell) (ps : List[Port]) . 
        (c = (s, ps)) => Length(ps) = Arity(s) + 1
    }
    
    -- Axiom: All ports in a cell must be distinct.
    AXIOM PortDistinct {
      âˆ€ (c : Cell) (ps : List[Port]) (i j : â„•) . 
        ((c, ps) âˆˆ Net âˆ§ (c, i) âˆˆ ps âˆ§ (c, j) âˆˆ ps âˆ§ i â‰  j) => (c, i) â‰  (c, j)
    }
    
    -- Axiom: The interaction rules are symmetric.
    -- If 'a' interacts with 'b' to produce net 'Î±', then 'b' interacts with 'a' to produce the flipped version of 'Î±'.
    AXIOM Symmetry {
      âˆ€ (a b : Symbol) (Î± Î² : Net) . 
        Interaction(a, b) = Î± âˆ§ Interaction(b, a) = Î² => Î± = Flip(Î²)
    }
    
    -- Axiom: The interaction rules are deterministic.
    -- If 'a' interacts with 'b', there is only one possible resulting net.
    AXIOM Determinism {
      âˆ€ (a b : Symbol) (Î± Î² : Net) . 
        Interaction(a, b) = Î± âˆ§ Interaction(a, b) = Î² => Î± = Î²
    }
  }
  
  NOTATION {
    -- Notation for reduction steps in a specific interaction system.
    "+ --S--> &" = "Net + reduces to Net & in system S"
    "+ --*S--> &" = "Net + reduces to Net & in zero or more steps in system S"

    -- Notation for reduction steps in the general Interaction Combinators system.
    "+ --IC--> &" = "Net + reduces to Net & in the Interaction Combinators system"
    "+ --*IC--> &" = "Net + reduces to Net & in zero or more steps in the Interaction Combinators system"

    -- Notation for the set of translations between interaction systems.
    "ğ’¯(S, T)" = "The set of translations from interaction system S to interaction system T"

    -- Notation for substitution of a cell in a net.
    "<x â†¦ y>z" = "Substitution of x with y in z"
  }

  STRUCTURE InteractionSystem {
    -- An interaction system consists of an alphabet of symbols and a set of interaction rules.
    alphabet : Set[Symbol]
    rules : Map[(Symbol, Symbol), Net]
      
    -- Requirements:
    -- - All symbols in the interaction rules must belong to the alphabet.
    -- - The resulting net of each interaction rule must be reduced.
    REQUIRE âˆ€ ((a, b) â†¦ Î±) âˆˆ rules . a âˆˆ alphabet âˆ§ b âˆˆ alphabet âˆ§ Reduced(Î±)

    -- - For every pair of symbols in the alphabet, there must be an interaction rule defined
    --   (either in the original order or in the flipped order).
    REQUIRE âˆ€ (a, b) âˆˆ (alphabet Ã— alphabet) . ((a, b) âˆˆ rules.Keys âˆ¨ (b, a) âˆˆ rules.Keys)  
  }
    
  TRANSFORMERS {
    -- Tactic for substituting a cell in a net with another net.
    TACTIC Substitution(+ : Net, c : Cell, ? : Net) -> Net = {  
      MATCH + WITH
      | ({c} âˆª cs, ps, ws) ->  (cs âˆª ?.Cells, <c â†¦ ?.Ports>ps, <c â†¦ ?.Wires>ws)
    }
  }
  
  PROOFS {  
    THEOREM ChurchRosser {
      STATEMENT:
        -- The Church-Rosser property (also known as confluence):
        -- If a net '+' reduces to two nets '&1' and '&2' in an interaction system 'S',
        -- then there exists a unique net '!' such that both '&1' and '&2' reduce to '!' in 'S'.
        âˆ€ (S : InteractionSystem) (+ : Net) .
          (+ --*S--> &1 âˆ§ + --*S--> &2) => (âˆƒ ! : Net . &1 --*S--> ! âˆ§ &2 --*S--> !)
          
      PROOF:
        -- Proof sketch:
        -- 1. Assume a net '+' reduces to '&1' and '&2' in system 'S'.
        -- 2. Show that '&1' and '&2' have a common reduct '!', using local confluence and induction.
        -- 3. Show that the common reduct '!' is unique, using induction and the determinism axiom.

        LET S : InteractionSystem, + : Net
        ASSUME +1 : + --*S--> &1, +2 : + --*S--> &2
        
        HAVE LocalConfluence := âˆ€ (. : Net) .
          (. --S--> .1 âˆ§ . --S--> .2) => (âˆƒ ! : Net . .1 --S--> ! âˆ§ .2 --S--> !)
        
        SHOW âˆƒ (! : Net) . &1 --*S--> ! âˆ§ &2 --*S--> ! {
          REWRITE &1 
            = .1 --S--> ... --S--> /1
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> /2  
          HAVE /1 = /2 BY Induction, LocalConfluence 
        }
        
        SHOW ! : ! = &1 --*S--> ? âˆ§ &2 --*S--> ? {  
          REWRITE &1
            = .1 --S--> ... --S--> !
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> !
          
          ASSUME &1 --*S--> ?1, &2 --*S--> ?2
          
          REWRITE ?1
            = ! --S--> ... --S--> ?1  
          REWRITE ?2
            = ! --S--> ... --S--> ?2
          
          HAVE ?1 = ?2 BY Induction, Determinism
        }  
      }
    }
    
    THEOREM TranslationTheorem {
      STATEMENT:  
        -- For every interaction system 'S', there exists a translation 'T' to the Interaction Combinators system
        -- such that 'T' faithfully represents the behavior of 'S'.
        âˆ€ (S : InteractionSystem) .
          âˆƒ (T : ğ’¯(S, InteractionCombinatorsSystem)) . FaithfullyRepresents(T)
      
      PROOF:
        -- Proof sketch:
        -- 1. Define the translation 'T' from system 'S' to the Interaction Combinators system.
        -- 2. Show that 'T' preserves reduction steps (equivariance).
        -- 3. Show that 'T' preserves net reducedness.
        -- 4. Conclude that 'T' faithfully represents the behavior of 'S'.

        LET S : InteractionSystem
        LET (C, D, E, #p, #q, $p, $q) := InteractionCombinatorsSystem.alphabet
        
        -- Define the translation 'T' as follows:
        -- - For each symbol 'a' in the alphabet of 'S', 'T(a)' is the tree encoding of the interaction rules for 'a'.
        -- - For each net '+' in 'S', 'T(+)' is the substitution of each cell in '+' with its translated version.
        DEFINE ğ’¯ : ğ’¯(S, InteractionCombinatorsSystem) {
          ON a : S.alphabet
            DEFINE ğ’¯(a) := TreeOf(CodesOf({& | (a, b) â†¦ & âˆˆ S.rules}))
          ON + : Net 
            DEFINE ğ’¯(+) := <a â†¦ ğ’¯(a)>+
        }  
        
        -- Show that 'T' preserves reduction steps (equivariance):
        -- If '+' reduces to '&' in 'S', then 'T(+)' reduces to 'T(&)' in the Interaction Combinators system.
        SHOW Equivariant(ğ’¯) BY {
          LET + & : Net, + --S--> &
          SHOW ğ’¯(+) --*IC--> ğ’¯(&) USING DecodingSimulation
        }

        -- Show that 'T' preserves net reducedness:
        -- A net '+' is reduced in 'S' if and only if 'T(+)' is reduced in the Interaction Combinators system.
        SHOW Reduced(ğ’¯(+)) <=> Reduced(+) USING DecodingSimulation, Definitions
        
        -- Conclude that 'T' faithfully represents the behavior of 'S'.
        HENCE FaithfullyRepresents(ğ’¯)
      }
    }
  }
}