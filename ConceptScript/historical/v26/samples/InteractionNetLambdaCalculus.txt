CONCEPT InteractionNetLambdaCalculus {
  LANGUAGE {
    TYPE Term
    TYPE Variable <: Term
    TYPE Abstraction <: Term
    TYPE Application <: Term
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, â„•)  
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])

    FUNC Var(name : String) : Variable
    FUNC Abs(v : Variable, body : Term) : Abstraction
    FUNC App(func : Term, arg : Term) : Application
    FUNC Arity : Symbol -> â„•
    FUNC Interaction : (Symbol, Symbol) -> Maybe[Net]
    FUNC Compile : Term -> Net
    FUNC Evaluate : Net -> Maybe[Term]

    PRED Equiv(t : Term, s : Term)
    PRED Reduced : Net -> ð”¹

    AXIOM Soundness {
      âˆ€ (t : Term) (Î± : Net) . Compile(t) = Î± => Equiv(t, Evaluate(Î±))
    }

    AXIOM Completeness {
      âˆ€ (t s : Term) . Equiv(t, s) => Reduced(Compile(t)) âˆ§ Evaluate(Compile(t)) = s  
    }
  }

  NOTATION {
    "Î» v . t" = Abs(Var(v), t) 
    "t s" = App(t, s)
    "t ~ s" = Equiv(t, s)
    "#" = "<Blank Symbol>"
    "Î± ~ t" = Equiv(Evaluate(Î±), t)
    "!" = Reduced
  }

  TRANSFORMERS {
    FUNC CompileVar(v) = ([v], [], [])

    FUNC CompileAbs(v, t) = {
      LET (V, P, W) = Compile(t)
      LET p_in = (v, 0)
      LET p_out = (v, 1)  
      (V âˆª {v}, P âˆª {p_in, p_out}, W âˆª {(p_in, P.In), (P.Out, p_out)})
    }
      
    FUNC CompileApp(t, s) = {
      LET (V1, P1, W1) = Compile(t) 
      LET (V2, P2, W2) = Compile(s)
      LET p = (NewPort(), 0)
      (V1 âˆª V2 âˆª {p}, P1 âˆª P2 âˆª {p}, W1 âˆª W2 âˆª {(P1.Out, p), (p, P2.In)}) 
    }

    REWRITE Interaction("Î»", v) = Some(([v], [], []))
    REWRITE Interaction(v, "#") = Some(([], [], []))
    REWRITE Interaction(p1, p2) = Some(([], [], [(p1, p2)]))
      
    FUNC EvaluateApp(Î±) = {
      MATCH Î± WITH
      | (âˆ…, âˆ…, âˆ…) -> None
      | ({c}, {p_in, p_out}, {(p_in, p), (c, 1, p_out)}) -> Evaluate(c)
      | _ -> EvaluateApp(Reduce(Î±))
    }
      
    FUNC Reduce(Î±) = {
      LET {c1, c2 | (c1, i1, c2, i2) âˆˆ W} = Î±.Cells
      LET i = Interaction(c1.Symbol, c2.Symbol) 
      MATCH i WITH
      | None -> Î±
      | Some(Î±') -> {
        LET p_in1 = (c1, i1)
        LET p_out1 = (c1, (i1+1) % Arity(c1.Symbol)) 
        LET p_in2 = (c2, i2)
        LET p_out2 = (c2, (i2+1) % Arity(c2.Symbol))
        LET W_redir = {(p, q) | (p, (c1,_)) âˆˆ W âˆ§ (p_out1, q) âˆˆ Î±'.Wires} âˆª  
                       {(p, q) | (p, (c2,_)) âˆˆ W âˆ§ (p_out2, q) âˆˆ Î±'.Wires} âˆª
                       {(p, q) | ((c1,_), q) âˆˆ W âˆ§ (p, p_in1) âˆˆ Î±'.Wires} âˆª
                       {(p, q) | ((c2,_), q) âˆˆ W âˆ§ (p, p_in2) âˆˆ Î±'.Wires}
        (Î±.Cells \ {c1, c2} âˆª Î±'.Cells,  
         Î±.Ports \ {p_in1, p_out1, p_in2, p_out2} âˆª Î±'.Ports,
         Î±.Wires \ {(_, c1,_), (_, c2,_), (c1,_,_), (c2,_,_)} âˆª W_redir âˆª Î±'.Wires)
      }
    }
  }

  PROOFS {
    THEOREM CompileCorrect {
      STATEMENT:
        âˆ€ (t : Term) . t ~ Evaluate(Compile(t))
      
      PROOF:
        BY Induction on t
        CASE Variable:
          LET v = Var(x)
          SHOW v ~ Evaluate(Compile(v)) {
            Compile(v) = ([v], [], []) = Î±
            Evaluate(Î±) = Some(v) = v
          }
          
        CASE Abstraction:
          LET t = Abs(v, t')
          ASSUME IH: t' ~ Evaluate(Compile(t')) (IH)
          SHOW Abs(v, t') ~ Evaluate(Compile(Abs(v, t'))) {
            Compile(t) = CompileAbs(v, t') = Î±
            HAVE Î± = (V âˆª {v}, P âˆª {p_in, p_out}, W âˆª {(p_in, P.In), (P.Out, p_out)})
            EvaluateApp(Î±) 
              = EvaluateApp((V âˆª {v}, {p_in, p_out}, {(p_in, p), (v, 1, p_out)})) 
                WHERE (V, P, W) = Compile(t')
              = Evaluate(v) = Abs(Var(v), Evaluate(Compile(t'))) 
              ~ Abs(Var(v), t') BY IH
          }
                
        CASE Application:
          LET t = App(t1, t2)
          ASSUME 
            IH1: t1 ~ Evaluate(Compile(t1))
            IH2: t2 ~ Evaluate(Compile(t2))
          SHOW App(t1, t2) ~ Evaluate(Compile(App(t1, t2))) {
            Compile(App(t1, t2)) 
              = CompileApp(t1, t2) 
              = (V1 âˆª V2 âˆª {p}, P1 âˆª P2 âˆª {p}, W1 âˆª W2 âˆª {(P1.Out, p), (p, P2.In)})
                WHERE (V1, P1, W1) = Compile(t1)
                      (V2, P2, W2) = Compile(t2) 
            REWRITE EvaluateApp(_)
              = EvaluateApp(Reduce(_))  
              = EvaluateApp(Reduce(V1 âˆª V2, P1 âˆª P2, W1 âˆª W2 âˆª {(P1.Out, P2.In)}))
              = EvaluateApp(P1.Out, [P2.In])
              = App(Evaluate(Compile(t1)), Evaluate(Compile(t2)))
              ~ App(t1, t2) BY IH1, IH2
          }
          
        QED  
    }
      
    THEOREM ReduceCorrect {
      STATEMENT:  
        âˆ€ (t : Term) (Î± : Net) . 
          t ~ Î± => (Reduced(Î±) âˆ§ Evaluate(Î±) = t) âˆ¨ (âˆƒ (Î² : Net) . Î± --IC--> Î² âˆ§ t ~ Î²)
      
      PROOF:
        ASSUME t ~ Î±
        SHOW (Reduced(Î±) âˆ§ Evaluate(Î±) = t) âˆ¨ (âˆƒ (Î² : Net) . Î± --IC--> Î² âˆ§ t ~ Î²) {
          CASES Î±
          CASE !Î± âˆ§ Î± ~ t:
            HENCE Evaluate(Î±) = t BY Assumption
            
          CASE âˆƒ (Î² : Net) . Î± --IC--> Î²:
            LET c1, c2, Î±' = 
              CHOOSE (c1 : Cell) (c2 : Cell) (Î±' : Net) . 
              (c1 âˆˆ Î±.Cells âˆ§ c2 âˆˆ Î±.Cells âˆ§ Interaction(c1.Symbol, c2.Symbol) = Some(Î±'))
            
            LET t1, t2 = CHOOSE (t1 t2 : Term) . t = App(t1, t2) BY t ~ Î±
            
            HAVE t1 ~ Compile(c1.Symbol) = Î±1, 
                 t2 ~ Compile(c2.Symbol) = Î±2
              BY CompileCorrect, Assumption
            
            REWRITE Reduce(Î±)  
              = Reduce({c1, c2}, {p1, p2}, {(c1, p1), (c2, p2)}) 
                  ++ (Î± \ {c1, c2, p1, p2, (c1, p1), (c2, p2)})
              = Î±' ++ (Î± \ {c1, c2, p1, p2, (c1, p1), (c2, p2)})
              WHERE p1 = (c1, i1), p2 = (c2, i2)  
            
            REWRITE t
              = App(t1, t2)
              ~ App(Evaluate(Î±1), Evaluate(Î±2)) 
                BY Î±1 ~ t1, Î±2 ~ t2
              ~ Evaluate(Î±') BY CompileCorrect
              ~ Evaluate(Reduce(Î±))
          
          HENCE âˆƒ (Î² : Net) . Î± --IC--> Î² âˆ§ t ~ Î²
        }  
        
        QED
    }
  }
}







CONCEPT InteractionCombinatorCalculus {
  LANGUAGE {
    TYPE Term  
    TYPE Variable <: Term
    TYPE Abstraction <: Term
    TYPE Application <: Term
    TYPE Interaction <: Term
    
    FUNC Var(name : String) : Variable
    FUNC Abs(v : Variable, body : Term) : Abstraction
    FUNC App(func : Term, arg : Term) : Application
    FUNC Int(a : Term, b : Term) : Interaction

    FUNC FreeVars(t : Term) : Set[Variable]
    FUNC BoundVars(t : Term) : Set[Variable]
    FUNC Subterms(t : Term) : Set[Term]
    FUNC Subst(t : Term, v : Variable, s : Term) : Term

    PRED FreeFor(v : Variable, t : Term, s : Term) = 
      Â¬âˆƒ (u : FreeVars(s)) . u âˆˆ BoundVars(t)
    PRED Reduces(t : Term, s : Term)
    PRED Equivalent(t : Term, s : Term) = Reduces(t, s) âˆ§ Reduces(s, t)
  }

  NOTATION {
    "Î» v . t" = Abs(Var(v), t)
    "t s" = App(t, s)
    "t # s" = Int(t, s)
    "t [v := s]" = Subst(t, v, s)
    "t ->Î² s" = BetaReduces(t, s)  
    "t ->Î¹ s" = InteractionReduces(t, s)
    "t =Î²Î¹ s" = BetaInteractionEquivalent(t, s)
  }

  TRANSFORMERS {
    REWRITE FreeVars(Var(x)) = {Var(x)}
    REWRITE FreeVars(Abs(v, t)) = FreeVars(t) \ {v}
    REWRITE FreeVars(App(t, s)) = FreeVars(t) âˆª FreeVars(s) 
    REWRITE FreeVars(Int(t, s)) = FreeVars(t) âˆª FreeVars(s)

    REWRITE BoundVars(Var(x)) = {}
    REWRITE BoundVars(Abs(v, t)) = {v} âˆª BoundVars(t)
    REWRITE BoundVars(App(t, s)) = BoundVars(t) âˆª BoundVars(s)
    REWRITE BoundVars(Int(t, s)) = BoundVars(t) âˆª BoundVars(s)

    REWRITE Subterms(Var(x)) = {Var(x)}
    REWRITE Subterms(Abs(v, t)) = {Abs(v, t)} âˆª Subterms(t)
    REWRITE Subterms(App(t, s)) = {App(t, s)} âˆª Subterms(t) âˆª Subterms(s) 
    REWRITE Subterms(Int(t, s)) = {Int(t, s)} âˆª Subterms(t) âˆª Subterms(s)

    REWRITE Subst(Var(x), v, s) = IF v = Var(x) THEN s ELSE Var(x)
    REWRITE Subst(Abs(v, t), u, s) = IF v = u THEN Abs(v, t) 
                                       ELSE IF FreeFor(v, t, s) THEN Abs(v, Subst(t, u, s))
                                       ELSE LET w = FreshVar(v, t, s) IN
                                         Abs(w, Subst(Subst(t, v, Var(w)), u, s))  
    REWRITE Subst(App(t1, t2), v, s) = App(Subst(t1, v, s), Subst(t2, v, s))
    REWRITE Subst(Int(t1, t2), v, s) = Int(Subst(t1, v, s), Subst(t2, v, s))

    FUNC FreshVar(v : Variable, t : Term, s : Term) -> Variable = {
      LET used = FreeVars(t) âˆª FreeVars(s) 
      LET x = v.name
      LET x' = x
      WHILE Var(x') âˆˆ used:
        x' := x + "'"
      Var(x')
    }
      
    TACTIC BetaReduces(t : Term, s : Term) -> Bool = {
      MATCH t WITH
      | App(Abs(v, t1), t2) -> IF FreeFor(v, t1, t2) THEN
                                 s = Subst(t1, v, t2)
                               ELSE 
                                 LET w = FreshVar(v, t1, t2),
                                     t1' = Subst(t1, v, Var(w))  
                                 IN s = Subst(t1', w, t2)
      | _ -> âˆƒ (t' : Subterms(t)) . t' ->Î² s' âˆ§ Replace(t, t', s') = s                            
    }
      
    TACTIC InteractionReduces(t : Term, s : Term) -> Bool = {
      MATCH t WITH
      | Int(Abs(v, t1), Abs(u, t2)) -> IF v = u THEN
                                          s = Subst(Subst(t1, v, t2), u, Abs(v, t1))
                                        ELSE 
                                          LET w = FreshVar(v, t1, t2),
                                              t1' = Subst(t1, v, Var(w)),
                                              t2' = Subst(t2, u, Var(w))
                                          IN s = Subst(Subst(t1', w, t2'), w, Abs(w, t1'))
      | _ -> âˆƒ (t' : Subterms(t)) . t' ->Î¹ s' âˆ§ Replace(t, t', s') = s
    }
      
    TACTIC BetaInteractionEquivalent(t : Term, s : Term) -> Bool = {
      âˆƒ (r : Term) . t ->Î²Î¹* r âˆ§ s ->Î²Î¹* r
    }
      
    TACTIC Replace(t : Term, s : Term, r : Term) -> Term = {
      MATCH t WITH
      | Var(x) -> IF t = s THEN r ELSE t
      | Abs(v, t1) -> IF t = s THEN r ELSE Abs(v, Replace(t1, s, r))
      | App(t1, t2) -> IF t = s THEN r ELSE App(Replace(t1, s, r), Replace(t2, s, r))
      | Int(t1, t2) -> IF t = s THEN r ELSE Int(Replace(t1, s, r), Replace(t2, s, r))
    }
  }
    
  PROOFS {
    THEOREM ChurchRosser {
      STATEMENT:
        âˆ€ (t s1 s2 : Term) . t ->Î²Î¹ s1 âˆ§ t ->Î²Î¹ s2 => âˆƒ (r : Term) . s1 ->Î²Î¹* r âˆ§ s2 ->Î²Î¹* r
          
      PROOF:
        ASSUME (A) : âˆ€ (t t1 t2 : Term) . t ->Î²Î¹ t1 âˆ§ t ->Î²Î¹ t2
                       => âˆƒ (s : Term) . t1 ->Î²Î¹* s âˆ§ t2 ->Î²Î¹* s
        
        LET t s1 s2 : Term
        ASSUME (B) : t ->Î²Î¹ s1, (C) : t ->Î²Î¹ s2
        
        SHOW âˆƒ (r : Term) . s1 ->Î²Î¹* r âˆ§ s2 ->Î²Î¹* r {
          CASES t
          CASE Var(x):
            REWRITE ->Î²Î¹ = =Î²Î¹  
            HENCE s1 = t = s2
            LET r = t
            
          CASE Abs(v, t'):
            LET FV = FreeVars(t')
            CASES v âˆˆ FV
            CASE True:
              REWRITE ->Î²Î¹ = =Î²Î¹
              HENCE s1 = t = s2 
              LET r = t
              
            CASE False:
              REWRITE B: t ->Î²Î¹ s1 = Abs(v, t') ->Î²Î¹ Abs(v, s1')
              REWRITE C: t ->Î²Î¹ s2 = Abs(v, t') ->Î²Î¹ Abs(v, s2')  
              HAVE t' ->Î²Î¹ s1' âˆ§ t' ->Î²Î¹ s2' BY Inversion
              HAVE âˆƒ (r' : Term) . s1' ->Î²Î¹* r' âˆ§ s2' ->Î²Î¹* r' BY A
              LET r = Abs(v, r')
              
          CASE App(t1, t2):
            CASES t1, t2
            CASE t1 = Abs(v, t'), t2 = s:
              REWRITE B: t ->Î²Î¹ s1 = App(Abs(v, t'), s) ->Î² Subst(t', v, s)
              REWRITE C: t ->Î²Î¹ s2 = App(Abs(v, t'), s) ->Î² Subst(t', v, s)
              LET r = Subst(t', v, s)
              
            CASE t1 ->Î²Î¹ t1', t2 ->Î²Î¹ t2':  
              HAVE âˆƒ (r1 r2 : Term) . t1' ->Î²Î¹* r1 âˆ§ t1 ->Î²Î¹* r1 âˆ§
                                       t2' ->Î²Î¹* r2 âˆ§ t2 ->Î²Î¹* r2 BY A
              LET r = App(r1, r2)
              
          CASE Int(t1, t2):
            CASES t1, t2
            CASE t1 = Abs(v, t'), t2 = Abs(u, s):
              REWRITE B: t ->Î²Î¹ s1 = Int(Abs(v, t'), Abs(u, s)) ->Î¹ Subst(Subst(t', v, s), u, Abs(v, t'))
              REWRITE C: t ->Î²Î¹ s2 = Int(Abs(v, t'), Abs(u, s)) ->Î¹ Subst(Subst(t', v, s), u, Abs(v, t'))
              LET r = Subst(Subst(t', v, s), u, Abs(v, t'))
              
            CASE t1 ->Î²Î¹ t1', t2 ->Î²Î¹ t2':
              HAVE âˆƒ (r1 r2 : Term) . t1' ->Î²Î¹* r1 âˆ§ t1 ->Î²Î¹* r1 âˆ§ 
                                       t2' ->Î²Î¹* r2 âˆ§ t2 ->Î²Î¹* r2 BY A
              LET r = Int(r1, r2)  
        }
        
        QED
    }
      
    THEOREM TranslationTheorem {
      STATEMENT:
        âˆ€ (t s : Term) . t ->Î² s <=> Tr(t) ->Î¹ Tr(s)  
          
      PROOF:
        DEFINE Tr(t) = MATCH t WITH
                       | Var(x) -> Var(x)
                       | Abs(v, t) -> Abs(v, Tr(t))
                       | App(t, s) -> Int(Abs(x, Tr(t)), Abs(x, Tr(s))) WHERE x = FreshVar(t, s)
        
        FORWARD DIRECTION:
          ASSUME t ->Î² s
          SHOW Tr(t) ->Î¹ Tr(s) BY Induction on t {
            CASE Var(x):
              REWRITE ->Î² = =Î² 
              HENCE t = s
              THUS Tr(t) = Tr(s)
              
            CASE Abs(v, t'):
              t ->Î² s = Abs(v, t') ->Î² Abs(v, s')
              HENCE t' ->Î² s'
              IH: Tr(t') ->Î¹ Tr(s')
              REWRITE Tr(Abs(v, t')) = Abs(v, Tr(t'))
              REWRITE Tr(Abs(v, s')) = Abs(v, Tr(s'))
              HENCE Tr(t) ->Î¹ Tr(s)
              
            CASE App(t1, t2):  
              t ->Î² s = App(t1, t2) ->Î² App(s1, s2)
              CASES t1, t2
              CASE t1 = Abs(v, t'), t2 = r:
                REWRITE t ->Î² s = App(Abs(v, t'), r) ->Î² Subst(t', v, r)
                LET x = FreshVar(t', r)
                REWRITE Tr(App(Abs(v, t'), r)) 
                  = Int(Abs(x, Tr(Abs(v, t'))), Abs(x, Tr(r)))
                  = Int(Abs(x, Abs(v, Tr(t'))), Abs(x, Tr(r)))
                  ->Î¹ Subst(Subst(Tr(t'), v, Tr(r)), x, Abs(v, Tr(t')))
                  = Tr(Subst(t', v, r))
                  
              CASE t1 ->Î² s1, t2 ->Î² s2:
                IH1: Tr(t1) ->Î¹ Tr(s1)  
                IH2: Tr(t2) ->Î¹ Tr(s2)
                LET x = FreshVar(s1, s2)
                REWRITE Tr(App(t1, t2))
                  = Int(Abs(x, Tr(t1)), Abs(x, Tr(t2)))
                  ->Î¹ Int(Abs(x, Tr(s1)), Abs(x, Tr(s2)))
                  = Tr(App(s1, s2))
          }
          
        BACKWARD DIRECTION:
          ASSUME Tr(t) ->Î¹ Tr(s)
          SHOW t ->Î² s BY Induction on Tr(t) {
            CASE Var(x):
              REWRITE ->Î¹ = =Î¹
              HENCE Tr(t) = Tr(s)
              THUS t = s
              
            CASE Abs(v, Tr(t')):
              Tr(t) ->Î¹ Tr(s) = Abs(v, Tr(t')) ->Î¹ Abs(v, Tr(s'))
              HENCE Tr(t') ->Î¹ Tr(s')
              IH: t' ->Î² s'
              REWRITE t = Abs(v, t')
              REWRITE s = Abs(v, s')
              HENCE t ->Î² s
              
            CASE Int(Abs(x, Tr(t1)), Abs(x,