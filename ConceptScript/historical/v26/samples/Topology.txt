CONCEPT Topology {
  LANGUAGE { 
    TYPE Point
    TYPE Set[T] = Point -> Bool
    TYPE Topology = Set[Set[Point]]
    TYPE Metric(X : Set[Point]) = (Point, Point) -> â„
    
    PRED Open[X](S : Set[Point], Ï„ : Topology[X]) = S âˆˆ Ï„
    PRED Closed[X](S : Set[Point], Ï„ : Topology[X]) = X \ S âˆˆ Ï„  
    PRED Dense[X](S : Set[Point], Ï„ : Topology[X]) = âˆ€ (U : Set[Point]) . Open[X](U, Ï„) => (U âˆ© S â‰  âˆ…)
    PRED Connected[X](Ï„ : Topology[X]) = âˆ€ (U V : Set[Point]) . 
      (Open[X](U, Ï„) âˆ§ Open[X](V, Ï„) âˆ§ (U âˆª V = X) âˆ§ (U âˆ© V = âˆ…)) => (U = âˆ… âˆ¨ V = âˆ…)
    PRED Compact[X](K : Set[Point], Ï„ : Topology[X]) = 
      âˆ€ (ğ“¤ : Set[Set[Point]]) . 
        (âˆ€ (U : Set[Point]) . U âˆˆ ğ“¤ => Open[X](U, Ï„)) => 
          (âˆ€ (x : Point) . x âˆˆ K => (âˆƒ (U : ğ“¤) . x âˆˆ U)) =>
            (âˆƒ (ğ“¤' : FiniteSubset(ğ“¤)) . âˆ€ (x : Point) . x âˆˆ K => (âˆƒ (U : ğ“¤') . x âˆˆ U))
  }

  TRANSFORMERS {
    FUNC DiscreteTopology[X](X : Set[Point]) : Topology[X] = Powerset(X)
    FUNC FiniteComplement[X](Ï„ : Topology[X]) : Topology[X] = {U : Set[Point] | X \ U âˆˆ Ï„}  
    FUNC TopologyFromBasis[X](ğ“‘ : Set[Set[Point]]) : Topology[X] = 
      {U : Set[Point] | âˆ€ (x : Point) . x âˆˆ U => (âˆƒ (B : ğ“‘) . x âˆˆ B âŠ† U)}
    FUNC TopologyFromSubbasis[X](ğ“¢ : Set[Set[Point]]) : Topology[X] =
      TopologyFromBasis({â‹‚ ğ“• | ğ“• : FiniteSubset(ğ“¢)})
    FUNC MetricTopology[X](d : Metric[X]) : Topology[X] =  
      {U : Set[Point] | âˆ€ (x : U) . âˆƒ (Îµ : â„âº) . âˆ€ (y : Point) . d(x,y) < Îµ => y âˆˆ U}
  }
    
  PROOFS { 
    THEOREM OpenSetsUnionIsOpen {
      STATEMENT:
        âˆ€ (X : Set[Point])  
          (Ï„ : Topology[X])
          (ğ“¤ : Set[Set[Point]]) .
        (âˆ€ (U : Set[Point]) . U âˆˆ ğ“¤ => Open[X](U, Ï„)) => Open[X](â‹ƒ ğ“¤, Ï„)
        
      PROOF:
        ASSUME (ğ“¤ : Set[Set[Point]]), (âˆ€ (U : ğ“¤) . Open[X](U, Ï„))
        
        Open[X](â‹ƒ ğ“¤, Ï„)
          <=> â‹ƒ ğ“¤ âˆˆ Ï„  
          <=> (* By definition of topology *)
              âˆ€ (A B : ğ“¤) . A âˆª B âˆˆ Ï„
          <=> (* By inductive generalization *)  
              âˆ€ (ğ“• : FiniteSubset(ğ“¤)) . â‹ƒ ğ“• âˆˆ Ï„
          <== (* By assumed antecedent *)
              TRUE
              
        QED
    }
      
    THEOREM ClosedSetsFiniteIntersectionIsClosed {
      STATEMENT:  
        âˆ€ (X : Set[Point])
          (Ï„ : Topology[X])
          (A B : Set[Point]) .
        Closed[X](A, Ï„) âˆ§ Closed[X](B, Ï„) => Closed[X](A âˆ© B, Ï„)
        
      PROOF:
        ASSUME Closed[X](A, Ï„), Closed[X](B, Ï„)
        
        HAVE X \ A âˆˆ Ï„, X \ B âˆˆ Ï„  by definition of Closed
        
        (X \ A) âˆª (X \ B) 
          = X \ (A âˆ© B)
          âˆˆ Ï„            by OpenSetsUnionIsOpen
          
        THEREFORE Closed[X](A âˆ© B, Ï„) 
        
        QED
    }
      
    THEOREM CompactImpliesClosed {
      STATEMENT:
        âˆ€ (X : Set[Point])
          (Ï„ : Topology[X]) 
          (K : Set[Point]) .
        Compact[X](K, Ï„) => Closed[X](K, Ï„)
        
      PROOF:
        ASSUME Compact[X](K, Ï„)
        SUFFICES Open[X](X \ K, Ï„)
        
        LET ğ“¤ = {X \ {x} | x âˆˆ K}
        
        âˆ€ (U : ğ“¤) {
          U = X \ {x}   for some x âˆˆ K
            âˆˆ Ï„         since {x} is closed
        }
        
        âˆ€ (x : Point) . x âˆˆ K => (âˆƒ (U : ğ“¤) . x âˆˆ U)
          TAKE U = X \ {x}
          
        HAVE âˆƒ (ğ“¤' : FiniteSubset(ğ“¤)) . âˆ€ (x : Point) . x âˆˆ K => (âˆƒ (U : ğ“¤') . x âˆˆ U)
          by Compact[X](K, Ï„)
        
        TAKE ğ“¤' = {Uâ‚, ..., Uâ‚™} 
        
        X \ K 
          = X \ â‹‚ {X \ U | U âˆˆ ğ“¤'}  
          = â‹ƒ ğ“¤'
          âˆˆ Ï„ by OpenSetsUnionIsOpen
        
        QED
    }
  }
}