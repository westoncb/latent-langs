CONCEPT InteractionCombinators {
  LANGUAGE {
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, â„•)
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])

    FUNC Arity(s: Symbol): â„•
    FUNC Interaction(a: Symbol, b: Symbol): Maybe[Net]
    PRED Reduced(n: Net): ğ”¹

    AXIOM PortCount {
      âˆ€ (s: Symbol) (c: Cell) (ps: List[Port]) .
        (c = (s, ps)) => Length(ps) = Arity(s) + 1
    }

    AXIOM PortDistinct {
      âˆ€ (c: Cell) (ps: List[Port]) (i: â„•) (j: â„•) .
        ((c, ps) âˆˆ Net âˆ§ (c, i) âˆˆ ps âˆ§ (c, j) âˆˆ ps âˆ§ i â‰  j) => (c, i) â‰  (c, j)
    }

    AXIOM Symmetry {
      âˆ€ (a: Symbol) (b: Symbol) (Î±: Net) (Î²: Net) .
        Interaction(a, b) = Î± âˆ§ Interaction(b, a) = Î² => Î± = Flip(Î²)
    }

    AXIOM Determinism {
      âˆ€ (a: Symbol) (b: Symbol) (Î±: Net) (Î²: Net) .
        Interaction(a, b) = Î± âˆ§ Interaction(a, b) = Î² => Î± = Î²
    }
  }

  NOTATION {
    + --S--> & = Net + reduces to Net & in system S
    + --*S--> & = Net + reduces to Net & in zero or more steps in system S
    + --IC--> & = Net + reduces to Net & in the Interaction Combinators system
    + --*IC--> & = Net + reduces to Net & in zero or more steps in the Interaction Combinators system
    ğ’¯(S, T) = The set of translations from interaction system S to interaction system T
    <x â†¦ y>z = Substitution of x with y in z
  }

  STRUCTURE InteractionSystem {
    PARAM alphabet: Set[Symbol]
    PARAM rules: Map[(Symbol, Symbol), Net]

    REQUIRE âˆ€ ((a, b) â†¦ Î±) âˆˆ rules . a âˆˆ alphabet âˆ§ b âˆˆ alphabet âˆ§ Reduced(Î±)
    REQUIRE âˆ€ (a: Symbol) (b: Symbol) . (a âˆˆ alphabet âˆ§ b âˆˆ alphabet) => ((a, b) âˆˆ rules.Keys âˆ¨ (b, a) âˆˆ rules.Keys)
  }

  TRANSFORMERS {
    TACTIC Substitution(+: Net, c: Cell, ?: Net) -> Net = {
      MATCH + WITH
      | ({c} âˆª cs, ps, ws) -> (cs âˆª ?.Cells, <c â†¦ ?.Ports>ps, <c â†¦ ?.Wires>ws)
    }
  }

  PROOFS {
    THEOREM ChurchRosser {
      STATEMENT:
        âˆ€ (S: InteractionSystem) (+: Net) .
          (+ --*S--> &1 âˆ§ + --*S--> &2) => (âˆƒ !: Net . &1 --*S--> ! âˆ§ &2 --*S--> !)

      PROOF:
        LET S: InteractionSystem, +: Net
        ASSUME +1: + --*S--> &1, +2: + --*S--> &2

        HAVE LocalConfluence := âˆ€ (.: Net) .
          (. --S--> .1 âˆ§ . --S--> .2) => (âˆƒ !: Net . .1 --S--> ! âˆ§ .2 --S--> !)

        SHOW âˆƒ (!: Net) . &1 --*S--> ! âˆ§ &2 --*S--> !:
          REWRITE &1
            = .1 --S--> ... --S--> /1
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> /2
          HAVE /1 = /2 BY Induction, LocalConfluence
          
        SHOW !: ! = &1 --*S--> ? âˆ§ &2 --*S--> ?:
          REWRITE &1
            = .1 --S--> ... --S--> !
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> !

          ASSUME &1 --*S--> ?1, &2 --*S--> ?2

          REWRITE ?1
            = ! --S--> ... --S--> ?1
          REWRITE ?2
            = ! --S--> ... --S--> ?2

          HAVE ?1 = ?2 BY Induction, Determinism
        
        QED
    }

    THEOREM TranslationTheorem {
      STATEMENT:
        âˆ€ (S: InteractionSystem) .
          âˆƒ (T: ğ’¯(S, InteractionCombinatorsSystem)) . FaithfullyRepresents(T)

      PROOF:
        LET S: InteractionSystem
        LET (C, D, E, #p, #q, $p, $q) := InteractionCombinatorsSystem.alphabet

        DEFINE ğ’¯: ğ’¯(S, InteractionCombinatorsSystem) {
          ON a: S.alphabet
            DEFINE ğ’¯(a) := TreeOf(CodesOf({& | (a, b) â†¦ & âˆˆ S.rules}))
          ON +: Net
            DEFINE ğ’¯(+) := <a â†¦ ğ’¯(a)>+ 
        }

        SHOW Equivariant(ğ’¯):
          LET +: Net, &: Net, + --S--> &
          SHOW ğ’¯(+) --*IC--> ğ’¯(&) USING DecodingSimulation

        SHOW Reduced(ğ’¯(+)) <=> Reduced(+) USING DecodingSimulation, Definitions

        HENCE FaithfullyRepresents(ğ’¯)

        QED
    }
  }
}