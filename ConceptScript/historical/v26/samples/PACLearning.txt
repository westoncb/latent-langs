CONCEPT PACLearning {
  LANGUAGE {
    TYPE Instance
    TYPE Label
    TYPE Hypothesis = Instance -> Label
    TYPE Concept = Instance -> Label  
    TYPE Dataset = List[(Instance, Label)]
    
    FUNC Accuracy(h : Hypothesis, c : Concept, D : Distribution[Instance]) : ‚Ñù
    FUNC Agree(h : Hypothesis, c : Concept, x : Instance) : ùîπ
    
    AXIOM AccuracyDef: ‚àÄ (h : Hypothesis) (c : Concept) (D : Distribution[Instance]) .
      Accuracy(h, c, D) = Exp_{x ~ D} Agree(h, c, x)
        
    PRED PAC(L : Concept -> Hypothesis, 
             ùúñ : ‚Ñù, Œ¥ : ‚Ñù, m : ‚Ñï,
             Train : Dataset -> Hypothesis,
             C : Concept) =
      ‚àÄ (D : Distribution[Instance]) .
        Pr_{S ~ D^m} [Accuracy(Train(S), C, D) > 1 - ùúñ] > 1 - Œ¥
  }
  
  NOTATION {
    "Pr[X]" = Probability of event X
    "Exp_D[X]" = Expected value of X over distribution D 
    "D^m" = Product distribution; m iid samples from D
    "S ~ D" = S is a random sample from distribution D
  }

  STRUCTURE Definitions {  
    DEF Learner(C : Set[Concept], 
               Train : Dataset -> Hypothesis, 
               m : Instance -> ‚Ñù,
               ùúñ : ‚Ñù, Œ¥ : ‚Ñù) = {
      ‚àÄ (c : C) . ‚àÉ (m_0 : ‚Ñï) . ‚àÄ (m > m_0) . PAC(Train, ùúñ, Œ¥, m, c)                
    }

    DEF SampleComplexity(C : Set[Concept],
                         ùúñ : ‚Ñù, Œ¥ : ‚Ñù,
                         L : Concept -> Hypothesis, 
                         Train : Dataset -> Hypothesis) : ‚Ñï =
      MIN {m : ‚Ñï | ‚àÄ (c : C) . PAC(L, ùúñ, Œ¥, m, Train, c)}
        
    PRED FinitelyLearnable(C : Set[Concept]) = 
      ‚àÉ (L : Concept -> Hypothesis) 
        (Train : Dataset -> Hypothesis)
        (m : (‚Ñù, ‚Ñù) -> ‚Ñï) .
      ‚àÄ (ùúñ > 0) (Œ¥ > 0) . 
        Learner(C, Train, (Œª ùúñ Œ¥ . m(ùúñ, Œ¥)), ùúñ, Œ¥)
        
    PRED EfficientlyLearnable(C : Set[Concept]) =
      FinitelyLearnable(C) ‚àß
      SampleComplexity(C) is polynomial in 1/ùúñ, 1/Œ¥, Dim(C) ‚àß
      Train is polynomial-time computable
  }

  PROOFS {
    THEOREM FiniteClassPAC {
      STATEMENT:
        ‚àÄ (C : FiniteSet[Concept]) . FinitelyLearnable(C)
          
      PROOF:
        LET C : FiniteSet[Concept],
            ùúñ Œ¥ : ‚Ñù, 
            D : Distribution[Instance],
            m = ‚åà(ln |C| + ln (1/Œ¥)) / ùúñ‚åâ
        
        DEF L(c) = c  // Hypotheses are just the concepts
        DEF Train(S) = argmin_{c ‚àà C} ùö∫_{(x,y) ‚àà S} ùüô[c(x) ‚â† y] 
        
        HAVE VC-Dim(C) ‚â§ log‚ÇÇ|C| by Sauer-Shelah Lemma
        
        ‚àÄ (c : C) {
          Pr_{S ~ D^m} [Accuracy(Train(S), c, D) ‚â§ 1-ùúñ] 
              ‚â§ Pr [‚àÉ (h : C) . Accuracy(h, c, D) ‚â§ 1-ùúñ ‚àß h = Train(S)] 
              ‚â§ ùö∫_{h ‚àà C} Pr [Accuracy(h, c, D) ‚â§ 1-ùúñ ‚àß h = Train(S)]
              ‚â§ |C| exp(-ùúñ¬≤m) 
                BY Chernoff Bound, Union Bound
              ‚â§ Œ¥ 
                BY choice of m
        }

        THEREFORE Learner(C, Train, (Œª _ _ . m), ùúñ, Œ¥)
        THEREFORE FinitelyLearnable(C)
        
        QED
    }
      
    THEOREM NoFreeLunch {
      STATEMENT:
        ‚àÄ (A : Set[Instance]) 
          (B : Set[Label]) 
          (m > |B|) .
        ‚àÄ (L : Concept -> Hypothesis)
          (Train : Dataset -> Hypothesis) .
        ‚àÉ (C : Set[Concept])
          (D : Distribution[Instance]) . 
          (‚àÄ (S : Dataset) . |S| = m 
            => Exp_{c ~ Uniform(C)} Exp_{x ~ D} ùüô[Train(S)(x) = c(x)] = 1/|B|)
            
      PROOF:
        ASSUME |A| = n, |B| = k
        LET C = ALL Functions A -> B
        LET D = Uniform(A)
        
        ‚àÄ (S : Dataset) . |S| = m {
          LET X = {x : A | (x,_) ‚àâ S}  // Unobserved instances
          
          ‚àÄ (b : B^X) . ‚àÉ (c : C) . 
            (‚àÄ (x,y) ‚àà S . c(x) = y) ‚àß 
            (‚àÄ (x : X) . c(x) = b[x])
        } 
        THEREFORE |C_S| = k^(n-m) where C_S = {c : C | ‚àÄ (x,y) ‚àà S . c(x) = y}  
        
        LET h = Train(S) 
        Exp_{c ~ Uniform(C)} Exp_{x ~ D} ùüô[h(x) = c(x)]
          = Exp_{x ~ D} Exp_{c ~ Uniform(C)} ùüô[h(x) = c(x)]
          = Exp_{x ~ D} [IF (x,_) ‚àà S THEN 1 ELSE 1/k]
          = m/n * 1 + (n-m)/n * 1/k
          = m/n + (n-m)/(nk)
          = 1/k + m/(nk) * (k-1)
          ‚â§ 1/k + m/n * (k-1)/k
          ‚â§ 1/k + (k-1)/k since m ‚â§ n
          = 1/k + 1 - 1/k
          = 1
          
        QED
    }
  }  
}