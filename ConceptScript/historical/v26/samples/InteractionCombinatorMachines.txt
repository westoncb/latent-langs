CONCEPT InteractionCombinatorMachines {
  LANGUAGE {
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, â„•)
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])
    TYPE Tape = List[Symbol]
    TYPE State
    TYPE Direction = {Left, Right, Stay}
    TYPE MachineConfig = (State, Tape, â„•)
    TYPE TransitionFunc = State -> Symbol -> (State, Symbol, Direction)
    TYPE Machine = (State, Symbol, TransitionFunc, State, State)
    
    FUNC Arity : Symbol -> â„•
    FUNC Interaction : (Symbol, Symbol) -> Maybe[Net]
    PRED Reduced : Net -> ð”¹
    FUNC Blank : Symbol
    FUNC Encode : Net -> Tape
    FUNC Decode : Tape -> Net
    FUNC InitialConfig(M : Machine, input : Tape) : MachineConfig
    FUNC Step(M : Machine, c : MachineConfig) : MachineConfig
    FUNC Run(M : Machine, input : Tape) : Tape
    PRED Halts(M : Machine, input : Tape) = 
      âˆƒ (n : â„•) (c : MachineConfig) . Step^n(M, InitialConfig(M, input)) = c âˆ§ c.State = M.HaltState
    
    AXIOM PortCountIC {
      âˆ€ (s : Symbol) (c : Cell) (ps : List[Port]) . 
        (c = (s, ps)) => Length(ps) = Arity(s) + 1
    }
    
    AXIOM PortDistinctIC {
      âˆ€ (c : Cell) (ps : List[Port]) (i j : â„•) . 
        ((c, ps) âˆˆ Net âˆ§ (c, i) âˆˆ ps âˆ§ (c, j) âˆˆ ps âˆ§ i â‰  j) => (c, i) â‰  (c, j)
    }
    
    AXIOM NetEncoding {
      âˆ€ (Î± : Net) . Decode(Encode(Î±)) = Î±
    }
  }
  
  NOTATION {
    "+ --M-> &" = "MachineConfig + transitions to MachineConfig & in Machine M"
    "+ --*M--> &" = "MachineConfig + transitions to MachineConfig & in Machine M in zero or more steps"
    "M âŠ¨ t" = "Machine M halts on input Tape t"
    "M âŠ­ t" = "Machine M does not halt on input Tape t"
  }
  
  TRANSFORMERS {
    TACTIC NetToMachine(Î± : Net) -> Machine = {
      LET start : State, halt : State, q_i : State[Î±.Cells.Length]
      LET f(q)(s) = {
        MATCH (q, s) WITH
        | (start, Blank) -> (q_i[0], Blank, Right)
        | (q_i[i], s_i) -> IF âˆƒ (c_j) . Interaction(s_i, c_j.Symbol) = Some(Î±_ij)
                           THEN (q_i[j], Encode(Î±_ij)[0], Stay)
                           ELSE (halt, Blank, Stay)
        | (halt, _) -> (halt, Blank, Stay)
      }
      (start, Blank, f, start, halt)
    }
    
    TACTIC MachineToNet(M : Machine) -> Net = {
      LET init <- Decode(Run(M, [])) 
      LET explore(Î±) = {
        LET nexts = {Î±' | âˆƒ (c : Î±.Cells) (c' : Cell) . 
                            Interaction(c.Symbol, c'.Symbol) = Some(Î±') âˆ§ 
                            Encode(Î±') âˆˆ Run(M, Encode(Î±))}
        Î± âˆª â‹ƒ (Map(explore, nexts))
      }
      explore(init)
    }
  }
  
  STRUCTURE ICMachine {
    M : Machine
    Î±_init : Net
    
    REQUIRE Decode(Run(M, [])) = Î±_init
    REQUIRE âˆ€ (Î± Î±' : Net) . 
      (Î± âŠ† MachineToNet(M) âˆ§ Î± --IC--> Î±') => Î±' âŠ† MachineToNet(M)
  }
  
  PROOFS {
    THEOREM ICMachineEmulation {
      STATEMENT:
        âˆ€ (Î± : Net) . âˆƒ (M : ICMachine) . 
          (Î± --*IC--> Î±' => M.Î±_init --*IC--> Î±') âˆ§
          (M.Î±_init --*IC--> Î±' => âˆƒ (n : â„•) . Î± --IC-->^n Î±')
      
      PROOF:
        LET Î± : Net
        LET M : ICMachine = (NetToMachine(Î±), Î±)
        
        SHOW Î± --*IC--> Î±' => M.Î±_init --*IC--> Î±' {
          ASSUME (H) : Î± --*IC--> Î±'
          REWRITE Î±' âŠ† MachineToNet(M) BY H, M.REQUIRE[1]
          HENCE M.Î±_init --*IC--> Î±'
        }
        
        SHOW M.Î±_init --*IC--> Î±' => âˆƒ (n : â„•) . Î± --IC-->^n Î±' {
          ASSUME (H) : M.Î±_init --*IC--> Î±'
          
          LET P(Î±) = âˆƒ (n : â„•) . Î±_init --IC-->^n Î±
          
          SHOW P(Î±') BY Induction on H {
            CASE Î±' = Î±_init:
              TAKE n = 0
            CASE Î±' = Î±_k --IC--> Î±_{k+1}:
              ASSUME (IH) : P(Î±_k)
              REWRITE IH 
                = âˆƒ (n : â„•) . Î±_init --IC-->^n Î±_k
              HENCE âˆƒ (n+1 : â„•) . Î±_init --IC-->^(n+1) Î±_{k+1}
          }
          
          HENCE âˆƒ (n : â„•) . Î± --IC-->^n Î±'
        }
        
        QED
    }
    
    THEOREM ICMachineHalting {
      STATEMENT:
        âˆ€ (M : ICMachine) . M.M âŠ¨ Encode(M.Î±_init) <=> Reduced(M.Î±_init)
        
      PROOF:
        LET M : ICMachine
        
        SHOW M.M âŠ¨ Encode(M.Î±_init) => Reduced(M.Î±_init) {
          ASSUME (H) : M.M âŠ¨ Encode(M.Î±_init)
          
          REWRITE H
            = âˆƒ (n : â„•) (c : MachineConfig) . 
                Step^n(M.M, InitialConfig(M.M, Encode(M.Î±_init))) = c âˆ§ 
                c.State = M.M.HaltState
          
          LET c = Step^n(M.M, InitialConfig(M.M, Encode(M.Î±_init)))
          LET Î±_n = Decode(c.Tape)
          
          HAVE InitialConfig(M.M, Encode(M.Î±_init)).Tape = Encode(M.Î±_init)
          HENCE Step^n(M.M, InitialConfig(M.M, Encode(M.Î±_init))).Tape = Encode(Î±_n)
            BY NetEncoding
          HENCE Î±_n âŠ† MachineToNet(M.M)
          
          ASSUME (H1) : Î±_n --IC--> Î±' 
          REWRITE H1
            = âˆƒ (c' : Cell) . Interaction(c.Symbol, c'.Symbol) = Some(Î±')
          HENCE Encode(Î±') âˆˆ Run(M.M, Encode(Î±_n))
          HENCE Step^m(M.M, c) = c_m âˆ§ c_m.Tape = Encode(Î±') for some m
          HENCE c_m.State â‰  M.M.HaltState
          HENCE Contradiction
          
          THEREFORE Î±_n --IC-/-> 
          HENCE Reduced(Î±_n)
          HENCE Reduced(M.Î±_init) BY ICMachineEmulation
        }
        
        SHOW Reduced(M.Î±_init) => M.M âŠ¨ Encode(M.Î±_init) {
          ASSUME (H) : Reduced(M.Î±_init)
          
          LET P(Î±) = Reduced(Î±) => (âˆƒ (n : â„•) . 
            Step^n(M.M, InitialConfig(M.M, Encode(Î±))).State = M.M.HaltState)
            
          SHOW P(M.Î±_init) BY Induction on Î± {
            CASE Î± = M.Î±_init:
              REWRITE H 
                = âˆ€ (c : Cell) . Â¬âˆƒ (Î±' : Net) . 
                    Interaction(M.Î±_init.Cells[0].Symbol, c.Symbol) = Some(Î±')
              LET c_0 = InitialConfig(M.M, Encode(M.Î±_init))
              REWRITE Step(M.M, c_0) 
                = (M.M.HaltState, Blank, Stay) BY H
              HENCE âˆƒ (1 : â„•) . Step^1(M.M, c_0).State = M.M.HaltState
            CASE Î± = Î±_k --IC--> Î±_{k+1}:
              ASSUME (IH) : P(Î±_k)
              ASSUME (H2) : Reduced(Î±_{k+1})
              LET c_k = Step^n(M.M, InitialConfig(M.M, Encode(Î±_k))) 
                where n is from IH
              REWRITE Step(M.M, c_k)
                = (q_i[j], Encode(Î±_{k+1})[0], Stay) 
                  where Î±_k.Cells[i] --IC--> Î±_{k+1}.Cells[j]
                BY H2
              HENCE âˆƒ (n+1 : â„•) . 
                Step^(n+1)(M.M, InitialConfig(M.M, Encode(Î±_{k+1}))).State = M.M.HaltState
                BY IH
          }
          
          HENCE P(M.Î±_init)
          HENCE M.M âŠ¨ Encode(M.Î±_init)
        }
        
        QED
    }
  }
}

This Concept, called InteractionCombinatorMachines, combines ideas from the InteractionCombinators and UniversalTuringMachine Concepts. The key idea is to define a notion of Machines that can simulate Interaction Nets, and conversely to map Interaction Nets to equivalent Machines.

The LANGUAGE block includes types and functions from both InteractionCombinators (Symbols, Cells, Ports, Nets, Interaction rules) and UniversalTuringMachine (Tapes, States, Machines, configurations, running Machines). It also defines predicates about Nets being reduced and Machines halting.

The TRANSFORMERS provide ways to convert between Interaction Nets and Machines. NetToMachine takes an Interaction Net and constructs a Machine that simulates its reductions. MachineToNet takes a Machine and produces the Interaction Net that is the union of all the Nets encoded on the tape when running the Machine.

The ICMachine STRUCTURE represents a Machine together with an initial Interaction Net, and requires that running the machine simulates reduction on that Net.

The PROOFS show two key theorems:
1) ICMachineEmulation states that for any Net, we can construct an ICMachine whose initial Net reduces in the same way. 
2) ICMachineHalting shows that the constructed Machine halts iff the initial Net is reduced.

Together, these theorems establish a tight correspondence between Interaction Nets and Machines, showing that Interaction Nets can be simulated by Machines, and that Machines can be mapped to equivalent Interaction Nets.






CONCEPT InteractionCombinatorMachines {
  LANGUAGE {
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, â„•)
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])
    
    TYPE State
    TYPE Direction = {Left, Right, Stay}
    TYPE Tape = List[Symbol]
    TYPE Head = â„•
    TYPE Configuration = (State, Tape, Head)
    TYPE TransitionFunction = State -> Symbol -> (State, Symbol, Direction)
    TYPE ICMachine = (State, Symbol, TransitionFunction, State, State, Net)
    
    FUNC Blank : Symbol
    FUNC StartState[M : ICMachine] : State 
    FUNC HaltState[M : ICMachine] : State
    FUNC Transition[M : ICMachine] : TransitionFunction
    FUNC InteractionNet[M : ICMachine] : Net
    FUNC InitialConfig[M : ICMachine](input : Tape) : Configuration
    FUNC Step[M : ICMachine](c : Configuration) : Configuration
    FUNC Run[M : ICMachine](input : Tape) : Tape
    FUNC Halt[M : ICMachine](c : Configuration) : ð”¹
    FUNC Accepts[M : ICMachine](input : Tape) : ð”¹

    AXIOM UniqueHalt {
      âˆ€ (M : ICMachine) (c c' : Configuration) .
        (Halt[M](c) âˆ§ Halt[M](c') âˆ§ Step[M](c) = c') => c = c'
    }
  }

  NOTATION {
    "(q, s) -> (p, t, d)" = Transition[M](q)(s) = (p, t, d)
    "M âŠ¢ c1 -> c2" = Step[M](c1) = c2
    "M âŠ¢* c1 ->! c2" = Halt[M](c2) âˆ§ (âˆƒ (n : â„•) . (M âŠ¢)^n (c1) = c2)
    "Î± --M--> Î²" = InteractionNet[M] reduces from Î± to Î² in machine M
    "Î± --*M--> Î²" = InteractionNet[M] reduces from Î± to Î² in zero or more steps in machine M
  }

  TRANSFORMERS {
    FUNC NextConfig[M : ICMachine](c : Configuration) -> Configuration = {
      LET (q, tape, pos) = c
      LET (q', s', d) = Transition[M](q)(tape[pos])
      LET tape' = tape with [pos := s']
      LET pos' = match d with {
        Left => pos - 1,
        Right => pos + 1, 
        Stay => pos
      }
      (q', tape', pos')
    }
    
    PROC RunICM[M : ICMachine](input : Tape) -> Tape = {
      LET c = InitialConfig[M](input)
      LET Î± = InteractionNet[M]
      WHILE not Halt[M](c):
        c := Step[M](c)
        Î± := SOME Î² . (Î± --M--> Î²) 
      RETURN c.Tape
    }

    TACTIC Simulation(M : ICMachine, input : Tape) = {
      LET c = InitialConfig[M](input)
      LET Î± = InteractionNet[M]
      SHOW âˆ€ (n : â„•) . (M âŠ¢)^n (c) = Simulate[M, Î±, n] BY {
        INDUCTION on n
        CASE 0: 
          REWRITE (M âŠ¢)^0 (c) = c
          REWRITE Simulate[M, Î±, 0] = c
        CASE n+1:
          ASSUME (H) : (M âŠ¢)^n (c) = Simulate[M, Î±, n]
          REWRITE (M âŠ¢)^(n+1) (c) = M âŠ¢ ((M âŠ¢)^n (c))
                                   = M âŠ¢ Simulate[M, Î±, n] BY H
                                   = Simulate[M, Î±, n+1] BY InteractionReduction
      }
      HENCE Run[M](input) = FinalState(Simulate[M, Î±, âˆž])
    }
  }

  STRUCTURE Translation {
    DEF Encode[M : TuringMachine] : ICMachine = {
      LET initial = some initial net wiring the TM configuration
      (M.States, M.Symbols, EncodeTransition[M.Transition], 
       M.StartState, M.HaltState, initial)
    }
    
    DEF EncodeTransition(t : TransitionFunction) = 
      Î» (q : State) (s : Symbol) . 
        LET (q', s', d) = t(q)(s)
        LET c' = (q', [s'], [Port(Left), Port(Right)])
        (q', s', match d with {
                   Left => Connect(0, c'), 
                   Right => Connect(1, c'),
                   Stay => Connect(0, c') âˆ§ Connect (1, c')
                 })
        
    DEF Decode[M : ICMachine] : TuringMachine = (
      M.States, M.Symbols, DecodeTransition[M.Transition],
      M.StartState, M.HaltState  
    )
      
    DEF DecodeTransition(t : TransitionFunction) =
      Î» (q : State) (s : Symbol) .
        LET (q', s', p) = t(q)(s)
        (q', s', match (p[0].Cell, p[1].Cell) with {
                   (Left, _) => Left,
                   (_, Right) => Right,
                   _ => Stay
                 })
  }
  
  PROOFS {
    THEOREM SimulationTheorem {
      STATEMENT:
        âˆ€ (M : TuringMachine) (input : Tape) .
          Run[M](input) = Run[Encode[M]](input)
            
      PROOF:
        LET M : TuringMachine, input : Tape
        LET T = Encode[M]
        
        SHOW Run[M](input) = Run[T](input) BY Simulation(T, input)
        
        QED
    }
      
    THEOREM TranslationCorrectness {
      STATEMENT:
        âˆ€ (M : ICMachine) . Encode[Decode[M]] = M
          
      PROOF:
        LET M : ICMachine
        
        SUFFICES_TO_SHOW Decode[Encode[Decode[M]]] = Decode[M]
        
        LET M' = Decode[M]
        REWRITE Decode[Encode[M']]
          = (M'.States, M'.Symbols, DecodeTransition[EncodeTransition[M'.Transition]], 
             M'.StartState, M'.HaltState)
             
        SHOW DecodeTransition[EncodeTransition[M'.Transition]] = M'.Transition BY {
          LET t = M'.Transition
          LET q : State, s : Symbol
          
          REWRITE DecodeTransition[EncodeTransition[t]](q)(s)
            = LET (q', s', p) = EncodeTransition[t](q)(s)
              (q', s', match (p[0].Cell, p[1].Cell) with {
                         (Left, _) => Left,
                         (_, Right) => Right, 
                         _ => Stay
                       })
            = LET (q', s', d) = t(q)(s)  
              LET c' = (q', [s'], [Port(Left), Port(Right)])
              LET p = match d with {
                        Left => Connect(0, c'),
                        Right => Connect(1, c'),
                        Stay => Connect(0, c') âˆ§ Connect (1, c') 
                      }
              (q', s', match (p[0].Cell, p[1].Cell) with {
                         (Left, _) => Left,
                         (_, Right) => Right,
                         _ => Stay  
                       })
            = (q', s', d)
            = t(q)(s)
        }
          
        HENCE Decode[Encode[Decode[M]]] = Decode[M]
        
        QED
    }
  }
}





CONCEPT InteractionCombinatorMachines {
  LANGUAGE {
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, â„•)
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])
    TYPE State
    TYPE Transition = (State, Symbol, State)
    TYPE ICMachine = (State, Symbol, Set[Transition], State, State)
    
    FUNC Arity : Symbol -> â„•
    FUNC Interaction : (Symbol, Symbol) -> Maybe[Net]
    FUNC Blank : Symbol
    FUNC StartState[M : ICMachine] : State
    FUNC HaltState[M : ICMachine] : State
    FUNC Transitions[M : ICMachine] : Set[Transition]
    FUNC InitialNet[M : ICMachine](input : List[Symbol]) : Net
    FUNC Reduce[M : ICMachine](n : Net) : Net
    FUNC Run[M : ICMachine](input : List[Symbol]) : Net
    FUNC Halt[M : ICMachine](n : Net) : ð”¹
    
    AXIOM UniqueLabels {
      âˆ€ (M : ICMachine) (q p : State) (a b : Symbol) .
        ((q, a, p) âˆˆ Transitions[M] âˆ§ (q, b, p) âˆˆ Transitions[M]) => a = b
    }
  }
  
  NOTATION {
    "M âŠ¢ n1 ~> n2" = Reduce[M](n1) = n2
    "M âŠ¢* n1 ~>! n2" = Halt[M](n2) âˆ§ (âˆƒ (k : â„•) . (M âŠ¢)^k (n1) = n2)
  }
  
  TRANSFORMERS {
    FUNC NextNet[M : ICMachine](n : Net) -> Net = {
      LET (cs, ps, ws) = n
      LET qs = {q | âˆƒ (c : Cell) . c âˆˆ cs âˆ§ c.Symbol = q}
      LET ts = {(q, a, p) | (q, a, p) âˆˆ Transitions[M] âˆ§ q âˆˆ qs âˆ§ a âˆˆ Alphabet(cs)}
      LET rs = {Interaction(a, b) | ((q1, a, _), (q2, b, _)) âˆˆ ts Ã— ts âˆ§ Interaction(a, b) â‰  âˆ…}
      LET n' = FoldL(rs, n, Î» n' r . Substitution(n', r.Cells, r))
      IF âˆƒ (c : Cell) . c âˆˆ n'.Cells âˆ§ c.Symbol = HaltState[M] THEN n' ELSE NextNet[M](n')
    }
    
    PROC RunICM[M : ICMachine](input : List[Symbol]) -> Net = {
      LET n = InitialNet[M](input)
      WHILE not Halt[M](n):
        n := Reduce[M](n)
      RETURN n
    }
  }
  
  STRUCTURE ICMachine {
    states : Set[State]
    alphabet : Set[Symbol]
    transitions : Set[Transition]
    startState : State
    haltState : State
    
    REQUIRE startState âˆˆ states
    REQUIRE haltState âˆˆ states
    REQUIRE âˆ€ ((q, a, p) : Transition) âˆˆ transitions . q âˆˆ states âˆ§ p âˆˆ states âˆ§ a âˆˆ alphabet
  }
  
  PROOFS {
    THEOREM ICMTuringEquivalence {
      STATEMENT:
              âˆ€ (f : List[Symbol] -> List[Symbol]) . Computable(f) <=>
        âˆƒ (M : ICMachine) . âˆ€ (input : List[Symbol]) . 
          Serialize(Run[M](input)) = f(input)
          
      PROOF:
        ASSUME (H1) : Computable(f)
        
        LET M : TuringMachine = WitnessFor(H1)
        LET I : ICMachine = ConstructICM(M)
        
        SHOW âˆ€ (input : List[Symbol]) . Serialize(Run[I](input)) = f(input) BY {
          LET input : List[Symbol]
          LET tapes_M = Run[M](input)
          LET net_I = Run[I](input)
          
          REWRITE Serialize(net_I)
            = Serialize(InitialNet[I](input) ~>! HaltNet[I]) 
            = input BY SimulationLemma[M, I]
            = tapes_M BY WitnessProperty(H1)
            = f(input)
        }
        
        HENCE âˆƒ (M : ICMachine) . âˆ€ (input : List[Symbol]) . 
                Serialize(Run[M](input)) = f(input)
        
        CONVERSELY, ASSUME (H2) : âˆƒ (M : ICMachine) . âˆ€ (input : List[Symbol]) . 
                                    Serialize(Run[M](input)) = f(input)
        
        LET I : ICMachine = WitnessFor(H2)
        LET M : TuringMachine = ConstructTM(I)
        
        SHOW Computable(f) BY {
          SUFFICES_TO_SHOW âˆ€ (input : List[Symbol]) . Run[M](input) = f(input)
          
          LET input : List[Symbol]
          LET net_I = Run[I](input)
          LET tapes_M = Run[M](input)
          
          REWRITE tapes_M
            = Serialize(InitialNet[I](input) ~>! HaltNet[I]) BY SimulationLemma[I, M]  
            = Serialize(net_I) BY WitnessProperty(H2)
            = f(input)
        }
        
        THEREFORE Computable(f) <=> âˆƒ (M : ICMachine) . âˆ€ (input : List[Symbol]) . 
                                       Serialize(Run[M](input)) = f(input)
        
        QED
    }
  }
}