CONCEPT NeuralInteractionNetwork {
  LANGUAGE {
    TYPE Neuron
    TYPE Synapse = (Neuron, Neuron, â„)  -- (source, target, weight)
    TYPE NeuralNet = (Set[Neuron], Set[Synapse])
    
    FUNC Activate : Neuron -> â„ -> â„
    FUNC Forward(net : NeuralNet, input : â„^n) : â„^m
    FUNC Backward(net : NeuralNet, input : â„^n, output : â„^m, target : â„^m) : NeuralNet
    
    PRED Trained : NeuralNet -> ð”¹
  }

  NOTATION {
    "+" = "Interaction between neurons"
    "Net --Fwd--> *" = "Neural net reduces via forward pass to output"
    "f âˆ˜ g" = compose(f, g)
  }
  
  TRANSFORMERS {
    TACTIC Optimize(net : NeuralNet) -> NeuralNet = SGD(net)
    
    REWRITE Forward(net, input) = Foldr[[n1, n2] -> n2 âˆ˜ Activate(n1)](net.Neurons, input)

    REWRITE Backward(net, input, output, target) 
          = Foldl[[s1, s2] -> UpdateWeights(s2, Î´(s1))](net.Synapses, output - target) 
  }
      
  STRUCTURE NeuralInteractions {
    DEF Interaction(n1 : Neuron, n2 : Neuron) : NeuralNet = {
      LET w_init = RandomWeight()
      ({n1, n2}, {(n1, n2, w_init)})  
    }

    DEF Reduction(net : NeuralNet) : NeuralNet = {
      LET (neurons, synapses) = net
      LET active = {n | n âˆˆ neurons, Activate(n) > 0}
      LET new_syns = {Interaction(pre, post) | pre âˆˆ active, post âˆˆ neurons}
      (neurons, synapses âˆª new_syns)
    }
      
    DEF Eq(net1 net2 : NeuralNet) : net1 = net2 = {
      LET iso1 : net1.Neurons -> net2.Neurons
      LET iso2 : net1.Synapses -> net2.Synapses
      âˆ€ (n1 n2 : Neuron) . (n1, n2, w) âˆˆ net1.Synapses <=> (iso1(n1), iso2(n2), w) âˆˆ net2.Synapses
    }
  }
    
  PROOFS {
    THEOREM Universality {
      STATEMENT:  
        âˆ€ (f : â„^n -> â„^m) . âˆƒ (net : NeuralNet) . Trained(net) âˆ§ (âˆ€ (input : â„^n) . Forward(net, input) = f(input))
          
      PROOF:
        LET f : â„^n -> â„^m

        DEF net_f : NeuralNet = {
          LET init_net = CreateNetworkStructure(n, m)
          FixedPoint(init_net, [net => Optimize(Backward(net, input, Forward(net, input), f(input)))])
        }

        SHOW Trained(net_f) BY {
          LET (neurons, synapses) = net_f
          âˆ€ (s : Synapse) . s âˆˆ synapses => Converged(s.weight) BY def. of FixedPoint
        }

        SHOW âˆ€ (input : â„^n) . Forward(net_f, input) = f(input) BY {
          LET output = Forward(net_f, input)
          output = f(input) BY def. of Backward, def. of FixedPoint
        }
          
        QED
    }

    THEOREM InteractionEvolution {
      STATEMENT:  
        âˆ€ (net_0 net_t : NeuralNet) . net_0 --*Fwd--> net_t => âˆƒ (p : net_0 = net_t) . p âˆˆ PathSpace(NeuralNetSpace, net_0, net_t) 
      
      PROOF:
        LET net_0 net_t : NeuralNet, net_0 --*Fwd--> net_t
          
        DEF path(step : â„•) : NeuralNet = Reduction^step(net_0)
          
        SHOW âˆ€ (step : â„•) . path(step) = Reduction(path(step-1)) BY def. of Iterate
        SHOW path(0) = net_0 âˆ§ âˆƒ (t : â„•) . path(t) = net_t BY def. of path, --*Fwd-->
          
        LET p : net_0 = net_t = FunctorialPath([step => Eq(path(step), path(step+1))])
          
        SHOW p âˆˆ PathSpace(NeuralNetSpace, net_0, net_t) BY def. of PathSpace, def. of Eq
          
        QED  
    }
  }
}

This Concept defines a NeuralInteractionNetwork, a type of neural network architecture where new connections (synapses) between neurons can form dynamically during the forward pass based on which neurons activate. The key ideas are:

The network is defined as a set of neurons and synapses, similar to an interaction net in the Interaction Combinators model.
During the forward pass, new synapses are added between all active neurons and all other neurons, allowing the network topology to evolve.
The Reduction function defines a single iteration of this interactional forward pass. Multiple reductions form an evolutionary path in the space of neural nets.
Training the network involves finding a fixpoint of iterated backward passes that minimize the output error. The Universality theorem states that this training process can approximate any function.
Inspired by Homotopy Type Theory, the InteractionEvolution theorem shows that the sequential reductions of the network form a path in the space of neural networks connecting the initial and final network states. This provides a topological perspective on the network's evolution during inference.

The core novelty is using dynamic interaction rules to evolve the network topology during inference, and analyzing this evolution through the lens of homotopy theory.