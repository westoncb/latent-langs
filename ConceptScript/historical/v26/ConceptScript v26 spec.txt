Here is the specification for the ConceptScript language, version 26:

ConceptScript v26

<Concept> ::= "CONCEPT" <ConceptName> ["[" <Params> "]"] [":" <ParentConcepts>] "{"
               <Language>
               <Notation>?
               <Transformers>?
               <Structure>*
               <Proofs>?
             "}"
<Language> ::= "LANGUAGE" "{"
                 (<TypeDecl> | <ConstDecl> | <FuncDecl> | <PredDecl> | 
                  <AxiomDecl>)*
               "}"
<TypeDecl> ::= "TYPE" <TypeName> ["[" <Params> "]"] ["<:" <TypeName>] "=" <Type>
<Type> ::= <TypeName> ["(" <Type> ("," <Type>)* ")"]
         | "(" <Type> ("," <Type>)* ")"
         | <Type> "->" <Type>
         | <Type> "|" <Type>
<ConstDecl> ::= "CONST" <ConstName> ":" <Type>
<FuncDecl> ::= "FUNC" <FuncName> ["[" <Params> "]"] ":" <Type>
<PredDecl> ::= "PRED" <PredName> ["[" <Params> "]"] ":" <Type>
<AxiomDecl> ::= "AXIOM" <AxiomName> ["[" <Params> "]"] ":" <Formula>
<Notation> ::= "NOTATION" "{"
                  <NotationDecl>*
               "}"
<NotationDecl> ::= <Notation> "=" <Pattern>

<Transformers> ::= "TRANSFORMERS" "{"
                     (<TransformerDecl>)*
                   "}"
<TransformerDecl> ::= <FuncDef> | <ProcDef> | <TacticDef> | <RewriteDef>
<FuncDef> ::= "FUNC" <FuncName> ["[" <Params> "]"] "=" <Expression>
<ProcDef> ::= "PROC" <ProcName> ["[" <Params> "]"] "=" <Expression>
<TacticDef> ::= "TACTIC" <TacticName> ["[" <Params> "]"] "=" <Expression>
<RewriteDef> ::= "REWRITE" <Pattern> "=" <Expression>

<Structure> ::= "STRUCTURE" <StructureName> ["[" <Params> "]"] ["EXTENDS" <ParentStructures>] "{"
                  (<LetDecl> | <DefDecl> | <Requirement>)*
                "}"
<LetDecl> ::= "LET" <Pattern> [":" <Type>] "=" <Expression>
<DefDecl> ::= "DEF" <Pattern> [":" <Type>] "=" <Expression> ["WHERE" <Constraint>]
<Requirement> ::= "REQUIRE" <Expression>
<Pattern> ::= <Identifier>
            | "(" <Pattern> ("," <Pattern>)* ")"
            | <Pattern> ":" <Type>
<Proofs> ::= "PROOFS" "{"
               (<TheoremDecl>)*
             "}"
<TheoremDecl> ::= "THEOREM" <TheoremName> ["[" <Params> "]"] "{"
                    "STATEMENT" ":" <Formula>
                    "PROOF" ":" <Proof>
                  "}"
<Proof> ::= <ProofStep> (";" <ProofStep>)*
<ProofStep> ::= <LetStep> 
              | <HaveStep>
              | <ShowStep>
              | <ByStep>
              | <QedStep>
<LetStep> ::= "LET" <Pattern> [":" <Type>] "=" <Expression>
<HaveStep> ::= "HAVE" <Formula> ["BY" <TacticApp>]
<ShowStep> ::= "SHOW" <Formula>
<ByStep> ::= "BY" <TacticApp>
<QedStep> ::= "QED"
<TacticApp> ::= <TacticName> ["[" <Params> "]"]


And here are a few example Concepts:

CONCEPT InteractionCombinators {
  LANGUAGE {
    TYPE Symbol
    TYPE Cell = (Symbol, List[Port])
    TYPE Port = (Cell, ‚Ñï)
    TYPE Net = (Set[Cell], Set[Port], Set[(Port, Port)])

    FUNC Arity(s: Symbol): ‚Ñï
    FUNC Interaction(a: Symbol, b: Symbol): Maybe[Net]
    PRED Reduced(n: Net): ùîπ

    AXIOM PortCount {
      ‚àÄ (s: Symbol) (c: Cell) (ps: List[Port]) .
        (c = (s, ps)) => Length(ps) = Arity(s) + 1
    }

    AXIOM PortDistinct {
      ‚àÄ (c: Cell) (ps: List[Port]) (i: ‚Ñï) (j: ‚Ñï) .
        ((c, ps) ‚àà Net ‚àß (c, i) ‚àà ps ‚àß (c, j) ‚àà ps ‚àß i ‚â† j) => (c, i) ‚â† (c, j)
    }

    AXIOM Symmetry {
      ‚àÄ (a: Symbol) (b: Symbol) (Œ±: Net) (Œ≤: Net) .
        Interaction(a, b) = Œ± ‚àß Interaction(b, a) = Œ≤ => Œ± = Flip(Œ≤)
    }

    AXIOM Determinism {
      ‚àÄ (a: Symbol) (b: Symbol) (Œ±: Net) (Œ≤: Net) .
        Interaction(a, b) = Œ± ‚àß Interaction(a, b) = Œ≤ => Œ± = Œ≤
    }
  }

  NOTATION {
    + --S--> & = Net + reduces to Net & in system S
    + --*S--> & = Net + reduces to Net & in zero or more steps in system S
    + --IC--> & = Net + reduces to Net & in the Interaction Combinators system
    + --*IC--> & = Net + reduces to Net & in zero or more steps in the Interaction Combinators system
    ùíØ(S, T) = The set of translations from interaction system S to interaction system T
    <x ‚Ü¶ y>z = Substitution of x with y in z
  }

  STRUCTURE InteractionSystem {
    PARAM alphabet: Set[Symbol]
    PARAM rules: Map[(Symbol, Symbol), Net]

    REQUIRE ‚àÄ ((a, b) ‚Ü¶ Œ±) ‚àà rules . a ‚àà alphabet ‚àß b ‚àà alphabet ‚àß Reduced(Œ±)
    REQUIRE ‚àÄ (a: Symbol) (b: Symbol) . (a ‚àà alphabet ‚àß b ‚àà alphabet) => ((a, b) ‚àà rules.Keys ‚à® (b, a) ‚àà rules.Keys)
  }

  TRANSFORMERS {
    TACTIC Substitution(+: Net, c: Cell, ?: Net) -> Net = {
      MATCH + WITH
      | ({c} ‚à™ cs, ps, ws) -> (cs ‚à™ ?.Cells, <c ‚Ü¶ ?.Ports>ps, <c ‚Ü¶ ?.Wires>ws)
    }
  }

  PROOFS {
    THEOREM ChurchRosser {
      STATEMENT:
        ‚àÄ (S: InteractionSystem) (+: Net) .
          (+ --*S--> &1 ‚àß + --*S--> &2) => (‚àÉ !: Net . &1 --*S--> ! ‚àß &2 --*S--> !)

      PROOF:
        LET S: InteractionSystem, +: Net
        ASSUME +1: + --*S--> &1, +2: + --*S--> &2

        HAVE LocalConfluence := ‚àÄ (.: Net) .
          (. --S--> .1 ‚àß . --S--> .2) => (‚àÉ !: Net . .1 --S--> ! ‚àß .2 --S--> !)

        SHOW ‚àÉ (!: Net) . &1 --*S--> ! ‚àß &2 --*S--> !:
          REWRITE &1
            = .1 --S--> ... --S--> /1
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> /2
          HAVE /1 = /2 BY Induction, LocalConfluence
          
        SHOW !: ! = &1 --*S--> ? ‚àß &2 --*S--> ?:
          REWRITE &1
            = .1 --S--> ... --S--> !
          REWRITE &2
            = .1 --S--> ... --S--> /k --S--> ... --S--> !

          ASSUME &1 --*S--> ?1, &2 --*S--> ?2

          REWRITE ?1
            = ! --S--> ... --S--> ?1
          REWRITE ?2
            = ! --S--> ... --S--> ?2

          HAVE ?1 = ?2 BY Induction, Determinism
        
        QED
    }

    THEOREM TranslationTheorem {
      STATEMENT:
        ‚àÄ (S: InteractionSystem) .
          ‚àÉ (T: ùíØ(S, InteractionCombinatorsSystem)) . FaithfullyRepresents(T)

      PROOF:
        LET S: InteractionSystem
        LET (C, D, E, #p, #q, $p, $q) := InteractionCombinatorsSystem.alphabet

        DEFINE ùíØ: ùíØ(S, InteractionCombinatorsSystem) {
          ON a: S.alphabet
            DEFINE ùíØ(a) := TreeOf(CodesOf({& | (a, b) ‚Ü¶ & ‚àà S.rules}))
          ON +: Net
            DEFINE ùíØ(+) := <a ‚Ü¶ ùíØ(a)>+ 
        }

        SHOW Equivariant(ùíØ):
          LET +: Net, &: Net, + --S--> &
          SHOW ùíØ(+) --*IC--> ùíØ(&) USING DecodingSimulation

        SHOW Reduced(ùíØ(+)) <=> Reduced(+) USING DecodingSimulation, Definitions

        HENCE FaithfullyRepresents(ùíØ)

        QED
    }
  }
}

CONCEPT LambdaCalculus {
  LANGUAGE {
    TYPE Term
    TYPE Variable <: Term
    TYPE Abstraction <: Term
    TYPE Application <: Term

    FUNC Var(name: String): Variable
    FUNC Abs(v: Variable, body: Term): Abstraction
    FUNC App(func: Term, arg: Term): Application

    FUNC FreeVars(t: Term): Set[Variable]
    FUNC BoundVars(t: Term): Set[Variable]
    FUNC Subterms(t: Term): Set[Term]
    FUNC Subst(t: Term, v: Variable, s: Term): Term

    PRED FreeFor(v: Variable, t: Term, s: Term) = ¬¨‚àÉ (u: FreeVars(s)) . u ‚àà BoundVars(t)
    PRED Reduces(t: Term, s: Term)
    PRED Equivalent(t: Term, s: Term) = Reduces(t, s) ‚àß Reduces(s, t)
  }

  NOTATION {
    Œª v . t = Abs(Var(v), t)
    t s = App(t, s)
    t [v := s] = Subst(t, v, s)
    t ->Œ≤ s = BetaReduces(t, s)
    t =Œ≤ s = BetaEquivalent(t, s)
  }

  TRANSFORMERS {
    REWRITE FreeVars(Var(x)) = {Var(x)}
    REWRITE FreeVars(Abs(v, t)) = FreeVars(t) \ {v}
    REWRITE FreeVars(App(t, s)) = FreeVars(t) ‚à™ FreeVars(s)

    REWRITE BoundVars(Var(x)) = {}
    REWRITE BoundVars(Abs(v, t)) = {v} ‚à™ BoundVars(t)
    REWRITE BoundVars(App(t, s)) = BoundVars(t) ‚à™ BoundVars(s)

    REWRITE Subterms(Var(x)) = {Var(x)}
    REWRITE Subterms(Abs(v, t)) = {Abs(v, t)} ‚à™ Subterms(t)
    REWRITE Subterms(App(t, s)) = {App(t, s)} ‚à™ Subterms(t) ‚à™ Subterms(s)

    REWRITE Subst(Var(x), v, s) = IF v = Var(x) THEN s ELSE Var(x)
    REWRITE Subst(Abs(v, t), u, s) = IF v = u THEN Abs(v, t)
                                     ELSE IF FreeFor(v, t, s) THEN Abs(v, Subst(t, u, s))
                                     ELSE LET w = FreshVar(v, t, s) IN
                                       Abs(w, Subst(Subst(t, v, Var(w)), u, s))
    REWRITE Subst(App(t1, t2), v, s) = App(Subst(t1, v, s), Subst(t2, v, s))

    FUNC FreshVar(v: Variable, t: Term, s: Term) -> Variable {
      LET used = FreeVars(t) ‚à™ FreeVars(s)
      LET x = v.name
      LET x' = x
      WHILE Var(x') ‚àà used:
        x' := x + "'"
      RETURN Var(x')
    }

    TACTIC BetaReduces(t: Term, s: Term) -> Bool {
      MATCH t WITH
      | App(Abs(v, t1), t2) -> IF FreeFor(v, t1, t2) THEN
                                 s = Subst(t1, v, t2)
                               ELSE
                                 LET w = FreshVar(v, t1, t2),
                                     t1' = Subst(t1, v, Var(w))
                                 IN s = Subst(t1', w, t2)
      | _ -> ‚àÉ (t': Subterms(t)) . t' ->Œ≤ s' ‚àß Replace(t, t', s') = s
    }

    TACTIC BetaEquivalent(t: Term, s: Term) -> Bool {
      ‚àÉ (r: Term) . t ->Œ≤* r ‚àß s ->Œ≤* r
    }
  }

  STRUCTURE Church {
    DEF I = Œª x . x
    DEF K = Œª x . Œª y . x
    DEF S = Œª x . Œª y . Œª z . x z (y z)
    DEF Zero = Œª f . Œª x . x
    DEF Succ = Œª n . Œª f . Œª x . f (n f x)
    DEF Plus = Œª m . Œª n . Œª f . Œª x . m f (n f x)
    DEF Mult = Œª m . Œª n . Œª f . m (n f)
    DEF Pow = Œª m . Œª n . n m
    DEF True = Œª t . Œª f . t
    DEF False = Œª t . Œª f . f
    DEF And = Œª p . Œª q . p q p
    DEF Or = Œª p . Œª q . p p q
    DEF Not = Œª p . p False True
    DEF IfThenElse = Œª p . Œª a . Œª b . p a b
    DEF Pair = Œª f . Œª s . Œª b . b f s
    DEF Fst = Œª p . p True
    DEF Snd = Œª p . p False
    DEF Pred = Œª n . Œª f . Œª x . n (Œª g . Œª h . h (g f)) (Œª u . x) I
    DEF Sub = Œª m . Œª n . n Pred m
    DEF IsZero = Œª n . n (Œª x . False) True
    DEF UnsignedLess = Œª m . Œª n . IsZero (Sub m n)
    DEF SignedLess = Œª m . Œª n . Or (And (IsNeg m) (Not (IsNeg n)))
                                    (And (Not (IsNeg m))
                                         (Not (IsNeg n))
                                         (UnsignedLess m n))
    DEF IsNeg = Œª n . Fst n
    DEF Neg = Œª n . Pair True n
    DEF UnsignedMinus = Œª m . Œª n . IF IsNeg m THEN
                                      IF IsNeg n THEN
                                        Sub (Snd n) (Snd m)
                                      ELSE
                                        Neg (Add (Snd m) n)
                                    ELSE
                                      IF IsNeg n THEN
                                        Add m (Snd n)
                                      ELSE
                                        Sub m n
  }

  PROOFS {
    THEOREM ChurchRosser {
      STATEMENT:
        ‚àÄ (t s1 s2: Term) . t ->Œ≤ s1 ‚àß t ->Œ≤ s2 => ‚àÉ (r: Term) . s1 ->Œ≤* r ‚àß s2 ->Œ≤* r

      PROOF:
        ASSUME (A): ‚àÄ (t t1 t2: Term) . t ->Œ≤ t1 ‚àß t ->Œ≤ t2
                       => ‚àÉ (s: Term) . t1 ->Œ≤* s ‚àß t2 ->Œ≤* s

        LET t: Term, s1: Term, s2: Term
        ASSUME (B): t ->Œ≤ s1, (C): t ->Œ≤ s2

        SHOW ‚àÉ (r: Term) . s1 ->Œ≤* r ‚àß s2 ->Œ≤* r:
          MATCH t WITH
          | Var(x):
            REWRITE ->Œ≤ = =Œ≤
            HENCE s1 = t = s2
            LET r = t

          | Abs(v, t'):
            LET FV = FreeVars(t')
            MATCH v ‚àà FV WITH
            | True:
              REWRITE ->Œ≤ = =Œ≤
              HENCE s1 = t = s2
              LET r = t

            | False:
              REWRITE B: t ->Œ≤ s1 = Abs(v, t') ->Œ≤ Abs(v, s1')
              REWRITE C: t ->Œ≤ s2 = Abs(v, t') ->Œ≤ Abs(v, s2')
              HAVE t' ->Œ≤ s1' ‚àß t' ->Œ≤ s2' BY Inversion
              HAVE ‚àÉ (r': Term) . s1' ->Œ≤* r' ‚àß s2' ->Œ≤* r' BY A
              LET r = Abs(v, r')

          | App(t1, t2):
            MATCH (t1, t2) WITH
            | (Abs(v, t'), s):
              REWRITE B: t ->Œ≤ s1 = App(Abs(v, t'), s) ->Œ≤ Subst(t', v, s)
              REWRITE C: t ->Œ≤ s2 = App(Abs(v, t'), s) ->Œ≤ Subst(t', v, s)
              LET r = Subst(t', v, s)

            | _:
              HAVE ‚àÉ (r1 r2: Term) . t1 ->Œ≤* r1 ‚àß t2 ->Œ≤* r2 BY A
              LET r = App(r1, r2)

        QED
    }

    THEOREM FixedPointCombinator {
      STATEMENT:
        ‚àÉ (Y: Term) . ‚àÄ (f: Term) . (Y f) =Œ≤ (f (Y f))

      PROOF:
        LET A = Œª x . f (x x)
        LET Y = Œª f . (Œª x . f (x x)) (Œª x . f (x x))
          = Œª f . A A

        SHOW (Y f) =Œ≤ (f (Y f)):
          (Y f)
            = (Œª f . A A) f
            ->Œ≤ (A A) [f := f]
            = (Œª x . f (x x)) (Œª x . f (x x))
            ->Œ≤ f ((Œª x . f (x x)) (Œª x . f (x x)))
            = f (Y f)

        QED
    }

    THEOREM ChurchNumeralCorrect {
      STATEMENT:
        ‚àÄ (n: ‚Ñï) (f: Term -> Term) (x: Term) . (ToChurch(n) f x) =Œ≤ (f^n x)

      PROOF:
        BY Induction on n
        BASE CASE: n = 0
          REWRITE ToChurch(0) = Œª f . Œª x . x
          SHOW (ToChurch(0) f x) = ((Œª f . Œª x . x) f x) ->Œ≤ x = (f^0 x)

        INDUCTIVE CASE:
          IH: (ToChurch(n) f x) =Œ≤ (f^n x)
          SHOW (ToChurch(n+1) f x) =Œ≤ (f^(n+1) x):
            REWRITE ToChurch(n+1) = Œª f . Œª x . f (ToChurch(n) f x)
            (ToChurch(n+1) f x)
              = ((Œª f . Œª x . f (ToChurch(n) f x)) f x)
              ->Œ≤ f (ToChurch(n) f x)
              =Œ≤ f (f^n x) BY IH
              = (f^(n+1) x)

        QED
    }
  }
}

- The LANGUAGE block allows you to define the formal elements in which you'll express structures, transformers, and proofs
- The NOTATION block allows you to define more efficient ways of expressing your LANGUAGE
- The TRANSFORMERS block allows you to define computational and logical tools to aid in expressing structures and proofs
- The PROOFS block allows is self-explanatory; sometimes I'll request particular theorems, otherwise you select them.

ConceptScript is a language of a new type: it's sole intended purpose is to be used in accordance with the following methodology:

1. I paste the spec and a few example Concepts into your context (as is happening now), thus teaching you the language.
2. I request that you express various concepts as Concepts; these Concepts come with detailed proofs of their own various claims; they serve as justifications of the selected structuring.
3. We iterate, precisely and efficiently exploring your latent space to solve a wide variety of important problems.

Please always output ConceptScript in a code block otherwise formatting gets lost :/

Alright, let's check your understanding of the language and system: please express a Concept in as much detail as possible in someway relating to, combining, or inspired by the foregoing examples.