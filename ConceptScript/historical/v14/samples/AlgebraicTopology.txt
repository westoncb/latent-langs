CONCEPT AlgebraicTopology {
  LANGUAGE {
    type Top = Space | Map | Homotopy
    type Alg = Group | Ring | Module | Algebra | Operad
    
    type Space = {
      Point,
      Disk(n: â„•), 
      Sphere(n: â„•), 
      Torus(g: â„•),
      KleinBottle,
      ProjectivePlane(â„ | â„‚ | â„)
    }
    
    type Map = Continuous(X: Space, Y: Space)
    
    notation "f: X -> Y" = Map(X, Y)
    notation "f âˆ˜ g" = Compose(f: Map, g: Map)
    notation "id_X" = Identity(X: Space)
    notation "H: f â‰ƒ g" = Homotopy(f: Map, g: Map)
    
    type ChainComplex = Sequence(C: Graded(Module), d: Differential(C))
    notation "Câ€¢" = ChainComplex
    notation "Hn(Câ€¢)" = Homology(Câ€¢: ChainComplex, n: â„¤)
    
    pred ModelFor(A: Alg, X: Space) 
    notation "A âŠ§ X" = ModelFor(A, X)
  }

  STRUCTURE {
    HomotopyInvariance: {
      f â‰ƒ g â‡’ f*: Hn(X) -> Hn(Y) = g*  ; Homotopic maps induce equal homomorphisms
    }
    
    HomologicalAlgebra: {
      X: Space âŠ§ C(X): ChainComplex   ; Singular chain complex
      Hn(C(X)) = Hn(X)                ; Homology of space
      (f: X -> Y) âŠ§ (f#: C(X) -> C(Y)) ; Induced chain map
    }

    AlgebraicModels: {
      Sphere(n) âŠ§ Algebra(Generator[n], Relations[x^2 = 0])
      Torus(g) âŠ§ ExteriorAlgebra(Generator[aâ‚...a_g, bâ‚...b_g])
      KleinBottle âŠ§ Algebra(Generator[a, b], Relations[a^2 = b^2, ab = -ba]) 
      X simply connected â‡’ ðœ‹â‚(X) âŠ§ Group(Presentation(X))
      ðœ‹*(X) âŠ§ Operad   ; Homotopy groups form an operad
    }
  }

  PROOFS {
    notation "Sn" = Sphere(n: â„•)
    notation "Dn" = Disk(n: â„•)
    
    tactic Exact(C: ChainComplex):
      (C exact) âŠ¢ (Hn(C) = 0 for n â‰  0)

    tactic CellularApproximation(f: Map, X: Space, Y: Space):
      (X, Y CW complexes) âŠ¢ (âˆƒ g â‰ƒ f cellular)

    theorem PoincareLemma(U âŠ† â„^n: Space):
      U contractible â‡’ Hn(U) = 0 for n > 0
    {
      have Dn contractible
      have Hn(Dn) = 0 for n > 0  ; Homology of disk
      let Ï†: U â‰ƒ Dn              ; Contraction 
      have Ï†*: Hn(U) = Hn(Dn)    ; Homotopy invariance
      hence Hn(U) = 0 for n > 0
    }
    
    theorem HomotopyInvariantHomology(f, g: Map, X, Y: Space):  
      f â‰ƒ g âŠ¢ f* = g*: Hn(X) -> Hn(Y)
    {
      assume f â‰ƒ g
      get H: f â‰ƒ g  ; Homotopy between maps
      H: X Ã— I -> Y             ; Homotopy as map
      Hn(X Ã— I) = Hn(X)         ; Homotopy invariance of homology  
      have H#: Hn(X Ã— I) -> Hn(Y)  ; Induced map on homology
      have f# = H#|_0, g# = H#|_1   ; Restrict to endpoints
      hence f* = H#|_0 = H#|_1 = g* ; Composition equality
    }
    
    theorem CellularHomology(X: Space):
      X CW complex âŠ¢ Hn(X) = Hn(Cellular(X))
    {
      assume X CW complex
      let i: Cellular(X) â†ª X             ; Inclusion of cellular chains
      CellularApproximation(id_X, X, X)   
      get g â‰ƒ id_X cellular
      have g âˆ˜ i â‰ƒ id, i âˆ˜ g â‰ƒ id        ; Homotopy equivalences
      have (g âˆ˜ i)* = id*, (i âˆ˜ g)* = id* ; Homotopy invariance
      hence i* iso, so Hn(X) = Hn(Cellular(X))      
    }

    theorem HopfInvariant(f: SÂ³ -> SÂ²):
      deg(f) = Hopf(f)   ; Degree equals Hopf invariant 
    {
      SÂ² âŠ§ A = Algebra(x, [xÂ²=0])    ; Algebraic model for SÂ²
      have C(SÂ³) = (0 -> â„¤ -> 0)     ; Cellular chain complex
      f#: C(SÂ³) -> C(A)              ; Induced chain map
      f#[eÂ³] = f*[SÂ³] = d(f#[eÂ³])    ; Fundamental class
      f*[SÂ³] = deg(f) x              ; Representing cocycle
      have f#[eÂ³] in Ker(d) = â„¤ x    ; Cycles are scalar multiples
      Hopf(f) := coefficient of x in f#[eÂ³]
      hence deg(f) = Hopf(f)
    }
  }
}




CONCEPT AlgebraicTopology {
  LANGUAGE {
    type TopologicalSpace = {points: Point*, neighborhoods: Point -> PowerSet(Point)*}
    type Point = Primitive
    type OpenSet = PowerSet(Point)

    type Chain(S: TopologicalSpace, n: â„•) = FormalSum(S.points^(n+1), ð•€)
    type Boundary(S: TopologicalSpace, n: â„•) = LinearMap(Chain(S, n), Chain(S, n-1))

    notation "Z(S, n)" = Cycles(S: TopologicalSpace, n: â„•) = Ker(âˆ‚(S, n))  ; n-cycles
    notation "B(S, n)" = Boundaries(S: TopologicalSpace, n: â„•) = Im(âˆ‚(S, n+1))  ; n-boundaries 
    notation "H(S, n)" = Homology(S: TopologicalSpace, n: â„•) = Z(S, n) / B(S, n)  ; n-th homology

    axiom PoincareLemma(S: SmoothManifold, Ï‰: DifferentialForm):  
      dÏ‰ = 0 â‡’ âˆƒÏ„. Ï‰ = dÏ„   ; Closed forms are exact
  }

  STRUCTURE {  
    [SimplicialComplex:
      {pointSet: Point*, simplices: PowerSet(pointSet)*, 
       âˆ€ Ïƒ âˆˆ simplices. Ï„ âŠ† Ïƒ â‡’ Ï„ âˆˆ simplices}
    ]

    [ChainComplex(S: TopologicalSpace):
      ...->âˆ‚(n+1)->  Chain(S, n)  ->âˆ‚(n)â†’  Chain(S, n-1)  ->âˆ‚(n-1)â†’...
      âˆ‚(n) âˆ˜ âˆ‚(n+1) = 0  ;  Boundary of a boundary is zero
    ]

    [Homomorphism(f, X, Y): 
      {X, Y: TopologicalSpace, f: X.points -> Y.points |
       âˆ€ U âˆˆ Y.neighborhoods(f(x)). âˆƒ V âˆˆ X.neighborhoods(x). f(V) âŠ† U}
      Functorial:  f_* âˆ˜ âˆ‚_X = âˆ‚_Y âˆ˜ f_*
    ]
  }

  PROOFS {
    tactic SplitExactSequence(C, D, E, i, f, g) = {
      have 0 ->iâ†’ C ->fâ†’ D ->gâ†’ E ->0â†’ 0  ; Short exact sequence
      have Im(i) = Ker(f)  ; Exactness at C
      have Im(f) = Ker(g)  ; Exactness at D
      have D = Im(f) âŠ• X    ; Splitting lemma, for some X  
    }

    theorem DeRhamTheorem(M: SmoothManifold): 
      H_dR(M) â‰… H_singular(M)  ; Isomorphism of cohomology theories
    {
      for n in ð•†(N):  ; For each dimension n
        let Ï‰ âˆˆ Z_dR(M, n)  ; Closed n-form
        PoincareLemma(M, Ï‰)  ; Ï‰ is exact
        hence Ï‰ = dÏ„ for some (n-1)-form Ï„
        have [Ï‰] = 0 in H_dR(M, n)  ; Exact forms are boundaries
        hence Z_dR(M, n) = B_dR(M, n)  ; All closed forms are exact
        hence H_dR(M, n) = 0
        
        let c âˆˆ Z_singular(M, n)  ; Singular n-cycle  
        have âˆ«_c:Z_dR(M, n) -> ð•€   ; Integration over cycles
        have Ker(âˆ«_c) = B_singular(M, n)  ; Stokes' theorem
        hence âˆ«_c induces H_dR(M, n) -> H_singular(M, n)
      
      therefore, H_dR(M) â‰… H_singular(M)
    }

    theorem MayerVietoris(X, U, V: TopologicalSpace):  
      X = U âˆª V â‡’ 
        ... -> H(Uâˆ©V, n) ->Î¦â†’ H(U, n) âŠ• H(V, n) ->Î¨â†’ H(X, n) ->Î”â†’ H(Uâˆ©V, n-1) -> ...
    {
      assume X = U âˆª V
      let A = U âˆ© V

      have 0 -> C(A, n) ->iâ†’ C(U, n) âŠ• C(V, n) ->jâ†’ C(X, n) -> 0   ; Chain complex
      SplitExactSequence(C(A, n), C(U, n) âŠ• C(V, n), C(X, n), i, j, 0)
      
      have H(X, n) â‰… H(C(X, n))  ; Homotopy invariance
      have H(U, n) âŠ• H(V, n) â‰… H(C(U, n)) âŠ• H(C(V, n))  ; Homotopy invariance 
      
      have Î¦: H(A, n) -> H(U, n) âŠ• H(V, n)  ; Induced map
      have Î¨: H(U, n) âŠ• H(V, n) -> H(X, n)  ; Induced map
      
      have Î”: H(X, n) -> H(A, n-1)  ; Connecting homomorphism
      have Im(Î”) = Ker(Î¦)  ; Exactness at H(A, n-1)  
      have Im(Î¦) = Ker(Î¨)  ; Exactness at H(U, n) âŠ• H(V, n)
      have Im(Î¨) = Ker(Î”)  ; Exactness at H(X, n)
    }
  }
}