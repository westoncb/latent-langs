CONCEPT ComputationalPhysicalCorrespondence {
  LANGUAGE {
    type Comp = Program | Circuit | AutomataType(ùìù: ‚Ñï) | TuringMachine | Lambda(ùì£: Type)
    type Phys = System | Process | Dynamics | Field(ùìú: Manifold, ùì•: VectorSpace)
    type Corr = Realize(Comp, Phys) | Implement(Comp, Phys)

    notation "C ‚áí P" = Realize(C: Comp, P: Phys)
    notation "C ‚ä® P" = Implement(C: Comp, P: Phys)
    notation "‚ü¶C‚üß" = Semantics(C: Comp)
    notation "ùìî(P)" = Evolution(P: Phys)
    notation "Init(P)" = InitialState(P: Phys)
    notation "ùìí(P)" = Observables(P: Phys)
  }

  STRUCTURE {
    ComputationalComplexity(C: Comp): {
      Time(C): ‚Ñï,
      Space(C): ‚Ñï
    }

    PhysicalComplexity(P: Phys): {
      Dimension(P): ‚Ñï,
      Interactions(P): ‚Ñï  
    }
    
    ComputationalInference(C: Comp, A: Type, B: Type): {
      C ‚ä¢ A -> B   
    }

    PhysicalDeduction(P: Phys, A: ùìí(P), B: ùìí(P)): {
      P ‚ä® A ~> B  
    }
  }

  THEOREMS {
    theorem Simulation:
      ‚àÄC: Comp, P: Phys. (C ‚áí P) ->
        ‚àÄt: Time. ‚ü¶C‚üß(t) = ùìî(P)(Init(P), t)  
      
    theorem Inference:
      ‚àÄC: Comp, P: Phys. (C ‚ä® P) ->  
        ‚àÄA, B: Type. (C ‚ä¢ A -> B) ->
          ‚àÉ√Ç, BÃÇ: ùìí(P). (P ‚ä® √Ç ~> BÃÇ) ‚àß (√Ç = Encode(A)) ‚àß (BÃÇ = Encode(B))

    theorem Complexity: 
      ‚àÄC: Comp, P: Phys. (C ‚áí P) -> 
        TimeComplexity(C) = Œò(Dimension(P)) ‚àß 
        SpaceComplexity(C) = O(Interactions(P))
  }
}



CONCEPT SyntacticSemanticCorrespondence {
  LANGUAGE {
    type Syntactic
    type Semantic
    type Interpretation(Syntactic, Semantic)
    type SyntacticTransformation(Syntactic, Syntactic)
    type SemanticTransformation(Semantic, Semantic)

    notation "S ‚ä® T" = Interpretation(S: Syntactic, T: Semantic)
    notation "S1 ‚ä¢ S2" = SyntacticTransformation(S1: Syntactic, S2: Syntactic)
    notation "T1 ‚üπ T2" = SemanticTransformation(T1: Semantic, T2: Semantic)

    axiom Satisfaction(S: Syntactic, T: Semantic): (S ‚ä® T) ‚áí Truth(T)
    axiom Preservation(S1: Syntactic, S2: Syntactic, T: Semantic):
      (S1 ‚ä¢ S2) ‚àß (S1 ‚ä® T) ‚áí (S2 ‚ä® T)
  }

  STRUCTURE {
    SyntacticConsistency(S: Syntactic): ¬¨(S ‚ä¢ Contradiction)
    SemanticEntailment(T1: Semantic, T2: Semantic): (T1 ‚üπ T2) ‚áî ‚àÄS. (S ‚ä® T1) ‚áí (S ‚ä® T2)
    SoundnessCompleteness(L: Syntactic, M: Semantic): 
      ‚àÄS: L. ‚àÄT: M. (S ‚ä¢ T) ‚áî (S ‚ä® T)
  }

  PROOFS {
    theorem Satisfaction_Preservation:
      ‚àÄS1, S2: Syntactic, T: Semantic. (S1 ‚ä¢ S2) ‚àß (S1 ‚ä® T) ‚áí (S2 ‚ä® T)
    {
      assume S1, S2: Syntactic, T: Semantic, (S1 ‚ä¢ S2), (S1 ‚ä® T)
      (S2 ‚ä® T) by Preservation(S1, S2, T)
    }

    theorem SoundnessCompleteness_Consistency:
      ‚àÄL: Syntactic, M: Semantic. SoundnessCompleteness(L, M) ‚áí SyntacticConsistency(L)
    {
      assume L: Syntactic, M: Semantic, SoundnessCompleteness(L, M)
      suppose ¬¨SyntacticConsistency(L)
      let S: L such that (S ‚ä¢ Contradiction)
      (S ‚ä® Contradiction) by SoundnessCompleteness(L, M)
      SemanticEntailment(Contradiction, T) for any T
      (S ‚ä® T) for any T
      SoundnessCompleteness(L, M) fails
      contradiction
    }
  }
}