CONCEPT ProgramCFC_v1 {
  LANGUAGE {
    P := p(I,O,S,C) | P+P | P*P | P-P | P/P | P@P | P.P | âˆ‚â‚šP | âˆ«P | Î´P
    I := i(T,V) | I+I | I*I | I-I | I/I | I@I | I.I | âˆ‚áµ¢I | âˆ«I | Î´I  
    O := o(T,V) | O+O | O*O | O-O | O/O | O@O | O.O | âˆ‚â‚’O | âˆ«O | Î´O
    S := s(M,B) | S+S | S*S | S-S | S/S | S@S | S.S | âˆ‚â‚›S | âˆ«S | Î´S
    C := c(E,A) | C+C | C*C | C-C | C/C | C@C | C.C | âˆ‚â‚šC | âˆ«C | Î´C
    
    p(I,O,S,C): program with input I, output O, state S, and computation C
    i(T,V): input with type T and value V
    o(T,V): output with type T and value V  
    s(M,B): state with memory M and bindings B
    c(E,A): computation with expression E and abstraction A
    
    T := t(P,K) | T+T | T*T | T-T | T/T | T@T | T.T | âˆ‚â‚œT | âˆ«T | Î´T
    t(P,K): type with primitive P and kind K
    
    E := e(O,F,X) | E+E | E*E | E-E | E/E | E@E | E.E | âˆ‚â‚‘E | âˆ«E | Î´E
    e(O,F,X): expression with operator O, function F, and argument X
    
    A := a(T,E,S) | A+A | A*A | A-A | A/A | A@A | A.A | âˆ‚â‚A | âˆ«A | Î´A
    a(T,E,S): abstraction with type T, expression E, and scope S
    
    ğ“£{P,p} := typeof(p(I,O,S,C))
    ğ“”{P,i} := eval(P,i(T,V))
    ğ“¡{P} := run(P)
    ğ“{C,X} := apply(c(E,A),X)
    ğ“‘{P,Q} := bind(P,Q)
    
    Well{P} âŸº âˆ€pâˆˆP. âˆƒT. ğ“£{p,T}
    Total{P,I} âŸº âˆ€iâˆˆI. âˆƒoâˆˆO. ğ“”{P,i} = o  
    Deterministic{P} âŸº âˆ€iâˆˆI. ğ“¡{p(i,O,S,C)} = ğ“¡{p(i,O,S,C)}
    Terminating{P} âŸº âˆ€iâˆˆI. âˆƒn. ğ“¡{p(i,O,S,C)}â†“â‚™
    Composable{P,Q} âŸº âˆ€oâˆˆO{P}. âˆƒiâˆˆI{Q}. o = i
    
    Correct{P,Ï†} âŸº âˆ€iâˆˆI. Ï†(i, ğ“”{P,i})
    Secure{P,ğ“Ÿ} âŸº âˆ€iâˆˆI. ğ“Ÿ(ğ“¡{p(i,O,S,C)})
    Private{P,â„} âŸº âˆ€iâˆˆâ„. âˆ€oâˆˆO. ğ“”{P,i} = ğ“”{P\â„,i}
    Robust{P,Î´I} âŸº âˆ€iâˆˆI. âˆ€Î´iâˆˆÎ´I. |ğ“”{P,i} - ğ“”{P,i+Î´i}| â‰¤ Îµ(|Î´i|)
    Efficient{P,ğ“’} âŸº âˆ€iâˆˆI. ğ“’(ğ“¡{p(i,O,S,C)}) â‰¤ ğ“(f(|i|))
  } 
  
  TACTIC {
    TypeInference{P} âŠ¢ âˆ€pâˆˆP. âˆƒT. ğ“£{p,T}
    InputCoverage{P,I} âŠ¢ âˆ€iâˆˆI. âˆƒpâˆˆP. ğ“”{p,i}
    OutputCoverage{P,O} âŠ¢ âˆ€oâˆˆO. âˆƒpâˆˆP. âˆƒiâˆˆI. ğ“”{p,i} = o
    EquationalReasoning{E1,E2} âŠ¢ E1 = E2
    CaseAnalysis{P,I} âŠ¢ âˆ€iâˆˆI. ğ“”{P,i} by cases on i  
    Induction{P,I} âŠ¢ âˆ€iâˆˆI. ğ“”{P,i} by induction on i
    UniversalGeneralization{P,I,Ï†} âŠ¢ âˆ€iâˆˆI. Ï†(i, ğ“”{P,i})
    Abstraction{C,T,S} âŠ¢ âˆƒA:a(T,E,S). A = c(E,_)
    Refinement{P,I,O,Ï†} âŠ¢ âˆƒP':p(I,O,S',C'). âˆ€iâˆˆI. Ï†(i, ğ“”{P',i})
    Composition{P,Q} âŠ¢ âˆƒR:p(I{P},O{Q},S{P}Ã—S{Q},C{P}â¨¾C{Q}). R = ğ“‘{P,Q}
  }
  
  PROOF {  
    theorem Combinators {S,K,I}:
      S = a(T* -> T* -> T* -> T*, (e(.,f,x) e(.,f,y) e(.,x,z)), Global) âˆ§  
      K = a(T* -> T* -> T*, e(.,x,_), Global) âˆ§
      I = a(T* -> T*, e(.,x,x), Global) âˆ§
      âˆ€T,E. ((âˆƒS,K. E = (((S e(..,E1)) E2) E3)) âˆ¨ (âˆƒK,E1. E = (K E1)) âˆ¨ (E = I))
      âŠ¢ E = c((S K), (K E))
    {
      base case {
        I 
          = a(T* -> T*, e(.,x,x), Global)  
          = c((K I), (K I))   ; By def. of S,K
      }
      
      inductive case {
        assume ((âˆƒS,K. E = (((S e(..,E1)) E2) E3)) âˆ¨ (âˆƒK,E1. E = (K E1)))
        
        case (âˆƒK,E1. E = (K E1)):
          (K E1) 
            = ((S K) E1)   ; By S = a(T* -> T* -> T* -> T*, (e(.,f,x) e(.,f,y) e(.,x,z)), Global)
            = c((S K), (K E1))   ; By I.H. on E1
        
        case (âˆƒS,K. E = (((S e(..,E1)) E2) E3)):
          (((S e(..,E1)) E2) E3)
            = (e(..,E1,_) E2 E3)   ; By S = a(T* -> T* -> T* -> T*, (e(.,f,x) e(.,f,y) e(.,x,z)), Global) 
            = ((e(..,E1,_) E2) E3)   ; By S = a(T* -> T* -> T* -> T*, (e(.,f,x) e(.,f,y) e(.,x,z)), Global)
            = ((K (e(..,E1,_))) E2 E3)   ; By K = a(T* -> T* -> T*, e(.,x,_), Global)
            = (((S K) (e(..,E1,_))) E2 E3)   ; By S = a(T* -> T* -> T* -> T*, (e(.,f,x) e(.,f,y) e(.,x,z)), Global)
            = (((S K) E1) E2 E3)   ; By I.H. on E1  
            = c((S K), ((S K) E1 E2) E3)   ; By I.H. on (E1 E2 E3)
      }
    }
      
    theorem UntypedLambdaCalculus:  
      âˆƒT,V. âˆ€E:e(_,_,_). âˆƒA:a(T,E,_). c(E,A) âˆ§ âˆ€vâˆˆV. âˆƒT. t(v,T)
    {
      let T = T*, V = {v|âˆƒT,P,K. t(v,T) âˆ§ T = T* âˆ§ (P = p(_,_,_,_) âˆ¨ K = *)}
      
      {
        âˆ€E:e(_,_,_). âˆƒA:a(T,E,_). c(E,A) by {
          {Abstraction{E,T,S} + Combinators{S,K,I}}
        }
        âˆ€vâˆˆV. âˆƒT. t(v,T) by {
          case v:
            v âˆˆ T* -> T* -> T* -> T* âˆ§ t(v,T* -> T* -> T* -> T*)  ; Function type
            v âˆˆ T* -> T* -> T* âˆ§ t(v,T* -> T* -> T*)              ; Function type
            v âˆˆ T* -> T* âˆ§ t(v,T* -> T*)                          ; Function type  
        }
      }
    }
      
    theorem SimplyTypedLambdaCalculus:
      âˆ€T,K. âˆ€P:p(I,O,S,C). Well{P} âŠ¢ Total{P,I} âˆ§ Deterministic{P} âˆ§ Terminating{P}
    {
      assume Well{P}
      have Total{P,I} âˆ§ Deterministic{P} by {
        let T' = ğ“£{P,_}
        âˆ€iâˆˆI. âˆƒoâˆˆO. ğ“”{P,i} = o by {
          TypeInference{P} + Total{P,I}  
        }
        âˆ€iâˆˆI. ğ“¡{p(i,O,S,C)} = ğ“¡{p(i,O,S,C)} by {
          EquationalReasoning{ğ“”{P,i}, ğ“”{P,i}}  ; Uniqueness of normal form
        }
      }
      have Terminating{P} by {
        assume iâˆˆI and p(I,O,S,C)
        fix Î¼ = Î»n.Î»x.(if n = 0 then x else (Î¼ (n-1) (x+1)))
        have âˆƒn. ğ“¡{p(i,O,S,C)}â†“â‚™ by {
          Induction{Î¼,â„•} + Abstraction{C,O,âˆ…}
        }  
      }
    }
      
    theorem HoareLogic: 
      âˆ€P:p(I,O,S,C). âˆ€Ï†,Ïˆ. {Ï†} P {Ïˆ} âŠ¢ Correct{P,Ïˆ}
    {
      assume {Ï†} P {Ïˆ}
      have Correct{P,Ïˆ} by {
        âˆ€iâˆˆI. Ïˆ(i, ğ“”{P,i}) by {
          {{  
            âˆ€iâˆˆI. Ï†(i)   ; Precondition
            ğ“¡{p(i,O,S,C)}   ; Execution of P
            âˆ€oâˆˆO. Ïˆ(i,o)   ; Postcondition 
          }}
        }
      }
    }
      
    theorem SecurityTyping:
      âˆ€P:p(I,O,S,C). âˆ€ğ“Ÿ. Secure{P,ğ“Ÿ} âŠ¢ âˆ€iâˆˆI. ğ“Ÿ(ğ“¡{p(i,O,S,C)})
    {
      assume Secure{P,ğ“Ÿ} 
      have âˆ€iâˆˆI. ğ“Ÿ(ğ“¡{p(i,O,S,C)}) by {
        âˆ€iâˆˆI. ğ“Ÿ(ğ“¡{p(i,O,S,C)}) by {
          TypeInference{P} + EquationalReasoning{ğ“Ÿ(ğ“¡{p(i,O,S,C)}), ğ“Ÿ(ğ“¡{p(i,O,S,C)})}
        }  
      }
    }
  }
}





      
    theorem DifferentialPrivacy:
      âˆ€P:p(I,O,S,C). âˆ€â„,Îµ. Private{P,â„} âˆ§ (âˆ€i,i'âˆˆI. |P(i) - P(i')| â‰¤ Îµ) âŠ¢ (âˆ€oâˆˆO. |P(o|iâˆˆâ„) - P(o|iâˆ‰â„)| â‰¤ eáµ‹)
    {
      assume Private{P,â„} and âˆ€i,i'âˆˆI. |P(i) - P(i')| â‰¤ Îµ
      have âˆ€oâˆˆO. |P(o|iâˆˆâ„) - P(o|iâˆ‰â„)| â‰¤ eáµ‹ by {
        âˆ€iâˆˆâ„. âˆ€oâˆˆO. ğ“”{P,i} = ğ“”{P\â„,i} by {
          UniversalGeneralization{P,â„,Î»i,o. ğ“”{P,i} = ğ“”{P\â„,i}}  ; Privacy
        } 
        âˆ€oâˆˆO. |P(o|iâˆˆâ„) - P(o|iâˆ‰â„)| 
              = |âˆ‘{iâˆˆâ„} P(o|i) P(i) / âˆ‘{iâˆˆâ„} P(i) - âˆ‘{iâˆ‰â„} P(o|i) P(i) / âˆ‘{iâˆ‰â„} P(i)|   ; Conditional prob.
              = |âˆ‘{i} P(o|i) (1{iâˆˆâ„} P(i) / âˆ‘{