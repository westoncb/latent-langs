CONCEPT MetamaterialLanguage_v3 {
  EXTENDS MetamaterialLanguage_v2 {
    type Material = Tuple(Structure, Properties, Processes)
    type Structure = Graph(Elements, Bonds)
    type Elements = Atom | Molecule | Defect
    type Bonds = Enumeration(Ionic, Covalent, Metallic, vanDerWaals, HydrogenBond)
    
    type Properties = Field(Material, TensorRank, â„‚)
    type Processes = Flow(Properties)
    
    type MaterialManifold = Manifold(Material)
    type StructureManifold = Lie(Structure)
    type PropertyManifold = Riemannian(Properties)
    type ProcessManifold = Manifold(Processes)
    
    type StructureFlow = Flow(StructureManifold)
    type PropertyFlow = Flow(PropertyManifold)  
    type CoupledFlow = Coupling(StructureFlow, PropertyFlow)
    
    func MultiscaleDecomposition(M: Material, Îµ: Scale): Tuple(Material)
    func MaterialConnection(S: Structure, P: Properties): Connection(StructureManifold, PropertyManifold)
    
    pred IsEquivariant(F: CoupledFlow, g: Symmetry(StructureManifold))
    pred SatisfiesBalance(S: Structure, P: Properties, F_S: StructureFlow, F_P: PropertyFlow)
    pred HasCorrespondence(S: Structure, P: Properties, F: CoupledFlow)
    
    axiom StructurePropertyCoupling(S: Structure, P: Properties):
      âˆƒ F: CoupledFlow. IsEquivariant(F, â€¢) âˆ§ SatisfiesBalance(S, P, F.StructureFlow, F.PropertyFlow)
      
    axiom MultiscaleConsistency(M: Material, Îµ: Scale):  
      âˆ€ F: CoupledFlow. IsEquivariant(F, â€¢) â‡’ 
        F(M) â‰ˆ â¨_{M_i âˆˆ MultiscaleDecomposition(M, Îµ)} F(M_i)
  }
  
  PROOFS {
    tactic MultiscaleLocalization(M: Material, P: Properties, Îµ: Scale):
      âˆ€ x âˆˆ M.Geometry. LocalProperty(M, x) â‰ˆ LocalProperty(M_i, x) 
        where M_i = arg min_{M_j âˆˆ MultiscaleDecomposition(M, Îµ)} d(x, M_j.Geometry)
    {
      assume x âˆˆ M.Geometry
      let M_i = arg min_{M_j âˆˆ MultiscaleDecomposition(M, Îµ)} d(x, M_j.Geometry)
      have âˆ€ j â‰  i. d(x, M_j.Geometry) > d(x, M_i.Geometry)  ; Minimal distance to M_i
      let B_Îµ = Ball(x, Îµ) âˆ© M.Geometry  ; Îµ-ball around x
      have B_Îµ âŠ† M_i.Geometry  ; Localization at scale Îµ
      hence LocalProperty(M, x) â‰ˆ AverageProperty(M, B_Îµ) â‰ˆ LocalProperty(M_i, x)
    }
    
    tactic StructurePropertySymmetry(S: Structure, P: Properties):
      âˆ€ g: Symmetry(S). IsEquivariant(F, g) âŠ¢ F(S, P) â‰ˆ F(g(S), P)
    {
      assume g: Symmetry(S) and IsEquivariant(F, g)
      let S' = g(S)
      have F(S, P) = F(gâ»Â¹(S'), P) by applying gâ»Â¹ to S'
      = gâ»Â¹(F(S', P)) by equivariance of F
      â‰ˆ F(S', P) by applying g to both sides
    }
    
    tactic PropertyInvariance(M: Material, P: Properties, Îµ: Scale):
      (âˆ€ i,j. HasCorrespondence(M_i.Structure, M_j.Structure, F) âˆ§ SatisfiesBalance(M_i, P, â€¢)) âŠ¢
        HomogenizedProperty(M, P, Îµ) â‰ˆ HomogenizedProperty(M_i, P, Îµ)
    {
      assume âˆ€ i,j. HasCorrespondence(M_i.Structure, M_j.Structure, F) âˆ§ SatisfiesBalance(M_i, P, â€¢)
      let P_hom = HomogenizedProperty(M, P, Îµ)
      suffices to show âˆ€ i. P_hom â‰ˆ HomogenizedProperty(M_i, P, Îµ)
      {
        fix M_i âˆˆ MultiscaleDecomposition(M, Îµ)
        let P_i = HomogenizedProperty(M_i, P, Îµ)
        let F_i = MaterialConnection(M_i.Structure, P)
        have âˆ€ x âˆˆ M_i.Geometry. P_hom(x) â‰ˆ P(x) by MultiscaleLocalization(M, P, Îµ)
        also have âˆ€ x âˆˆ M_i.Geometry. P(x) â‰ˆ P_i(x) by {
          SatisfiesBalance(M_i, P, â€¢) âŠ¢ P_i â‰ˆ P on M_i  ; Homogenization commutes with balance
          HasCorrespondence(M_i.Structure, M_j.Structure, F) âŠ¢ F_i(M_i.Structure, P) â‰ˆ F_i(M_j.Structure, P)
          hence P is invariant under structure correspondences at scale Îµ
        }
        hence P_hom â‰ˆ P_i on M_i.Geometry
        hence P_hom â‰ˆ P_i globally by patching local approximations
      }
    }
  }
}


CONCEPT NegativeThermalExpansionMetamaterial : MetamaterialLanguage_v3 {
  PARAMETERS {
    Î±_micro: â„ = 1e-5 / K  ; Microscale thermal expansion coefficient
    Î±_macro: â„ = -5e-6 / K ; Target macroscale thermal expansion coefficient
    T_range: Interval(â„) = [200 K, 400 K]  ; Operating temperature range
  }

  REQUIREMENTS {
    Structure: {
      Cell(Lattice(â„Â³), Triangle(120Â°)) ; Triangular lattice with hexagonal symmetry      
      Element(Material(Al), Beam([1 Î¼m, 10 Î¼m], [1 Î¼m, 1 Î¼m]))   ; Aluminum microbeams
      Bond(Hinge(1), Periodic(Lattice))  ; Hinged bonds with lattice periodicity
    }
    Properties: {
      ThermalExpansion(T: â„): Tensor(1,1) = Î±_micro * ðˆ  on Element  ; Microscale thermal expansion
      ThermalExpansion(T: â„): Tensor(1,1) = Î±_macro * ðˆ  on Cell    ; Macroscale thermal expansion
    }
    Processes: {
      HeatTransfer(T: â„): VectorField = -k * âˆ‡(T)  ; Fourier's law of heat conduction  
      Deformation(T: â„): VectorField = âˆ«_{T_0}^T Î±(Ï„) dÏ„  ; Thermal strain integration
    }
    Constraints: {
      âˆ€ T âˆˆ T_range. MinEigenvalue(ThermalExpansion(T)) > 0  ; Positive microscale expansion
      âˆ€ T âˆˆ T_range. MaxEigenvalue(ThermalExpansion(T)) < 0  ; Negative macroscale expansion
    }  
  }

  PROOF {
    theorem NegativeThermalExpansionDesign:
      âˆƒ M: Material. 
        MultiscaleDecomposition(M, Micro) = Element âˆ§
        MultiscaleDecomposition(M, Macro) = Cell âˆ§
        âˆ€ T âˆˆ T_range. SatisfiesBalance(M.Structure, ThermalExpansion(T), HeatTransfer(T), Deformation(T)) âˆ§
        âˆ€ T âˆˆ T_range. Constraints(ThermalExpansion(T))
    {
      // Step 1: Construct the microscale triangular lattice structure
      let a: â„ = 10 * Î¼m  ; Lattice constant  
      let Element = Material(Al) * Beam([1 Î¼m, 10 Î¼m], [1 Î¼m, 1 Î¼m])
      let Bond = Hinge(1) * Periodic(Lattice(a))
      let Cell = Lattice(â„Â³) * Triangle(120Â°, a)
      
      // Step 2: Assign the thermal expansion properties at micro and macro scales
      let Î±_micro_tensor: Tensor(1,1) = Î±_micro * ðˆ
      let Î±_macro_tensor: Tensor(1,1) = Î±_macro * ðˆ
      let ThermalExpansion_micro(T) = Field(Element, Tensor(1,1), Î±_micro_tensor)
      let ThermalExpansion_macro(T) = Field(Cell, Tensor(1,1), Î±_macro_tensor)
      
      // Step 3: Define the heat transfer and deformation processes
      let HeatTransfer(T) = -k * âˆ‡(T) on Cell
      let Deformation(T) = âˆ«_{T_0}^T Î±(Ï„) dÏ„ on Cell
      
      // Step 4: Construct the multiscale material with structure and properties
      let M = Material(
        Structure(Cell, Element, Bond),
        Properties(ThermalExpansion_micro, ThermalExpansion_macro),
        Processes(HeatTransfer, Deformation)
      )
      
      // Step 5: Verify the balance equations and constraints at each scale
      let S = M.Structure
      let P(T) = ThermalExpansion_macro(T)
      let F_S(T) = HeatTransfer(T)  
      let F_P(T) = Deformation(T)
      
      have âˆ€ T âˆˆ T_range. SatisfiesBalance(S, P(T), F_S(T), F_P(T)) by {
        SatisfiesBalance(S, P, F_S, F_P) :- {
          âˆ‡ â‹… F_S + dP/dt = 0  ; Heat equation
          âˆ‡ â‹… F_P = P         ; Kinematic compatibility
        }
        ; Automatic verification of the balance equations
      }
      
      have âˆ€ T âˆˆ T_range. Constraints(ThermalExpansion_micro(T)) by {
        âˆ€ T. MinEigenvalue(ThermalExpansion_micro(T)) = Î±_micro > 0
      }
      
      have âˆ€ T âˆˆ T_range. Constraints(ThermalExpansion_macro(T)) by {
        âˆ€ T. MaxEigenvalue(ThermalExpansion_macro(T)) = Î±_macro < 0   
      }
      
      // Step 6: Verify the multiscale decomposition and consistency
      have MultiscaleDecomposition(M, Micro) = Element by definition
      have MultiscaleDecomposition(M, Macro) = Cell by definition
      
      have âˆ€ T âˆˆ T_range. IsEquivariant(Deformation(T), â€¢) by {
        ; Deformation is equivariant under rigid body transformations
        âˆ€ g: Symmetry(S). g âˆ˜ Deformation(T) = Deformation(T) âˆ˜ g
      }
      
      have âˆ€ T âˆˆ T_range. MultiscaleConsistency(M, ThermalExpansion(T), Deformation(T)) by {
        ; Apply the MultiscaleConsistency axiom
        let F = Deformation(T)
        have IsEquivariant(F, â€¢) from above
        hence F(M) â‰ˆ â¨_{M_i âˆˆ {Element, Cell}} F(M_i)
      }
      
      hence proved.
    }
  }
}