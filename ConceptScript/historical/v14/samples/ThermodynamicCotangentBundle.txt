CONCEPT ThermodynamicCotangentBundle {
  LANGUAGE {
    type System = ThermodynamicSystem(States, Observables)
    type State = MacroState(System) | MicroState(System)  
    type Observable = Function(State -> â„)
    
    type PhaseSpace = CotangentBundle(StateSpace(System))
    type StateSpace = Manifold(States(System))
    type dq = Coordinate(StateSpace)  ; Generalized coordinates 
    type dp = Coordinate(Fiber(PhaseSpace))  ; Generalized momenta
    
    notation "H" = Hamiltonian(Observable)
    notation "Î²" = InverseTemperature(Observable)
    notation "S" = Entropy(Observable) 
    notation "p(x)" = Probability(MicroState -> â„)
    
    axiom CoordinateTransformation(q: dq, p: dp, Q: dq, P: dp):
      (q, p) â‰ˆ (Q(q), P(q, p))  ; Canonical transformations
      
    axiom CanonicalCommutation(q: dq, p: dp):
      {q, p} = 1  ; Poisson bracket  
      
    axiom CanonicalDistribution(H: Observable, Î²: Observable, p: Probability):  
      p(x) = (1/Z) exp(-Î² H(x))  ; Boltzmann distribution
  }

  STRUCTURE {
    ThermodynamicQuantities: {
      def InternalEnergy(System) = <H>
      def FreeEnergy(System) = - (1/Î²) log(Z)
      def Entropy(System) = - <log(p)> 
      def Pressure(System) = - (âˆ‚/âˆ‚V) FreeEnergy(System)
    }
    
    EnsembleEquivalence: {
      def Microcanonical(E: Observable) = 
        Uniform(x: MicroState | H(x) = E)
        
      def Canonical(Î²: Observable) = 
        (1/Z) exp(-Î² H(x)) for x: MicroState
        
      axiom Equivalence(E: Observable, Î²: Observable): 
        Microcanonical(E) â‰ˆ Canonical(Î²) as Volume(System) -> âˆ
    }
    
    MaxEntPrinciple: {
      def RelativeEntropy(p, q: Probability) = 
        <log(p/q)>_p
        
      axiom MaximumEntropy(p: Probability, E: Observable):
        p = argmax_{q: Probability} Entropy(q) 
            subject to <H>_q = E
    }
  }
  
  PROOFS {
    tactic Legendre(f: State -> â„, x: dq):
      assumes âˆ‚Â²f/âˆ‚xÂ² != 0
      let p := âˆ‚f/âˆ‚x
      let g(p) := px - f(x)  ; Legendre transform
      have âˆ‚g/âˆ‚p = x
      
    theorem EnergyRepresentation(S: Observable, Î²: Observable):  
      d S = Î² d <H>
    {
      S = - <log(p)>            ; Entropy definition  
      d S = - <dlog(p)>         
      = - <(1/p) dp>
      = - <(1/p) (dZ/Z) + Î² dH>  ; Differentiate Boltzmann dist.
      dZ/Z = -Î² d<H>            ; Differentiate partition function  
      d S = Î² d<H>              ; Simplify
    }
      
    theorem LegendreTransformHamiltonian(L: Observable, H: Observable):
      âˆ‚Â²L/âˆ‚vÂ² != 0 âŠ¢ H(q, p) = pv - L(q, v) and p = âˆ‚L/âˆ‚v  
    {  
      Legendre(L(q, Â·), v)
      hence H(q, p) = pv - L(q, v) and p = âˆ‚L/âˆ‚v
    }
      
    theorem JarzynskiEquality(W: Observable, Î²: Observable):
      <exp(-Î²W)> = exp(-Î² Î”F)
    {
      assume p(x, t) solves Fokker-Planck equation  
      let Ï†(t) := <exp(-Î²W(t))>_p  
      have dÏ†/dt = 0             ; Differentiate and apply Fokker-Planck 
      Ï†(t) = Ï†(0) = <exp(-Î²W(0))> = 1   ; W(0) = 0
      <exp(-Î²W(t))> = 1          ; Substitute 
      Î”F = - (1/Î²) log<exp(-Î²W)>   ; Jarzynski's equality
    }
  }
}




CONCEPT ThermodynamicPhaseSpace {
  LANGUAGE {
    type System = ThermodynamicSystem(States)
    type State = MacroState(System) | MicroState(System)
    type Observable = Function(State -> â„)
    
    notation "ğ’ª(S)" = SpaceOfObservables(S: System)
    notation "ğ’ª*(S)" = DualSpaceOfObservables(S: System)
    notation "âŸ¨A, BâŸ©" = DualPairing(A: Observable, B: ğ’ª*(S))
    
    notation "S(E, V)" = EntropyObservable(E: Observable, V: Observable)
    notation "F(T, P)" = FreeEnergyObservable(T: Observable, P: Observable)
    
    notation "Z(Î², V)" = PartitionFunction(Î²: Observable, V: Observable)
    notation "Ï(x; Î², V)" = BoltzmannDistribution(x: MicroState, Î²: Observable, V: Observable)
    
    notation "Ï†(E, V)" = Î¦(dE^dV) = LiouvilleForm(E: Observable, V: Observable)
    notation "Ï‰ = -dÏ†" = SymplecticForm(LiouvilleForm)
    
    axiom LegendreTransform(S: Observable, F: Observable, T: Observable, P: Observable):
      F(T, P) = âŸ¨E, TâŸ© + âŸ¨V, PâŸ© - S(E, V)
      
    axiom PartitionFunctionRelation(Z: Observable, F: Observable, Î²: Observable, P: Observable): 
      F(Î², P) = - 1/Î² * log(Z(Î², P))  
  }
  
  STRUCTURE {
    TangentSpace: {  
      type ğ’¯(S: System) = Space(Velocities(S))
      
      axiom VelocityPairing(v: ğ’¯(S), A: Observable):
        âŸ¨A, vâŸ© = d/dt|â‚€ A(Î³(t)) where Î³: (-Îµ, Îµ) -> S such that Î³(0) = s, Î³'(0) = v
    }
    
    CotangentSpace: {
      ğ’¯*(S: System) = ğ’ª*(S)   
      
      axiom MomentumMap(H: Observable, p: ğ’¯*(S)):
        âŸ¨p, vâŸ© = d/dt|â‚€ H(Î³(t)) where Î³: (-Îµ, Îµ) -> S such that Î³(0) = s, Î³'(0) = v
    }
    
    CotangentBundle: {
      T*(S: System) = S Ã— ğ’¯*(S)

      axiom CanonicalOneForm(Ï†: LiouvilleForm):  
        Ï†(s)(p, v) = âŸ¨p, vâŸ© for (s, p) âˆˆ T*(S), v âˆˆ ğ’¯â‚›(S)
      
      axiom CanonicalSymplecticForm(Ï‰: SymplecticForm, Ï†: LiouvilleForm):
        Ï‰ = -dÏ†
    }
    
    StatisticalMechanics: {
      axiom AverageObservable(A: Observable, Ï: BoltzmannDistribution):  
        âŸ¨AâŸ© = âˆ« A(x) Ï(x) dx
        
      axiom Entropy(S: Observable, Ï: BoltzmannDistribution):
        S = - k âˆ« Ï(x) log(Ï(x)) dx  
    }
  }
  
  PROOFS {
    theorem CanonicalCommutationRelations(q: Observable, p: Observable):
      {q, p} = 1 where {â‹…,â‹…} is the Poisson bracket
    {
      {q, p} = Ï‰(Xq, Xp)         ; Def. of Poisson bracket
      = dq(Xp)                    ; Ï‰(Xq, â‹…) = dq
      = LXp q                     ; Def. of Lie derivative 
      = d/dt|â‚€ (q âˆ˜ Ï†t)           ; Ï†t Hamiltonian flow of Xp 
      = d/dt|â‚€ q(t)               ; Def. of observable  
      = 1                         ; Canonical coordinate
    }
    
    theorem MaxEntPrinciple(Ï: BoltzmannDistribution, S: Observable):
      Ï = arg max_Ï' S(Ï') subject to âˆ« Ï' = 1, âˆ« E Ï' = âŸ¨EâŸ©  
    {
      Î´S - Î± Î´(âˆ« Ï) - Î² Î´(âˆ« E Ï) = 0   ; Lagrange multipliers 
      Î´(- âˆ« Ï log Ï - Î± âˆ« Ï - Î² âˆ« E Ï) = 0  ; Variation
      Î´Ï (- log Ï - 1 - Î± - Î² E) = 0     ; Function in parens is 0
      Ï = exp(- 1 - Î± - Î² E)             ; Solve for Ï
      Ï = 1/Z exp(-Î² E) where Z = exp(1 + Î±)  ; Normalize Ï 
    }
  }
}