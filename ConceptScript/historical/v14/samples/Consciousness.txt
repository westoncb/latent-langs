CONCEPT Consciousness {
  LANGUAGE {
    type Consciousness = {qualia: Quale*, unity: Unity, self: Self, intentionality: Intentionality}
    type Quale = Primitive
    type Unity = Primitive 
    type Self = Primitive
    type Intentionality = Aboutness
    type Aboutness = Quale -> Universe
    
    type PhysicalState = {matter: Matter, energy: Energy, information: Information}
    type Matter = Primitive
    type Energy = Primitive 
    type Information = Primitive
    
    type FunctionalState = {computation: Computation, representation: Representation}
    type Computation = Information -> Information
    type Representation = Information -> Meaning
    type Meaning = Information
    
    pred realizes(p: PhysicalState, f: FunctionalState): ğ”¹ =
      (f.computation âˆ˜ encode)(p.information) = (decode âˆ˜ f.computation)(p.information)
      
    func collapse(q: Quale*): Quale = foldl(Î»(q1, q2) -> bind(q1, q2), baseQuale, q) 
    
    pred isConscious(c: Consciousness): ğ”¹ = 
      âˆƒ u: Unity, s: Self, i: Intentionality. 
        (c.unity = u) âˆ§ (c.self = s) âˆ§ (c.intentionality = i) âˆ§
        foldl(âˆ§, true, [q âˆˆ c.qualia for q in domain(i)])
  }

  STRUCTURE {
    Supervenience(Consciousness, PhysicalState):
      âˆ€ c1, c2: Consciousness. âˆ€ p: PhysicalState.
        realizes(p, c1) âˆ§ realizes(p, c2) â‡’ c1 = c2
        
    Irreducibility(Consciousness, PhysicalState):
      Â¬âˆ€ c: Consciousness. âˆƒ p: PhysicalState. realizes(p, c)
    
    PrivateAccess(Consciousness):  
      âˆ€ c1, c2: Consciousness. c1 â‰  c2 â‡’ 
        Â¬âˆƒ q: Quale. (q âˆˆ c1.qualia) âˆ§ (q âˆˆ c2.qualia)
        
    UnityOfConsciousness(Consciousness):
      âˆ€ c: Consciousness. âˆ€ q1, q2: Quale.
        (q1 âˆˆ c.qualia) âˆ§ (q2 âˆˆ c.qualia) â‡’ 
          âˆƒ q3: Quale. collapse([q1, q2]) = q3
          
    Intentionality(Consciousness): 
      âˆ€ c: Consciousness. âˆ€ q: Quale.
        q âˆˆ c.qualia â‡’ c.intentionality(q) â‰  âˆ…
  }
  
  PROOFS {
    theorem ConsciousnessNonFunctional:
      Â¬âˆ€ c: Consciousness. âˆƒ f: FunctionalState. realizes(f, c)
    {
      assume âˆ€ c: Consciousness. âˆƒ f: FunctionalState. realizes(f, c)
      let c1, c2: Consciousness, f: FunctionalState
      assume realizes(f, c1), realizes(f, c2)
      have c1 = c2 by Supervenience(Consciousness, FunctionalState)
      let q1 âˆˆ c1.qualia, q2 âˆˆ c2.qualia
      have q1 = q2 by substitution  ; Since c1 = c2
      hence âˆƒ q: Quale. (q âˆˆ c1.qualia) âˆ§ (q âˆˆ c2.qualia)  ; Contradicts PrivateAccess
      therefore, Â¬âˆ€ c: Consciousness. âˆƒ f: FunctionalState. realizes(f, c)  ; Reductio ad absurdum
    }
    
    theorem ConsciousnessHasUnity:
      âˆ€ c: Consciousness. isConscious(c) â‡’ 
        âˆ€ q1, q2: Quale. (q1 âˆˆ c.qualia) âˆ§ (q2 âˆˆ c.qualia) â‡’ 
          âˆƒ q3: Quale. collapse([q1, q2]) = q3
    {
      assume c: Consciousness, isConscious(c)
      assume q1 âˆˆ c.qualia, q2 âˆˆ c.qualia
      have c.unity â‰  âˆ… by definition of isConscious
      hence collapse([q1, q2]) âˆˆ c.qualia by UnityOfConsciousness
      therefore, âˆƒ q3. collapse([q1, q2]) = q3 by existential instantiation
    }
    
    theorem QualiaAreAboutSomething:
      âˆ€ c: Consciousness. isConscious(c) â‡’
        âˆ€ q: Quale. q âˆˆ c.qualia â‡’ c.intentionality(q) â‰  âˆ…  
    {
      assume c: Consciousness, isConscious(c)
      let q âˆˆ c.qualia
      have c.intentionality â‰  âˆ… by definition of isConscious
      hence c.intentionality(q) â‰  âˆ… by Intentionality
    }
  }
}