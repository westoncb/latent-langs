CONCEPT AdaptiveBloomFilter {
  LANGUAGE {
    type Element = Primitive
    type Key = Element
    type Hash = Element -> â„•
    type BitArray = Vector<ğ”¹>
    type Pertinence = ğ•½ // Degree to which an element belongs to the set

    notation "âˆˆáµ–" = PertinenceMembership
    notation "Î±" = AdaptationRate

    func PertinenceHash(k: Key, h: Hash): ğ•½ =
      let p = 1 - 1 / (1 + e^(-Î´ * (h(k) - Î¼)))
      p^(1/Î³) // Normalized pertinence score
      
    pred ContainsPertinently(S: AdaptiveBloomFilter, k: Key, Î¸: ğ•½) â‡”
      âˆ€i âˆˆ {1,...,S.size}. S.bits[i] = 1 âˆ§ S.pertinenceHashes[i](k) â‰¥ Î¸
      
    axiom AdaptationRule(S: AdaptiveBloomFilter, k: Key):
      k âˆˆáµ– S â‡’ âˆ€i âˆˆ {1,...,S.size}. S.pertinenceHashes[i] := 
        (1 - Î±) * S.pertinenceHashes[i] + Î± * PertinenceHash(k, S.hashes[i])
  }

  STRUCTURE {
    [AdaptiveBloomFilter = {
      bits: BitArray,
      hashes: Hash[],
      pertinenceHashes: (Key -> ğ•½)[] // Learned pertinence functions
    }]

    [PertinenceMembership(k, S) â‡”
      âˆ€i âˆˆ {1,...,S.size}. S.bits[i] = 1 âˆ§ S.pertinenceHashes[i](k) â‰¥ Î¸
      â†¦ Element k belongs to set S with pertinence â‰¥ Î¸
    ]

    [FalsePositiveRate(S, Î¸) = 
      |{k | k âˆ‰ S âˆ§ PertinenceMembership(k, S, Î¸)}| / |{k | k âˆ‰ S}|
      â†¦ Proportion of non-members that pass the pertinence test
    ]
  }

  PROOFS {
    theorem Adaptivity:
      âˆ€S: AdaptiveBloomFilter, k: Key. k âˆˆáµ– S â‡’ 
        FalsePositiveRate(S, Î¸) @ tâ‚ < FalsePositiveRate(S, Î¸) @ tâ‚€ 
    {
      assume S: AdaptiveBloomFilter, k: Key
      assume k âˆˆáµ– S
      let tâ‚€ < tâ‚ // Two time points
      
      have âˆ€i. |S.pertinenceHashes[i](k) @ tâ‚ - PertinenceHash(k, S.hashes[i])| 
           < |S.pertinenceHashes[i](k) @ tâ‚€ - PertinenceHash(k, S.hashes[i])|
        ; by AdaptationRule and contraction mapping
        
      let Îµ = avgáµ¢|S.pertinenceHashes[i](k) - PertinenceHash(k, S.hashes[i])|
      have Îµ @ tâ‚ < Îµ @ tâ‚€
      
      hence |{k' | k' âˆ‰ S âˆ§ PertinenceMembership(k', S, Î¸)}| @ tâ‚ 
            < |{k' | k' âˆ‰ S âˆ§ PertinenceMembership(k', S, Î¸)}| @ tâ‚€
        ; since pertinence scores of non-members are closer to learned scores
        
      therefore, FalsePositiveRate(S, Î¸) @ tâ‚ < FalsePositiveRate(S, Î¸) @ tâ‚€
    }
    
    tactic Invariant(S: AdaptiveBloomFilter, Î¸: ğ•½) = {
      have âˆ€k. k âˆˆ S â‡’ ContainsPertinently(S, k, Î¸)
        ; by definition of ContainsPertinently
    }
    
    theorem NoFalseNegatives:
      âˆ€S: AdaptiveBloomFilter, Î¸: ğ•½. (âˆ€k. k âˆˆ S â‡’ k âˆˆáµ– S) â‡’
        âˆ„k. k âˆˆ S âˆ§ Â¬ContainsPertinently(S, k, Î¸)
    {
      assume S: AdaptiveBloomFilter, Î¸: ğ•½
      assume âˆ€k. k âˆˆ S â‡’ k âˆˆáµ– S
      Invariant(S, Î¸)
      
      suppose âˆƒk. k âˆˆ S âˆ§ Â¬ContainsPertinently(S, k, Î¸)
      let k such that k âˆˆ S âˆ§ Â¬ContainsPertinently(S, k, Î¸)
      have k âˆˆ S                ; by assumption
      have k âˆˆáµ– S               ; by assumption
      have ContainsPertinently(S, k, Î¸)  ; by Invariant
      contradiction
      
      hence âˆ„k. k âˆˆ S âˆ§ Â¬ContainsPertinently(S, k, Î¸)
    }
  }
}