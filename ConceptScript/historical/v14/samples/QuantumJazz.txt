CONCEPT QuantumJazz {
  LANGUAGE {
    type Chord = Set<Note>
    type Note = (Pitch, Duration)
    type Pitch = Frequency
    type Duration = BeatCount
    
    type Particle = (Mass, Charge, Spin)
    type Interaction = Particle -> Particle -> AmplitudeProbability
    
    notation "â™®" = Naturalness
    notation "ðŸŽ¼" = Harmonicity
    notation "ðŸŽ·" = JazzyCombination
    
    func Progression(c1: Chord, c2: Chord): Chord =
      {n | n âˆˆ c1 â™® c2 âˆ§ ðŸŽ¼(n, c1, c2)}
      
    func Naturalness(n: Note, c: Chord): ð”¹ = 
      n.Pitch âˆˆ Consonance(c) âˆ¨ (n.Duration = ðŸŽ·(c))
        
    func Interaction(p1: Particle, p2: Particle): Event =
      let a = Amplitude(FeynmanDiagram(p1, p2));
      a > 0 ? Scatter(p1, p2) : Bind(p1, p2)
  }

  STRUCTURE {
    [QuantumParticle(p) â‡” Chord(p.State)
      â†¦ A quantum particle's state is like a musical chord.
    ]

    [QuantumInteraction(i) â‡” Progression(i.Input, i.Output)  
      â†¦ Particle interactions are like chord progressions.
    ]
    
    [FeynmanDiagram(i) â‰… JazzImprovisation(i.Input, i.Output)
      â†¦ Feynman diagrams are the "jazz improvisations" of particle physics.
    ]
  }

  PROOFS {
    theorem QuantumHarmony:
      âˆ€i: Interaction. 
        let c1 = i.Input, c2 = i.Output;
        Harmonicity(c1, c2) â‡’ Amplitude(FeynmanDiagram(i)) > 0
    {
      assume i: Interaction
      let c1 = i.Input, c2 = i.Output
      assume Harmonicity(c1, c2)

      have âˆ€n âˆˆ Progression(c1, c2). Naturalness(n, c1) âˆ§ Naturalness(n, c2)  
        ; by definition of Progression and Harmonicity
      hence JazzyCombination(c1, c2)
        ; by jazz theory (trust me on this one ðŸ˜‰)
        
      have FeynmanDiagram(i) â‰… JazzImprovisation(c1, c2)
        ; by FeynmanDiagram structure  
      hence Amplitude(FeynmanDiagram(i)) > 0
        ; by amplitude of jazzy diagrams
    }
  }
}